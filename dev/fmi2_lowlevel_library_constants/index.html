<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FMI2 Constants in FMI Import/Core .jl · FMI.jl</title><meta name="title" content="FMI2 Constants in FMI Import/Core .jl · FMI.jl"/><meta property="og:title" content="FMI2 Constants in FMI Import/Core .jl · FMI.jl"/><meta property="twitter:title" content="FMI2 Constants in FMI Import/Core .jl · FMI.jl"/><meta name="description" content="Documentation for FMI.jl."/><meta property="og:description" content="Documentation for FMI.jl."/><meta property="twitter:description" content="Documentation for FMI.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FMI.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../features/">Features</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/overview/">Overview</a></li><li><a class="tocitem" href="../examples/simulate/">Simulate</a></li><li><a class="tocitem" href="../examples/parameterize/">Parameterize</a></li><li><a class="tocitem" href="../examples/multiple_instances/">Multiple instances</a></li><li><a class="tocitem" href="../examples/modelica_conference_2021/">Modelica conference 2021</a></li><li><a class="tocitem" href="../examples/manipulation/">Manipulation</a></li><li><a class="tocitem" href="../examples/multithreading/">Multithreading</a></li><li><a class="tocitem" href="../examples/multiprocessing/">Multiprocessing</a></li></ul></li><li><a class="tocitem" href="../library/">User Level API - FMI.jl</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Level API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">fmi version independent content</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../fmi_lowlevel_library_types/">Types in FMI Import/Core .jl</a></li><li><a class="tocitem" href="../fmi_lowlevel_library_constants/">Constants in FMI Import/Core .jl</a></li><li><a class="tocitem" href="../fmi_lowlevel_library_functions/">Functions in FMI Import/Core .jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox" checked/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">FMI2 specific content</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../fmi2_lowlevel_library_types/">FMI2 Types in FMI Import/Core .jl</a></li><li class="is-active"><a class="tocitem" href>FMI2 Constants in FMI Import/Core .jl</a></li><li><input class="collapse-toggle" id="menuitem-6-2-3" type="checkbox"/><label class="tocitem" for="menuitem-6-2-3"><span class="docs-label">FMI2 Functions in FMI Import/Core .jl</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../fmi2_lowlevel_modeldescription_functions/">Working with the FMI model description</a></li><li><a class="tocitem" href="../fmi2_lowlevel_library_functions/">FMI Common Concepts for Model Exchange and Co-Simulation</a></li><li><a class="tocitem" href="../fmi2_lowlevel_ME_functions/">FMI for Model Exchange</a></li><li><a class="tocitem" href="../fmi2_lowlevel_CS_functions/">FMI for Co-Simulation</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">FMI3 specific content</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../fmi3_lowlevel_library_types/">FMI3 Types in FMI Import/Core .jl</a></li><li><a class="tocitem" href="../fmi3_lowlevel_library_constants/">FMI3 Constants in FMI Import/Core .jl</a></li><li><input class="collapse-toggle" id="menuitem-6-3-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3-3"><span class="docs-label">FMI3 Functions in FMI Import/Core .jl</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../fmi3_lowlevel_modeldescription_functions/">Working with the FMI model description</a></li><li><a class="tocitem" href="../fmi3_lowlevel_library_functions/">FMI Common Concepts for Model Exchange and Co-Simulation</a></li><li><a class="tocitem" href="../fmi3_lowlevel_ME_functions/">FMI for Model Exchange</a></li><li><a class="tocitem" href="../fmi3_lowlevel_CS_functions/">FMI for Co-Simulation</a></li><li><a class="tocitem" href="../fmi3_lowlevel_SE_functions/">FMI for Scheduled Execution</a></li></ul></li></ul></li></ul></li><li><a class="tocitem" href="../index_library/">API Index</a></li><li><a class="tocitem" href="../fmi-tool-info/">FMI Tool Information</a></li><li><a class="tocitem" href="../related/">Related Publication</a></li><li><a class="tocitem" href="../contents/">Contents</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Level API</a></li><li><a class="is-disabled">FMI2 specific content</a></li><li class="is-active"><a href>FMI2 Constants in FMI Import/Core .jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FMI2 Constants in FMI Import/Core .jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ThummeTo/FMI.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="FMI2-Constants-in-FMI-Import/Core-.jl"><a class="docs-heading-anchor" href="#FMI2-Constants-in-FMI-Import/Core-.jl">FMI2 Constants in FMI Import/Core .jl</a><a id="FMI2-Constants-in-FMI-Import/Core-.jl-1"></a><a class="docs-heading-anchor-permalink" href="#FMI2-Constants-in-FMI-Import/Core-.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi2True" href="#FMICore.fmi2True"><code>FMICore.fmi2True</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions</p><p>To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section. All definitions in this section are provided in the header file “fmi2TypesPlatform.h”.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.2/src/FMI2/cconst.jl#L131-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi2False" href="#FMICore.fmi2False"><code>FMICore.fmi2False</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions</p><p>To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section. All definitions in this section are provided in the header file “fmi2TypesPlatform.h”.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.2/src/FMI2/cconst.jl#L131-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi2StatusOK" href="#FMICore.fmi2StatusOK"><code>FMICore.fmi2StatusOK</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions</p><p>Status returned by functions. The status has the following meaning:</p><ul><li>fmi2OK – all well</li><li>fmi2Warning – things are not quite right, but the computation can continue. Function “logger” was called in the model (see below), and it is expected that this function has shown the prepared information message to the user.</li><li>fmi2Discard – this return status is only possible if explicitly defined for the corresponding function</li></ul><p>(ModelExchange: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2SetContinuousStates, fmi2GetReal, fmi2GetDerivatives, fmi2GetContinuousStates, fmi2GetEventIndicators; CoSimulation: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2DoStep, fmiGetXXXStatus): For “model exchange”: It is recommended to perform a smaller step size and evaluate the model equations again, for example because an iterative solver in the model did not converge or because a function is outside of its domain (for example sqrt(&lt;negative number&gt;)). If this is not possible, the simulation has to be terminated. For “co-simulation”: fmi2Discard is returned also if the slave is not able to return the required status information. The master has to decide if the simulation run can be continued. In both cases, function “logger” was called in the FMU (see below) and it is expected that this function has shown the prepared information message to the user if the FMU was called in debug mode (loggingOn = fmi2True). Otherwise, “logger” should not show a message.</p><ul><li>fmi2Error – the FMU encountered an error. The simulation cannot be continued with this FMU instance. If one of the functions returns fmi2Error, it can be tried to restart the simulation from a formerly stored FMU state by calling fmi2SetFMUstate.</li></ul><p>This can be done if the capability flag canGetAndSetFMUstate is true and fmi2GetFMUstate was called before in non-erroneous state. If not, the simulation cannot be continued and fmi2FreeInstance or fmi2Reset must be called afterwards.4 Further processing is possible after this call; especially other FMU instances are not affected. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user.</p><ul><li>fmi2Fatal – the model computations are irreparably corrupted for all FMU instances. [For example, due to a run-time exception such as access violation or integer division by zero during the execution of an fmi function]. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user. It is not possible to call any other function for any of the FMU instances.</li><li>fmi2Pending – this status is returned only from the co-simulation interface, if the slave executes the function in an asynchronous way. That means the slave starts to compute but returns immediately. The master has to call fmi2GetStatus(..., fmi2DoStepStatus) to determine if the slave has finished the computation. Can be returned only by fmi2DoStep and by fmi2GetStatus (see section 4.2.3).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.2/src/FMI2/cconst.jl#L47-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi2StatusWarning" href="#FMICore.fmi2StatusWarning"><code>FMICore.fmi2StatusWarning</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions</p><p>Status returned by functions. The status has the following meaning:</p><ul><li>fmi2OK – all well</li><li>fmi2Warning – things are not quite right, but the computation can continue. Function “logger” was called in the model (see below), and it is expected that this function has shown the prepared information message to the user.</li><li>fmi2Discard – this return status is only possible if explicitly defined for the corresponding function</li></ul><p>(ModelExchange: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2SetContinuousStates, fmi2GetReal, fmi2GetDerivatives, fmi2GetContinuousStates, fmi2GetEventIndicators; CoSimulation: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2DoStep, fmiGetXXXStatus): For “model exchange”: It is recommended to perform a smaller step size and evaluate the model equations again, for example because an iterative solver in the model did not converge or because a function is outside of its domain (for example sqrt(&lt;negative number&gt;)). If this is not possible, the simulation has to be terminated. For “co-simulation”: fmi2Discard is returned also if the slave is not able to return the required status information. The master has to decide if the simulation run can be continued. In both cases, function “logger” was called in the FMU (see below) and it is expected that this function has shown the prepared information message to the user if the FMU was called in debug mode (loggingOn = fmi2True). Otherwise, “logger” should not show a message.</p><ul><li>fmi2Error – the FMU encountered an error. The simulation cannot be continued with this FMU instance. If one of the functions returns fmi2Error, it can be tried to restart the simulation from a formerly stored FMU state by calling fmi2SetFMUstate.</li></ul><p>This can be done if the capability flag canGetAndSetFMUstate is true and fmi2GetFMUstate was called before in non-erroneous state. If not, the simulation cannot be continued and fmi2FreeInstance or fmi2Reset must be called afterwards.4 Further processing is possible after this call; especially other FMU instances are not affected. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user.</p><ul><li>fmi2Fatal – the model computations are irreparably corrupted for all FMU instances. [For example, due to a run-time exception such as access violation or integer division by zero during the execution of an fmi function]. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user. It is not possible to call any other function for any of the FMU instances.</li><li>fmi2Pending – this status is returned only from the co-simulation interface, if the slave executes the function in an asynchronous way. That means the slave starts to compute but returns immediately. The master has to call fmi2GetStatus(..., fmi2DoStepStatus) to determine if the slave has finished the computation. Can be returned only by fmi2DoStep and by fmi2GetStatus (see section 4.2.3).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.2/src/FMI2/cconst.jl#L47-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi2StatusPending" href="#FMICore.fmi2StatusPending"><code>FMICore.fmi2StatusPending</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions</p><p>Status returned by functions. The status has the following meaning:</p><ul><li>fmi2OK – all well</li><li>fmi2Warning – things are not quite right, but the computation can continue. Function “logger” was called in the model (see below), and it is expected that this function has shown the prepared information message to the user.</li><li>fmi2Discard – this return status is only possible if explicitly defined for the corresponding function</li></ul><p>(ModelExchange: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2SetContinuousStates, fmi2GetReal, fmi2GetDerivatives, fmi2GetContinuousStates, fmi2GetEventIndicators; CoSimulation: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2DoStep, fmiGetXXXStatus): For “model exchange”: It is recommended to perform a smaller step size and evaluate the model equations again, for example because an iterative solver in the model did not converge or because a function is outside of its domain (for example sqrt(&lt;negative number&gt;)). If this is not possible, the simulation has to be terminated. For “co-simulation”: fmi2Discard is returned also if the slave is not able to return the required status information. The master has to decide if the simulation run can be continued. In both cases, function “logger” was called in the FMU (see below) and it is expected that this function has shown the prepared information message to the user if the FMU was called in debug mode (loggingOn = fmi2True). Otherwise, “logger” should not show a message.</p><ul><li>fmi2Error – the FMU encountered an error. The simulation cannot be continued with this FMU instance. If one of the functions returns fmi2Error, it can be tried to restart the simulation from a formerly stored FMU state by calling fmi2SetFMUstate.</li></ul><p>This can be done if the capability flag canGetAndSetFMUstate is true and fmi2GetFMUstate was called before in non-erroneous state. If not, the simulation cannot be continued and fmi2FreeInstance or fmi2Reset must be called afterwards.4 Further processing is possible after this call; especially other FMU instances are not affected. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user.</p><ul><li>fmi2Fatal – the model computations are irreparably corrupted for all FMU instances. [For example, due to a run-time exception such as access violation or integer division by zero during the execution of an fmi function]. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user. It is not possible to call any other function for any of the FMU instances.</li><li>fmi2Pending – this status is returned only from the co-simulation interface, if the slave executes the function in an asynchronous way. That means the slave starts to compute but returns immediately. The master has to call fmi2GetStatus(..., fmi2DoStepStatus) to determine if the slave has finished the computation. Can be returned only by fmi2DoStep and by fmi2GetStatus (see section 4.2.3).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.2/src/FMI2/cconst.jl#L47-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi2StatusError" href="#FMICore.fmi2StatusError"><code>FMICore.fmi2StatusError</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions</p><p>Status returned by functions. The status has the following meaning:</p><ul><li>fmi2OK – all well</li><li>fmi2Warning – things are not quite right, but the computation can continue. Function “logger” was called in the model (see below), and it is expected that this function has shown the prepared information message to the user.</li><li>fmi2Discard – this return status is only possible if explicitly defined for the corresponding function</li></ul><p>(ModelExchange: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2SetContinuousStates, fmi2GetReal, fmi2GetDerivatives, fmi2GetContinuousStates, fmi2GetEventIndicators; CoSimulation: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2DoStep, fmiGetXXXStatus): For “model exchange”: It is recommended to perform a smaller step size and evaluate the model equations again, for example because an iterative solver in the model did not converge or because a function is outside of its domain (for example sqrt(&lt;negative number&gt;)). If this is not possible, the simulation has to be terminated. For “co-simulation”: fmi2Discard is returned also if the slave is not able to return the required status information. The master has to decide if the simulation run can be continued. In both cases, function “logger” was called in the FMU (see below) and it is expected that this function has shown the prepared information message to the user if the FMU was called in debug mode (loggingOn = fmi2True). Otherwise, “logger” should not show a message.</p><ul><li>fmi2Error – the FMU encountered an error. The simulation cannot be continued with this FMU instance. If one of the functions returns fmi2Error, it can be tried to restart the simulation from a formerly stored FMU state by calling fmi2SetFMUstate.</li></ul><p>This can be done if the capability flag canGetAndSetFMUstate is true and fmi2GetFMUstate was called before in non-erroneous state. If not, the simulation cannot be continued and fmi2FreeInstance or fmi2Reset must be called afterwards.4 Further processing is possible after this call; especially other FMU instances are not affected. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user.</p><ul><li>fmi2Fatal – the model computations are irreparably corrupted for all FMU instances. [For example, due to a run-time exception such as access violation or integer division by zero during the execution of an fmi function]. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user. It is not possible to call any other function for any of the FMU instances.</li><li>fmi2Pending – this status is returned only from the co-simulation interface, if the slave executes the function in an asynchronous way. That means the slave starts to compute but returns immediately. The master has to call fmi2GetStatus(..., fmi2DoStepStatus) to determine if the slave has finished the computation. Can be returned only by fmi2DoStep and by fmi2GetStatus (see section 4.2.3).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.2/src/FMI2/cconst.jl#L47-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi2StatusDiscard" href="#FMICore.fmi2StatusDiscard"><code>FMICore.fmi2StatusDiscard</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions</p><p>Status returned by functions. The status has the following meaning:</p><ul><li>fmi2OK – all well</li><li>fmi2Warning – things are not quite right, but the computation can continue. Function “logger” was called in the model (see below), and it is expected that this function has shown the prepared information message to the user.</li><li>fmi2Discard – this return status is only possible if explicitly defined for the corresponding function</li></ul><p>(ModelExchange: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2SetContinuousStates, fmi2GetReal, fmi2GetDerivatives, fmi2GetContinuousStates, fmi2GetEventIndicators; CoSimulation: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2DoStep, fmiGetXXXStatus): For “model exchange”: It is recommended to perform a smaller step size and evaluate the model equations again, for example because an iterative solver in the model did not converge or because a function is outside of its domain (for example sqrt(&lt;negative number&gt;)). If this is not possible, the simulation has to be terminated. For “co-simulation”: fmi2Discard is returned also if the slave is not able to return the required status information. The master has to decide if the simulation run can be continued. In both cases, function “logger” was called in the FMU (see below) and it is expected that this function has shown the prepared information message to the user if the FMU was called in debug mode (loggingOn = fmi2True). Otherwise, “logger” should not show a message.</p><ul><li>fmi2Error – the FMU encountered an error. The simulation cannot be continued with this FMU instance. If one of the functions returns fmi2Error, it can be tried to restart the simulation from a formerly stored FMU state by calling fmi2SetFMUstate.</li></ul><p>This can be done if the capability flag canGetAndSetFMUstate is true and fmi2GetFMUstate was called before in non-erroneous state. If not, the simulation cannot be continued and fmi2FreeInstance or fmi2Reset must be called afterwards.4 Further processing is possible after this call; especially other FMU instances are not affected. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user.</p><ul><li>fmi2Fatal – the model computations are irreparably corrupted for all FMU instances. [For example, due to a run-time exception such as access violation or integer division by zero during the execution of an fmi function]. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user. It is not possible to call any other function for any of the FMU instances.</li><li>fmi2Pending – this status is returned only from the co-simulation interface, if the slave executes the function in an asynchronous way. That means the slave starts to compute but returns immediately. The master has to call fmi2GetStatus(..., fmi2DoStepStatus) to determine if the slave has finished the computation. Can be returned only by fmi2DoStep and by fmi2GetStatus (see section 4.2.3).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.2/src/FMI2/cconst.jl#L47-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi2StatusFatal" href="#FMICore.fmi2StatusFatal"><code>FMICore.fmi2StatusFatal</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions</p><p>Status returned by functions. The status has the following meaning:</p><ul><li>fmi2OK – all well</li><li>fmi2Warning – things are not quite right, but the computation can continue. Function “logger” was called in the model (see below), and it is expected that this function has shown the prepared information message to the user.</li><li>fmi2Discard – this return status is only possible if explicitly defined for the corresponding function</li></ul><p>(ModelExchange: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2SetContinuousStates, fmi2GetReal, fmi2GetDerivatives, fmi2GetContinuousStates, fmi2GetEventIndicators; CoSimulation: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2DoStep, fmiGetXXXStatus): For “model exchange”: It is recommended to perform a smaller step size and evaluate the model equations again, for example because an iterative solver in the model did not converge or because a function is outside of its domain (for example sqrt(&lt;negative number&gt;)). If this is not possible, the simulation has to be terminated. For “co-simulation”: fmi2Discard is returned also if the slave is not able to return the required status information. The master has to decide if the simulation run can be continued. In both cases, function “logger” was called in the FMU (see below) and it is expected that this function has shown the prepared information message to the user if the FMU was called in debug mode (loggingOn = fmi2True). Otherwise, “logger” should not show a message.</p><ul><li>fmi2Error – the FMU encountered an error. The simulation cannot be continued with this FMU instance. If one of the functions returns fmi2Error, it can be tried to restart the simulation from a formerly stored FMU state by calling fmi2SetFMUstate.</li></ul><p>This can be done if the capability flag canGetAndSetFMUstate is true and fmi2GetFMUstate was called before in non-erroneous state. If not, the simulation cannot be continued and fmi2FreeInstance or fmi2Reset must be called afterwards.4 Further processing is possible after this call; especially other FMU instances are not affected. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user.</p><ul><li>fmi2Fatal – the model computations are irreparably corrupted for all FMU instances. [For example, due to a run-time exception such as access violation or integer division by zero during the execution of an fmi function]. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user. It is not possible to call any other function for any of the FMU instances.</li><li>fmi2Pending – this status is returned only from the co-simulation interface, if the slave executes the function in an asynchronous way. That means the slave starts to compute but returns immediately. The master has to call fmi2GetStatus(..., fmi2DoStepStatus) to determine if the slave has finished the computation. Can be returned only by fmi2DoStep and by fmi2GetStatus (see section 4.2.3).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.2/src/FMI2/cconst.jl#L47-L62">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fmi2_lowlevel_library_types/">« FMI2 Types in FMI Import/Core .jl</a><a class="docs-footer-nextpage" href="../fmi2_lowlevel_modeldescription_functions/">Working with the FMI model description »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 14 December 2023 08:48">Thursday 14 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
