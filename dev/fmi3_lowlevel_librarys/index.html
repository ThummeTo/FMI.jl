<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FMI3 specific content · FMI.jl</title><meta name="title" content="FMI3 specific content · FMI.jl"/><meta property="og:title" content="FMI3 specific content · FMI.jl"/><meta property="twitter:title" content="FMI3 specific content · FMI.jl"/><meta name="description" content="Documentation for FMI.jl."/><meta property="og:description" content="Documentation for FMI.jl."/><meta property="twitter:description" content="Documentation for FMI.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FMI.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../features/">Features</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/overview/">Overview</a></li><li><a class="tocitem" href="../examples/simulate/">Simulate</a></li><li><a class="tocitem" href="../examples/parameterize/">Parameterize</a></li><li><a class="tocitem" href="../examples/multiple_instances/">Multiple instances</a></li><li><a class="tocitem" href="../examples/modelica_conference_2021/">Modelica conference 2021</a></li><li><a class="tocitem" href="../examples/manipulation/">Manipulation</a></li><li><a class="tocitem" href="../examples/multithreading/">Multithreading</a></li><li><a class="tocitem" href="../examples/multiprocessing/">Multiprocessing</a></li></ul></li><li><a class="tocitem" href="../library/">User Level API - FMI.jl</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Level API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">fmi version independent content</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../fmi_lowlevel_library_types/">Types in FMI Import/Core .jl</a></li><li><a class="tocitem" href="../fmi_lowlevel_library_constants/">Constants in FMI Import/Core .jl</a></li><li><a class="tocitem" href="../fmi_lowlevel_library_functions/">Functions in FMI Import/Core .jl</a></li></ul></li><li><a class="tocitem" href="../fmi2_lowlevel_librarys/">FMI2 specific content</a></li><li class="is-active"><a class="tocitem" href>FMI3 specific content</a><ul class="internal"><li><a class="tocitem" href="#FMI-Common-Concepts-for-Model-Exchange-and-Co-Simulation"><span>FMI Common Concepts for Model Exchange and Co-Simulation</span></a></li><li><a class="tocitem" href="#FMI-for-Model-Exchange"><span>FMI for Model Exchange</span></a></li><li><a class="tocitem" href="#FMI-for-Co-Simulation"><span>FMI for Co-Simulation</span></a></li><li><a class="tocitem" href="#non-FMI-spec-functions"><span>non FMI-spec functions</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../index_library/">API Index</a></li><li><a class="tocitem" href="../fmi-tool-info/">FMI Tool Information</a></li><li><a class="tocitem" href="../related/">Related Publication</a></li><li><a class="tocitem" href="../contents/">Contents</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Level API</a></li><li class="is-active"><a href>FMI3 specific content</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FMI3 specific content</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ThummeTo/FMI.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="library"><a class="docs-heading-anchor" href="#library">FMI Import/Core .jl Library Functions/Types for FMI3</a><a id="library-1"></a><a class="docs-heading-anchor-permalink" href="#library" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.FMU3" href="#FMICore.FMU3"><code>FMICore.FMU3</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.1. Header Files and Naming of Functions</p><p>The mutable struct representing an FMU in the FMI 3.0 Standard. Also contains the paths to the FMU and ZIP folder as well als all the FMI 3.0 function pointers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/struct.jl#L361-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.FMU3Instance" href="#FMICore.FMU3Instance"><code>FMICore.FMU3Instance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1:: 2.2.1. Header Files and Naming of Functions</p><p>The mutable struct represents a pointer to an FMU specific data structure that contains the information needed to process the model equations or to process the co-simulation of the model/subsystem represented by the FMU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/struct.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.FMU3InstanceEnvironment" href="#FMICore.FMU3InstanceEnvironment"><code>FMICore.FMU3InstanceEnvironment</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This is a pointer to a data structure in the importer. Using this pointer, data may be transferred between the importer and callback functions the importer provides with the instantiation functions.</p><p>Source: FMISpec 3.0.1 [2.2.3. Platform Dependent Definitions]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/struct.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3Struct" href="#FMIImport.fmi3Struct"><code>FMIImport.fmi3Struct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Union containing a <a href="#FMICore.FMU3"><code>FMU3</code></a> or a <a href="#FMICore.FMU3Instance"><code>FMU3Instance</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMIImport.jl#L155-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3StructMD" href="#FMIImport.fmi3StructMD"><code>FMIImport.fmi3StructMD</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Union containing a <a href="#FMICore.FMU3"><code>FMU3</code></a>, a <a href="#FMICore.FMU3Instance"><code>FMU3Instance</code></a> or a <a href="#FMICore.fmi3ModelDescription"><code>fmi3ModelDescription</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMIImport.jl#L166-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Initial" href="#FMICore.fmi3Initial"><code>FMICore.fmi3Initial</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1:2.4.7.5. Type specific properties Enumeration that defines how the variable is initialized, i.e. if a fmi3Set{VariableType} is allowed and how the FMU internally treats this value in Instantiated and Initialization Mode. For the variable with causality = independent, the attribute initial must not be provided, because its start value is set with the startTime parameter of fmi3EnterInitializationMode.</p><p>The attribute initial for other variables can have the following values and meanings:</p><p>exact - The variable is initialized with the start value (provided under the variable type element).</p><p>approx - The start value provides an approximation that may be modified during initialization, e.g., if the FMU is part of an algebraic loop where the variable might be an iteration variable and start value is taken as initial value for an iterative solution process.</p><p>calculated - The variable is calculated from other variables during initialization. It is not allowed to provide a start value.</p><p>If initial is not present, it is defined by Table 22 based on causality and variability. If initial = exact or approx, or causality = input, a start value must be provided. If initial = calculated, or causality = independent, it is not allowed to provide a start value.</p><p>[The environment decides when to use the start value of a variable with causality = input. Examples: * Automatic tests of FMUs are performed, and the FMU is tested by providing the start value as constant input. * For a Model Exchange FMU, the FMU might be part of an algebraic loop. If the input variable is iteration variable of this algebraic loop, then initialization starts with its start value.]</p><p>If fmi3Set{VariableType} is not called on a variable with causality = input, then the FMU must use the start value as value of this input.</p><p>Added prefix &quot;fmi3&quot; to help with redefinition of constans in enums.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L148-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.FMU3Solution" href="#FMICore.FMU3Solution"><code>FMICore.FMU3Solution</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The mutable struct representing a specific Solution of a FMI2 FMU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/struct.jl#L281-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Variable" href="#FMICore.fmi3Variable"><code>FMICore.fmi3Variable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.4.7. Definition of Model Variables</p><p>A fmi3Variable describes the the type, name, valueRefence and optional information for every variable in the Modeldescription.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/ctype.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3VariableDependency" href="#FMICore.fmi3VariableDependency"><code>FMICore.fmi3VariableDependency</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Mutable Struct representing existance and kind of dependencies of an Unknown on Known Variables.</p><p>See also FMI3.0.1 Spec [fig 30]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/ctype.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SimpleType" href="#FMICore.fmi3SimpleType"><code>FMICore.fmi3SimpleType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ToDo: Not implemented</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/ctype.jl#L1080-L1083">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Type" href="#FMICore.fmi3Type"><code>FMICore.fmi3Type</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable</p><p>Argument fmuType defines the type of the FMU:</p><ul><li>fmi3ModelExchange: FMU with initialization and events; between events simulation of continuous systems is performed with external integrators from the environment.</li><li>fmi3CoSimulation: Black box interface for co-simulation.</li><li>fmi3ScheduledExecution: Concurrent computation of model partitions on a single computational resource (e.g. CPU-core)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L184-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Unit" href="#FMICore.fmi3Unit"><code>FMICore.fmi3Unit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ToDo: Not implemented</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/ctype.jl#L1072-L1075">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Float32" href="#FMICore.fmi3Float32"><code>FMICore.fmi3Float32</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions</p><p>To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section.  All definitions in this section are provided in the header file fmi3PlatformTypes.h. It is required to use this definition for all binary FMUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Float64" href="#FMICore.fmi3Float64"><code>FMICore.fmi3Float64</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions</p><p>To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section.  All definitions in this section are provided in the header file fmi3PlatformTypes.h. It is required to use this definition for all binary FMUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Int8" href="#FMICore.fmi3Int8"><code>FMICore.fmi3Int8</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions</p><p>To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section.  All definitions in this section are provided in the header file fmi3PlatformTypes.h. It is required to use this definition for all binary FMUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Int16" href="#FMICore.fmi3Int16"><code>FMICore.fmi3Int16</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions</p><p>To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section.  All definitions in this section are provided in the header file fmi3PlatformTypes.h. It is required to use this definition for all binary FMUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Int32" href="#FMICore.fmi3Int32"><code>FMICore.fmi3Int32</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions</p><p>To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section.  All definitions in this section are provided in the header file fmi3PlatformTypes.h. It is required to use this definition for all binary FMUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Int64" href="#FMICore.fmi3Int64"><code>FMICore.fmi3Int64</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions</p><p>To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section.  All definitions in this section are provided in the header file fmi3PlatformTypes.h. It is required to use this definition for all binary FMUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3UInt8" href="#FMICore.fmi3UInt8"><code>FMICore.fmi3UInt8</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions</p><p>To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section.  All definitions in this section are provided in the header file fmi3PlatformTypes.h. It is required to use this definition for all binary FMUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3UInt16" href="#FMICore.fmi3UInt16"><code>FMICore.fmi3UInt16</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions</p><p>To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section.  All definitions in this section are provided in the header file fmi3PlatformTypes.h. It is required to use this definition for all binary FMUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3UInt32" href="#FMICore.fmi3UInt32"><code>FMICore.fmi3UInt32</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions</p><p>To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section.  All definitions in this section are provided in the header file fmi3PlatformTypes.h. It is required to use this definition for all binary FMUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3UInt64" href="#FMICore.fmi3UInt64"><code>FMICore.fmi3UInt64</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions</p><p>To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section.  All definitions in this section are provided in the header file fmi3PlatformTypes.h. It is required to use this definition for all binary FMUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3True" href="#FMICore.fmi3True"><code>FMICore.fmi3True</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>fmi3Boolean</code> TODO</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L178-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3False" href="#FMICore.fmi3False"><code>FMICore.fmi3False</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>fmi3Boolean</code> TODO</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L178-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3ValueReferenceFormat" href="#FMIImport.fmi3ValueReferenceFormat"><code>FMIImport.fmi3ValueReferenceFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Union of (wildcard for) all ways to describe and pass a fmi3ValueReference (e.g. String, Int64, Array, fmi3ValueReference, ...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMIImport.jl#L29-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3IntervalQualifier" href="#FMICore.fmi3IntervalQualifier"><code>FMICore.fmi3IntervalQualifier</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.9.4. Scheduled Execution Enumeration that defines the IntervalQualifiers which describe how to treat the intervals and intervalCounters arguments. They have the following meaning: fmi3IntervalNotYetKnown -  is returned for a countdown aperiodic Clock for which the next interval is not yet known. This qualifier value can only be returned directly after the Clock was active and previous calls to fmi3GetInterval never returned fmi3IntervalChanged (nor fmi3IntervalUnchanged). In Scheduled Execution this return value means that the corresponding model partition cannot be scheduled yet.</p><p>fmi3IntervalUnchanged - is returned if a previous call to fmi3GetInterval already returned a value qualified with fmi3IntervalChanged which has not changed since. In Scheduled Execution this means the corresponding model partition has already been scheduled.</p><p>fmi3IntervalChanged - is returned to indicate that the value for the interval has changed for this Clock. Any previously returned intervals (if any) are overwritten with the current value. The new Clock interval is relative to the time of the current Event Mode or Clock Update Mode in contrast to the interval of a periodic Clock, where the interval is defined as the time between consecutive Clock ticks. In Scheduled Execution this means that the corresponding model partition has to be scheduled or re-scheduled (if a previous call to fmi3GetInterval returned fmi3IntervalChanged).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L198-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Variability" href="#FMICore.fmi3Variability"><code>FMICore.fmi3Variability</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.4.7.4. Variable Attributes Enumeration that defines the time dependency of the variable, in other words, it defines the time instants when a variable can change its value. [The purpose of this attribute is to define when a result value needs to be inquired and to be stored. For example, discrete variables change their values only at event instants (ME) or at a communication point (CS and SE) and it is therefore only necessary to inquire them with fmi3Get{VariableType} and store them at event times.] Allowed values of this enumeration: constant - The value of the variable never changes.</p><p>fixed - The value of the variable is fixed after initialization, in other words, after fmi3ExitInitializationMode was called the variable value does not change anymore.</p><p>tunable - The value of the variable is constant between events (ME) and between communication points (CS and SE) due to changing variables with causality = parameter and variability = tunable. Whenever a parameter with variability = tunable changes, an event is triggered externally (ME or CS if events are supported), or the change is performed at the next communication point (CS and SE) and the variables with variability = tunable and causality = calculatedParameter or output must be newly computed. [tunable inputs are not allowed, see Table 18.]</p><p>discrete - Model Exchange: The value of the variable is constant between external and internal events (= time, state, step events defined implicitly in the FMU). Co-Simulation: By convention, the variable is from a real sampled data system and its value is only changed at communication points (including event handling). During intermediateUpdate, discrete variables are not allowed to change. [If the simulation algorithm notices a change in a discrete variable during intermediateUpdate, the simulation algorithm will delay the change, raise an event with earlyReturnRequested == fmi3True and during the communication point it can change the discrete variable, followed by event handling.]</p><p>continuous - Only a variable of type == fmi3GetFloat32 or type == fmi3GetFloat64 can be continuous. Model Exchange: No restrictions on value changes (see Section 4.1.1).</p><p>The default is continuous for variables of type &lt;Float32&gt; and &lt;Float64&gt;, and discrete for all other types.</p><p>For variables of type Clock and clocked variables the variability is always discrete or tunable.</p><p>[Note that the information about continuous states is defined with elements &lt;ContinuousStateDerivative&gt; in &lt;ModelStructure&gt;.]</p><p>Added prefix &quot;fmi3&quot; to help with redefinition of constans in enums.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L116-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3DependencyKind" href="#FMICore.fmi3DependencyKind"><code>FMICore.fmi3DependencyKind</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.10. Dependencies of Variables</p><p>Enumeration that defines the dependencies a single unknown variable vunknown can have in relation to a known variable vknown. They have the following meaning: dependent - no particular structure, f(.., v_{known,i}, ..)</p><p>Only for floating point type unknowns v_{unknown}:</p><p>constant - constant factor, c ⋅ v_{known,i} where c is an expression that is evaluated before fmi3EnterInitializationMode is called.</p><p>Only for floating point type unknowns v_{unknown} in Event and Continuous-Time Mode (ME) and at communication points (CS and SE), and not for &lt;InitialUnknown&gt; for Initialization Mode:</p><p>fixed - fixed factor, p⋅v_{known,i} where p is an expression that is evaluated before fmi3ExitInitializationMode is called.</p><p>tunable - tunable factor, p⋅v_{known,i} where p is an expression that is evaluated before fmi3ExitInitializationMode is called and in Event Mode due to event handling (ME) or at a communication point (CS and SE)</p><p>discrete - discrete factor, d⋅v_{known,i} where d is an expression that is evaluated before fmi3ExitInitializationMode is called and in Event Mode due to an external or internal event or at a communication point (CS and SE).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L239-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.FMU3Event" href="#FMICore.FMU3Event"><code>FMICore.FMU3Event</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Container for event related information. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/struct.jl#L252-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.FMU3ExecutionConfiguration" href="#FMICore.FMU3ExecutionConfiguration"><code>FMICore.FMU3ExecutionConfiguration</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A mutable struct representing the excution configuration of a FMU. For FMUs that have issues with calls like <code>fmi3Reset</code> or <code>fmi3FreeInstance</code>, this is pretty useful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/struct.jl#L160-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Status" href="#FMICore.fmi3Status"><code>FMICore.fmi3Status</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions Defines the status flag (an enumeration of type fmi3Status defined in file fmi3FunctionTypes.h) that is returned by functions to indicate the success of the function call: The status has the following meaning:</p><ul><li>fmi3OK: The call was successful. The output argument values are defined.</li><li>fmi3Warning: A non-critical problem was detected, but the computation can continue. The output argument values are defined. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings.</li></ul><p>[In certain applications, e.g. in a prototyping environment, warnings may be acceptable. For production environments warnings should be treated like errors unless they can be safely ignored.]</p><ul><li>fmi3Discard: The call was not successful and the FMU is in the same state as before the call. The output argument values are not defined, but the computation can continue. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. Advanced simulation algorithms can try alternative approaches to drive the simulation by calling the function with different arguments or calling another function. Otherwise the simulation algorithm has to treat this return code like fmi3Error and has to terminate the simulation.</li></ul><p>[Examples for usage of fmi3Discard are handling of min/max violation, or signal numerical problems during model evaluation forcing smaller step sizes.]</p><ul><li>fmi3Error: The call failed. The output argument values are undefined and the simulation cannot be continued. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. If a function returns fmi3Error, it is possible to restore a previously retrieved FMU state by calling fmi3SetFMUState. Otherwise fmi3FreeInstance or fmi3Reset must be called. When detecting illegal arguments or a function call not allowed in the current state according to the respective state machine, the FMU must return fmi3Error. Other instances of this FMU are not affected by the error.</li><li>fmi3Fatal: The state of all instances of the model is irreparably corrupted. [For example, due to a runtime exception such as access violation or integer division by zero during the execution of an FMI function.] Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings, if still possible. It is not allowed to call any other function for any instance of the FMU.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StatusOK" href="#FMICore.fmi3StatusOK"><code>FMICore.fmi3StatusOK</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions Defines the status flag (an enumeration of type fmi3Status defined in file fmi3FunctionTypes.h) that is returned by functions to indicate the success of the function call: The status has the following meaning:</p><ul><li>fmi3OK: The call was successful. The output argument values are defined.</li><li>fmi3Warning: A non-critical problem was detected, but the computation can continue. The output argument values are defined. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings.</li></ul><p>[In certain applications, e.g. in a prototyping environment, warnings may be acceptable. For production environments warnings should be treated like errors unless they can be safely ignored.]</p><ul><li>fmi3Discard: The call was not successful and the FMU is in the same state as before the call. The output argument values are not defined, but the computation can continue. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. Advanced simulation algorithms can try alternative approaches to drive the simulation by calling the function with different arguments or calling another function. Otherwise the simulation algorithm has to treat this return code like fmi3Error and has to terminate the simulation.</li></ul><p>[Examples for usage of fmi3Discard are handling of min/max violation, or signal numerical problems during model evaluation forcing smaller step sizes.]</p><ul><li>fmi3Error: The call failed. The output argument values are undefined and the simulation cannot be continued. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. If a function returns fmi3Error, it is possible to restore a previously retrieved FMU state by calling fmi3SetFMUState. Otherwise fmi3FreeInstance or fmi3Reset must be called. When detecting illegal arguments or a function call not allowed in the current state according to the respective state machine, the FMU must return fmi3Error. Other instances of this FMU are not affected by the error.</li><li>fmi3Fatal: The state of all instances of the model is irreparably corrupted. [For example, due to a runtime exception such as access violation or integer division by zero during the execution of an FMI function.] Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings, if still possible. It is not allowed to call any other function for any instance of the FMU.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StatusWarning" href="#FMICore.fmi3StatusWarning"><code>FMICore.fmi3StatusWarning</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions Defines the status flag (an enumeration of type fmi3Status defined in file fmi3FunctionTypes.h) that is returned by functions to indicate the success of the function call: The status has the following meaning:</p><ul><li>fmi3OK: The call was successful. The output argument values are defined.</li><li>fmi3Warning: A non-critical problem was detected, but the computation can continue. The output argument values are defined. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings.</li></ul><p>[In certain applications, e.g. in a prototyping environment, warnings may be acceptable. For production environments warnings should be treated like errors unless they can be safely ignored.]</p><ul><li>fmi3Discard: The call was not successful and the FMU is in the same state as before the call. The output argument values are not defined, but the computation can continue. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. Advanced simulation algorithms can try alternative approaches to drive the simulation by calling the function with different arguments or calling another function. Otherwise the simulation algorithm has to treat this return code like fmi3Error and has to terminate the simulation.</li></ul><p>[Examples for usage of fmi3Discard are handling of min/max violation, or signal numerical problems during model evaluation forcing smaller step sizes.]</p><ul><li>fmi3Error: The call failed. The output argument values are undefined and the simulation cannot be continued. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. If a function returns fmi3Error, it is possible to restore a previously retrieved FMU state by calling fmi3SetFMUState. Otherwise fmi3FreeInstance or fmi3Reset must be called. When detecting illegal arguments or a function call not allowed in the current state according to the respective state machine, the FMU must return fmi3Error. Other instances of this FMU are not affected by the error.</li><li>fmi3Fatal: The state of all instances of the model is irreparably corrupted. [For example, due to a runtime exception such as access violation or integer division by zero during the execution of an FMI function.] Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings, if still possible. It is not allowed to call any other function for any instance of the FMU.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StatusDiscard" href="#FMICore.fmi3StatusDiscard"><code>FMICore.fmi3StatusDiscard</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions Defines the status flag (an enumeration of type fmi3Status defined in file fmi3FunctionTypes.h) that is returned by functions to indicate the success of the function call: The status has the following meaning:</p><ul><li>fmi3OK: The call was successful. The output argument values are defined.</li><li>fmi3Warning: A non-critical problem was detected, but the computation can continue. The output argument values are defined. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings.</li></ul><p>[In certain applications, e.g. in a prototyping environment, warnings may be acceptable. For production environments warnings should be treated like errors unless they can be safely ignored.]</p><ul><li>fmi3Discard: The call was not successful and the FMU is in the same state as before the call. The output argument values are not defined, but the computation can continue. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. Advanced simulation algorithms can try alternative approaches to drive the simulation by calling the function with different arguments or calling another function. Otherwise the simulation algorithm has to treat this return code like fmi3Error and has to terminate the simulation.</li></ul><p>[Examples for usage of fmi3Discard are handling of min/max violation, or signal numerical problems during model evaluation forcing smaller step sizes.]</p><ul><li>fmi3Error: The call failed. The output argument values are undefined and the simulation cannot be continued. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. If a function returns fmi3Error, it is possible to restore a previously retrieved FMU state by calling fmi3SetFMUState. Otherwise fmi3FreeInstance or fmi3Reset must be called. When detecting illegal arguments or a function call not allowed in the current state according to the respective state machine, the FMU must return fmi3Error. Other instances of this FMU are not affected by the error.</li><li>fmi3Fatal: The state of all instances of the model is irreparably corrupted. [For example, due to a runtime exception such as access violation or integer division by zero during the execution of an FMI function.] Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings, if still possible. It is not allowed to call any other function for any instance of the FMU.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StatusError" href="#FMICore.fmi3StatusError"><code>FMICore.fmi3StatusError</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions Defines the status flag (an enumeration of type fmi3Status defined in file fmi3FunctionTypes.h) that is returned by functions to indicate the success of the function call: The status has the following meaning:</p><ul><li>fmi3OK: The call was successful. The output argument values are defined.</li><li>fmi3Warning: A non-critical problem was detected, but the computation can continue. The output argument values are defined. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings.</li></ul><p>[In certain applications, e.g. in a prototyping environment, warnings may be acceptable. For production environments warnings should be treated like errors unless they can be safely ignored.]</p><ul><li>fmi3Discard: The call was not successful and the FMU is in the same state as before the call. The output argument values are not defined, but the computation can continue. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. Advanced simulation algorithms can try alternative approaches to drive the simulation by calling the function with different arguments or calling another function. Otherwise the simulation algorithm has to treat this return code like fmi3Error and has to terminate the simulation.</li></ul><p>[Examples for usage of fmi3Discard are handling of min/max violation, or signal numerical problems during model evaluation forcing smaller step sizes.]</p><ul><li>fmi3Error: The call failed. The output argument values are undefined and the simulation cannot be continued. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. If a function returns fmi3Error, it is possible to restore a previously retrieved FMU state by calling fmi3SetFMUState. Otherwise fmi3FreeInstance or fmi3Reset must be called. When detecting illegal arguments or a function call not allowed in the current state according to the respective state machine, the FMU must return fmi3Error. Other instances of this FMU are not affected by the error.</li><li>fmi3Fatal: The state of all instances of the model is irreparably corrupted. [For example, due to a runtime exception such as access violation or integer division by zero during the execution of an FMI function.] Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings, if still possible. It is not allowed to call any other function for any instance of the FMU.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StatusFatal" href="#FMICore.fmi3StatusFatal"><code>FMICore.fmi3StatusFatal</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions Defines the status flag (an enumeration of type fmi3Status defined in file fmi3FunctionTypes.h) that is returned by functions to indicate the success of the function call: The status has the following meaning:</p><ul><li>fmi3OK: The call was successful. The output argument values are defined.</li><li>fmi3Warning: A non-critical problem was detected, but the computation can continue. The output argument values are defined. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings.</li></ul><p>[In certain applications, e.g. in a prototyping environment, warnings may be acceptable. For production environments warnings should be treated like errors unless they can be safely ignored.]</p><ul><li>fmi3Discard: The call was not successful and the FMU is in the same state as before the call. The output argument values are not defined, but the computation can continue. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. Advanced simulation algorithms can try alternative approaches to drive the simulation by calling the function with different arguments or calling another function. Otherwise the simulation algorithm has to treat this return code like fmi3Error and has to terminate the simulation.</li></ul><p>[Examples for usage of fmi3Discard are handling of min/max violation, or signal numerical problems during model evaluation forcing smaller step sizes.]</p><ul><li>fmi3Error: The call failed. The output argument values are undefined and the simulation cannot be continued. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. If a function returns fmi3Error, it is possible to restore a previously retrieved FMU state by calling fmi3SetFMUState. Otherwise fmi3FreeInstance or fmi3Reset must be called. When detecting illegal arguments or a function call not allowed in the current state according to the respective state machine, the FMU must return fmi3Error. Other instances of this FMU are not affected by the error.</li><li>fmi3Fatal: The state of all instances of the model is irreparably corrupted. [For example, due to a runtime exception such as access violation or integer division by zero during the execution of an FMI function.] Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings, if still possible. It is not allowed to call any other function for any instance of the FMU.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Annotation" href="#FMICore.fmi3Annotation"><code>FMICore.fmi3Annotation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A not further specified annotation struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L63-L65">source</a></section></article><h2 id="FMI-Common-Concepts-for-Model-Exchange-and-Co-Simulation"><a class="docs-heading-anchor" href="#FMI-Common-Concepts-for-Model-Exchange-and-Co-Simulation">FMI Common Concepts for Model Exchange and Co-Simulation</a><a id="FMI-Common-Concepts-for-Model-Exchange-and-Co-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#FMI-Common-Concepts-for-Model-Exchange-and-Co-Simulation" title="Permalink"></a></h2><p>In both cases, FMI defines an input/output block of a dynamic model where the distribution of the block, the platform dependent header file, several access functions, as well as the schema files are identical.</p><h3 id="Reading-the-model-description"><a class="docs-heading-anchor" href="#Reading-the-model-description">Reading the model description</a><a id="Reading-the-model-description-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-the-model-description" title="Permalink"></a></h3><p>This section documents functions to inquire information about the model description of an FMU.</p><h4 id="Load/Parse-the-FMI-model-description"><a class="docs-heading-anchor" href="#Load/Parse-the-FMI-model-description">Load/Parse the FMI model description</a><a id="Load/Parse-the-FMI-model-description-1"></a><a class="docs-heading-anchor-permalink" href="#Load/Parse-the-FMI-model-description" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3ModelDescription" href="#FMICore.fmi3ModelDescription"><code>FMICore.fmi3ModelDescription</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.4.1. Definition of an FMU</p><p>The central FMU data structure defining all variables of the FMU that are visible/accessible via the FMU functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/ctype.jl#L1088-L1092">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3LoadModelDescription" href="#FMIImport.fmi3LoadModelDescription"><code>FMIImport.fmi3LoadModelDescription</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Extract the FMU variables and meta data from the ModelDescription</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L23-L25">source</a></section></article><h4 id="Get-value-functions"><a class="docs-heading-anchor" href="#Get-value-functions">Get value functions</a><a id="Get-value-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Get-value-functions" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetDefaultStartTime" href="#FMIImport.fmi3GetDefaultStartTime"><code>FMIImport.fmi3GetDefaultStartTime</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns startTime from DefaultExperiment if defined else defaults to nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L652-L654">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetDefaultStopTime" href="#FMIImport.fmi3GetDefaultStopTime"><code>FMIImport.fmi3GetDefaultStopTime</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns stopTime from DefaultExperiment if defined else defaults to nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L662-L664">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetDefaultTolerance" href="#FMIImport.fmi3GetDefaultTolerance"><code>FMIImport.fmi3GetDefaultTolerance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns tolerance from DefaultExperiment if defined else defaults to nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L672-L674">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetDefaultStepSize" href="#FMIImport.fmi3GetDefaultStepSize"><code>FMIImport.fmi3GetDefaultStepSize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns stepSize from DefaultExperiment if defined else defaults to nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L682-L684">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetModelName" href="#FMIImport.fmi3GetModelName"><code>FMIImport.fmi3GetModelName</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the tag &#39;modelName&#39; from the model description.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L692-L694">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetInstantiationToken" href="#FMIImport.fmi3GetInstantiationToken"><code>FMIImport.fmi3GetInstantiationToken</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the tag &#39;instantionToken&#39; from the model description.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L699-L701">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetGenerationTool" href="#FMIImport.fmi3GetGenerationTool"><code>FMIImport.fmi3GetGenerationTool</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the tag &#39;generationtool&#39; from the model description.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L706-L708">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetGenerationDateAndTime" href="#FMIImport.fmi3GetGenerationDateAndTime"><code>FMIImport.fmi3GetGenerationDateAndTime</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the tag &#39;generationdateandtime&#39; from the model description.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L713-L715">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetVariableNamingConvention" href="#FMIImport.fmi3GetVariableNamingConvention"><code>FMIImport.fmi3GetVariableNamingConvention</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the tag &#39;varaiblenamingconvention&#39; from the model description.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L720-L722">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetNumberOfEventIndicators" href="#FMIImport.fmi3GetNumberOfEventIndicators"><code>FMIImport.fmi3GetNumberOfEventIndicators</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetNumberOfEventIndicators(c::FMU3Instance)</code></pre><p>This function returns the number of event indicators. This function can only be called in Model Exchange. </p><p><code>fmi3GetNumberOfEventIndicators</code> must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Returns</strong></p><ul><li><code>size::Integer</code>: Return <code>size</code> is the number of event indicators of this instance </li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.3.2. State: Instantiated</li></ul><p>See also <a href="#FMIImport.fmi3GetNumberOfEventIndicators"><code>fmi3GetNumberOfEventIndicators</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2296-L2316">source</a></section><section><div><p>Returns the number of EventIndicators from the model description.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L727-L729">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetNumberOfEventIndicators!" href="#FMICore.fmi3GetNumberOfEventIndicators!"><code>FMICore.fmi3GetNumberOfEventIndicators!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetNumberOfEventIndicators!(c::FMU3Instance, nEventIndicators::Ref{Csize_t})</code></pre><p>This function returns the number of event indicators. This function can only be called in Model Exchange. </p><p><code>fmi3GetNumberOfEventIndicators</code> must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>nEventIndicators::Ref{Csize_t}</code>: Stores the number of continuous states returned by the function</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.2. State: Instantiated</li></ul><p>See also <a href="#FMICore.fmi3GetNumberOfEventIndicators!"><code>fmi3GetNumberOfEventIndicators!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2376-L2404">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.2. State: Instantiated</p><p>This function returns the number of event indicators. This function can only be called in Model Exchange. </p><p>fmi3GetNumberOfEventIndicators must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1120-L1127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3IsCoSimulation" href="#FMIImport.fmi3IsCoSimulation"><code>FMIImport.fmi3IsCoSimulation</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns true, if the FMU supports co simulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L734-L736">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3IsModelExchange" href="#FMIImport.fmi3IsModelExchange"><code>FMIImport.fmi3IsModelExchange</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns true, if the FMU supports model exchange</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L741-L743">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3IsScheduledExecution" href="#FMIImport.fmi3IsScheduledExecution"><code>FMIImport.fmi3IsScheduledExecution</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns true, if the FMU supports scheduled execution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L747-L749">source</a></section></article><h4 id="Information-functions"><a class="docs-heading-anchor" href="#Information-functions">Information functions</a><a id="Information-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Information-functions" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetModelIdentifier" href="#FMIImport.fmi3GetModelIdentifier"><code>FMIImport.fmi3GetModelIdentifier</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the tag &#39;modelIdentifier&#39; from CS or ME section.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L758-L760">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3ProvidesAdjointDerivatives" href="#FMIImport.fmi3ProvidesAdjointDerivatives"><code>FMIImport.fmi3ProvidesAdjointDerivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns true, if the FMU provides adjoint derivatives</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L794-L796">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3CanGetSetState" href="#FMIImport.fmi3CanGetSetState"><code>FMIImport.fmi3CanGetSetState</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns true, if the FMU supports the getting/setting of states</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L771-L773">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3CanSerializeFMUState" href="#FMIImport.fmi3CanSerializeFMUState"><code>FMIImport.fmi3CanSerializeFMUState</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns true, if the FMU state can be serialized</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L779-L781">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3ProvidesDirectionalDerivatives" href="#FMIImport.fmi3ProvidesDirectionalDerivatives"><code>FMIImport.fmi3ProvidesDirectionalDerivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns true, if the FMU provides directional derivatives</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/md.jl#L787-L789">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetVersion" href="#FMICore.fmi3GetVersion"><code>FMICore.fmi3GetVersion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetVersion(fmu::FMU3)</code></pre><p><strong>Arguments</strong></p><ul><li><code>fmu::FMU3</code>: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.</li></ul><p><strong>Returns</strong></p><ul><li>Returns a string from the address of a C-style (NUL-terminated) string. The string represents the version of the “fmi3Functions.h” header file which was used to compile the functions of the FMU. The function returns “fmiVersion” which is defined in this header file. The standard header file as documented in this specification has version “3.0”</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4. Inquire Version Number of Header Files</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L178-L191">source</a></section><section><div><pre><code class="language-julia hljs">function fmi3GetVersion(fmu::FMU3)</code></pre><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Returns</strong></p><ul><li>Returns a string from the address of a C-style (NUL-terminated) string. The string represents the version of the “fmi3Functions.h” header file which was used to compile the functions of the FMU. The function returns “fmiVersion” which is defined in this header file. The standard header file as documented in this specification has version “3.0”</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4. Inquire Version Number of Header Files</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L199-L211">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.4. Inquire Version Number of Header Files</p><p>This function returns fmi3Version of the fmi3Functions.h header file which was used to compile the functions of the FMU. This function call is allowed always and in all interface types.</p><p>The standard header file as documented in this specification has version &quot;3.0-beta.2&quot;, so this function returns &quot;3.0-beta.2&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L96-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3VariableNamingConvention" href="#FMICore.fmi3VariableNamingConvention"><code>FMICore.fmi3VariableNamingConvention</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.4.7.5.1. Variable Naming Conventions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L217-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3VariableNamingConventionFlat" href="#FMICore.fmi3VariableNamingConventionFlat"><code>FMICore.fmi3VariableNamingConventionFlat</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.4.7.5.1. Variable Naming Conventions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L217-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3VariableNamingConventionStructured" href="#FMICore.fmi3VariableNamingConventionStructured"><code>FMICore.fmi3VariableNamingConventionStructured</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.4.7.5.1. Variable Naming Conventions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L217-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3VariableNamingConventionToString" href="#FMICore.fmi3VariableNamingConventionToString"><code>FMICore.fmi3VariableNamingConventionToString</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3VariableNamingConventionToString(c::fmi3VariableNamingConvention)</code></pre><p>Convert <a href="#FMICore.fmi3VariableNamingConvention"><code>fmi3VariableNamingConvention</code></a> <code>c</code> to the corresponding String (&quot;flat&quot;, &quot;structured&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L229-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StringToVariableNamingConvention" href="#FMICore.fmi3StringToVariableNamingConvention"><code>FMICore.fmi3StringToVariableNamingConvention</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3StringToVariableNamingConvention(s::AbstractString)</code></pre><p>Convert <code>s</code> (&quot;flat&quot;, &quot;structured&quot;) to the corresponding <a href="#FMICore.fmi3VariableNamingConvention"><code>fmi3VariableNamingConvention</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StringToVariability" href="#FMICore.fmi3StringToVariability"><code>FMICore.fmi3StringToVariability</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3StringToVariability(s::AbstractString)</code></pre><p>Convert <code>s</code> (&quot;constant&quot;, &quot;fixed&quot;, &quot;tunable&quot;, &quot;discrete&quot;, &quot;continuous&quot;) to the corresponding <a href="#FMICore.fmi3Variability"><code>fmi3Variability</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3VariabilityToString" href="#FMICore.fmi3VariabilityToString"><code>FMICore.fmi3VariabilityToString</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3VariabilityToString(c::fmi3Variability)</code></pre><p>Convert <a href="#FMICore.fmi3Variability"><code>fmi3Variability</code></a> <code>c</code> to the corresponding String (&quot;constant&quot;, &quot;fixed&quot;, &quot;tunable&quot;, &quot;discrete&quot;, &quot;continuous&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StatusToString" href="#FMICore.fmi3StatusToString"><code>FMICore.fmi3StatusToString</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3StatusToString(status::Union{fmi3Status, Integer})</code></pre><p>Converts <code>fmi3Status</code> <code>status</code> into a String (&quot;OK&quot;, &quot;Warning&quot;, &quot;Discard&quot;, &quot;Error&quot;, &quot;Fatal&quot;, &quot;Unknown&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StringToStatus" href="#FMICore.fmi3StringToStatus"><code>FMICore.fmi3StringToStatus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3CausalityToString(c::fmi3Causality)</code></pre><p>Convert <a href="#FMICore.fmi3Causality"><code>fmi3Causality</code></a> <code>c</code> to the corresponding String (&quot;parameter&quot;, &quot;calculatedParameter&quot;, &quot;structuralParameter&quot;, &quot;input&quot;, &quot;output&quot;, &quot;local&quot;, &quot;independent&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3DependencyKindToString" href="#FMICore.fmi3DependencyKindToString"><code>FMICore.fmi3DependencyKindToString</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3DependencyKindToString(c::fmi3DependencyKind)</code></pre><p>Convert <a href="#FMICore.fmi3DependencyKind"><code>fmi3DependencyKind</code></a> <code>c</code> to the corresponding String (&quot;independent&quot;, &quot;dependent&quot;, &quot;constant&quot;, &quot;fixed&quot;, &quot;tunable&quot;, &quot;discrete&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StringToDependencyKind" href="#FMICore.fmi3StringToDependencyKind"><code>FMICore.fmi3StringToDependencyKind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3StringToDependencyKind(s::AbstractString)</code></pre><p>Convert <code>s</code> (&quot;independent&quot;, &quot;dependent&quot;, &quot;constant&quot;, &quot;fixed&quot;, &quot;tunable&quot;, &quot;discrete&quot;) to the corresponding <a href="#FMICore.fmi3DependencyKind"><code>fmi3DependencyKind</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L205-L209">source</a></section></article><h3 id="Creation,-Destruction-and-Logging-of-FMU-Instances"><a class="docs-heading-anchor" href="#Creation,-Destruction-and-Logging-of-FMU-Instances">Creation, Destruction and Logging of FMU Instances</a><a id="Creation,-Destruction-and-Logging-of-FMU-Instances-1"></a><a class="docs-heading-anchor-permalink" href="#Creation,-Destruction-and-Logging-of-FMU-Instances" title="Permalink"></a></h3><p>This section documents functions that deal with instantiation, destruction and logging of FMUs.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3InstantiateCoSimulation" href="#FMICore.fmi3InstantiateCoSimulation"><code>FMICore.fmi3InstantiateCoSimulation</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1:: 2.3.1. Super State: FMU State Setable</p><p>This function instantiates a Co-Simulation FMU (see Section 4). It is allowed to call this function only if modelDescription.xml includes a &lt;CoSimulation&gt; element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3InstantiateCoSimulation!" href="#FMIImport.fmi3InstantiateCoSimulation!"><code>FMIImport.fmi3InstantiateCoSimulation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3InstantiateCoSimulation!(fmu::FMU3; instanceName::String=fmu.modelName, type::fmi3Type=fmu.type, pushInstances::Bool = true, visible::Bool = false, loggingOn::Bool = fmu.executionConfig.loggingOn, externalCallbacks::Bool = fmu.executionConfig.externalCallbacks, 
    eventModeUsed::Bool = false, ptrIntermediateUpdate=nothing, logStatusOK::Bool=true, logStatusWarning::Bool=true, logStatusDiscard::Bool=true, logStatusError::Bool=true, logStatusFatal::Bool=true)</code></pre><p>Create a new coSimulation instance of the given fmu, adds a logger if <code>logginOn == true</code>.</p><p><strong>Arguments</strong></p><ul><li><code>fmu::FMU3</code>: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.</li></ul><p><strong>Keywords</strong></p><ul><li><code>instanceName::String=fmu.modelName</code>: Name of the instance</li><li><code>type::fmi3Type=fmu.type</code>: Defines whether a Co-Simulation or Model Exchange is present</li><li><code>pushInstances::Bool = true</code>: Defines if the fmu instances should be pushed in the application.</li><li><code>visible::Bool = false</code> if the FMU should be started with graphic interface, if supported (default=<code>false</code>)</li><li><code>loggingOn::Bool = fmu.executionConfig.loggingOn</code> if the FMU should log and display function calls (default=<code>false</code>)</li><li><code>externalCallbacks::Bool = fmu.executionConfig.externalCallbacks</code> if an external shared library should be used for the fmi3CallbackFunctions, this may improve readability of logging messages (default=<code>false</code>)</li><li><code>eventModeUsed::Bool = false</code>: Defines if the FMU instance can use the event mode. (default=<code>false</code>)</li><li><code>ptrIntermediateUpdate=nothing</code>: Points to a function handling intermediate Updates (defalut=<code>nothing</code>) </li><li><code>logStatusOK::Bool=true</code> whether to log status of kind <code>fmi3OK</code> (default=<code>true</code>)</li><li><code>logStatusWarning::Bool=true</code> whether to log status of kind <code>fmi3Warning</code> (default=<code>true</code>)</li><li><code>logStatusDiscard::Bool=true</code> whether to log status of kind <code>fmi3Discard</code> (default=<code>true</code>)</li><li><code>logStatusError::Bool=true</code> whether to log status of kind <code>fmi3Error</code> (default=<code>true</code>)</li><li><code>logStatusFatal::Bool=true</code> whether to log status of kind <code>fmi3Fatal</code> (default=<code>true</code>)</li></ul><p><strong>Returns</strong></p><ul><li>Returns the instance of a new FMU coSimulation instance.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.4.7  Model variables</li><li>FMISpec3.0: 2.3.1. Super State: FMU State Setable</li></ul><p>See also <a href="#@ref"><code>fmi3InstantiateCoSimulation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L456-L490">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3InstantiateModelExchange" href="#FMICore.fmi3InstantiateModelExchange"><code>FMICore.fmi3InstantiateModelExchange</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1:: 2.3.1. Super State: FMU State Setable</p><p>This function instantiates a Model Exchange FMU (see Section 3). It is allowed to call this function only if modelDescription.xml includes a &lt;ModelExchange&gt; element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3InstantiateModelExchange!" href="#FMIImport.fmi3InstantiateModelExchange!"><code>FMIImport.fmi3InstantiateModelExchange!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3InstantiateModelExchange!(fmu::FMU3; instanceName::String=fmu.modelName, type::fmi3Type=fmu.type, pushInstances::Bool = true, visible::Bool = false, loggingOn::Bool = fmu.executionConfig.loggingOn, externalCallbacks::Bool = fmu.executionConfig.externalCallbacks,
    logStatusOK::Bool=true, logStatusWarning::Bool=true, logStatusDiscard::Bool=true, logStatusError::Bool=true, logStatusFatal::Bool=true)</code></pre><p>Create a new modelExchange instance of the given fmu, adds a logger if <code>logginOn == true</code>.</p><p><strong>Arguments</strong></p><ul><li><code>fmu::FMU3</code>: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.</li></ul><p><strong>Keywords</strong></p><ul><li><code>instanceName::String=fmu.modelName</code>: Name of the instance</li><li><code>type::fmi3Type=fmu.type</code>: Defines whether a Co-Simulation or Model Exchange is present</li><li><code>pushInstances::Bool = true</code>: Defines if the fmu instances should be pushed in the application.</li><li><code>visible::Bool = false</code> if the FMU should be started with graphic interface, if supported (default=<code>false</code>)</li><li><code>loggingOn::Bool = fmu.executionConfig.loggingOn</code> if the FMU should log and display function calls (default=<code>false</code>)</li><li><code>externalCallbacks::Bool = fmu.executionConfig.externalCallbacks</code> if an external shared library should be used for the fmi3CallbackFunctions, this may improve readability of logging messages (default=<code>false</code>)</li><li><code>logStatusOK::Bool=true</code> whether to log status of kind <code>fmi3OK</code> (default=<code>true</code>)</li><li><code>logStatusWarning::Bool=true</code> whether to log status of kind <code>fmi3Warning</code> (default=<code>true</code>)</li><li><code>logStatusDiscard::Bool=true</code> whether to log status of kind <code>fmi3Discard</code> (default=<code>true</code>)</li><li><code>logStatusError::Bool=true</code> whether to log status of kind <code>fmi3Error</code> (default=<code>true</code>)</li><li><code>logStatusFatal::Bool=true</code> whether to log status of kind <code>fmi3Fatal</code> (default=<code>true</code>)</li></ul><p><strong>Returns</strong></p><ul><li>Returns the instance of a new FMU modelExchange instance.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.4.7  Model variables</li><li>FMISpec3.0: 2.3.1. Super State: FMU State Setable</li></ul><p>See also <a href="#@ref"><code>fmi3InstantiateModelExchange</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L341-L373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3InstantiateScheduledExecution" href="#FMICore.fmi3InstantiateScheduledExecution"><code>FMICore.fmi3InstantiateScheduledExecution</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1:: 2.3.1. Super State: FMU State Setable</p><p>This function instantiates a Scheduled Execution FMU (see Section 4). It is allowed to call this function only if modelDescription.xml includes a &lt;ScheduledExecution&gt; element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3InstantiateScheduledExecution!" href="#FMIImport.fmi3InstantiateScheduledExecution!"><code>FMIImport.fmi3InstantiateScheduledExecution!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3InstantiateScheduledExecution!(fmu::FMU3; ptrlockPreemption::Ptr{Cvoid}, ptrunlockPreemption::Ptr{Cvoid}, instanceName::String=fmu.modelName, type::fmi3Type=fmu.type, pushInstances::Bool = true, visible::Bool = false, loggingOn::Bool = fmu.executionConfig.loggingOn, externalCallbacks::Bool = fmu.executionConfig.externalCallbacks, 
    logStatusOK::Bool=true, logStatusWarning::Bool=true, logStatusDiscard::Bool=true, logStatusError::Bool=true, logStatusFatal::Bool=true)</code></pre><p>Create a new ScheduledExecution instance of the given fmu, adds a logger if <code>logginOn == true</code>.</p><p><strong>Arguments</strong></p><ul><li><code>fmu::FMU3</code>: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.</li></ul><p><strong>Keywords</strong></p><ul><li><code>ptrlockPreemption::Ptr{Cvoid}</code>: Points to a function handling locking Preemption</li><li><code>ptrunlockPreemption::Ptr{Cvoid}</code>: Points to a function handling unlocking Preemption</li><li><code>instanceName::String=fmu.modelName</code>: Name of the instance</li><li><code>type::fmi3Type=fmu.type</code>: Defines whether a Co-Simulation or Model Exchange is present</li><li><code>pushInstances::Bool = true</code>: Defines if the fmu instances should be pushed in the application.</li><li><code>visible::Bool = false</code> if the FMU should be started with graphic interface, if supported (default=<code>false</code>)</li><li><code>loggingOn::Bool = fmu.executionConfig.loggingOn</code> if the FMU should log and display function calls (default=<code>false</code>)</li><li><code>externalCallbacks::Bool = fmu.executionConfig.externalCallbacks</code> if an external shared library should be used for the fmi3CallbackFunctions, this may improve readability of logging messages (default=<code>false</code>)</li><li><code>logStatusOK::Bool=true</code> whether to log status of kind <code>fmi3OK</code> (default=<code>true</code>)</li><li><code>logStatusWarning::Bool=true</code> whether to log status of kind <code>fmi3Warning</code> (default=<code>true</code>)</li><li><code>logStatusDiscard::Bool=true</code> whether to log status of kind <code>fmi3Discard</code> (default=<code>true</code>)</li><li><code>logStatusError::Bool=true</code> whether to log status of kind <code>fmi3Error</code> (default=<code>true</code>)</li><li><code>logStatusFatal::Bool=true</code> whether to log status of kind <code>fmi3Fatal</code> (default=<code>true</code>)</li></ul><p><strong>Returns</strong></p><ul><li>Returns the instance of a new FMU ScheduledExecution instance.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.4.7  Model variables</li><li>FMISpec3.0: 2.3.1. Super State: FMU State Setable</li></ul><p>See also <a href="#@ref"><code>fmi3InstantiateScheduledExecution</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L577-L611">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3FreeInstance!" href="#FMICore.fmi3FreeInstance!"><code>FMICore.fmi3FreeInstance!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3FreeInstance!(c::FMU3Instance; popInstance::Bool = true)</code></pre><p>Disposes the given instance, unloads the loaded model, and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface. If a null pointer is provided for “c”, the function call is ignored (does not have an effect).</p><p>Removes the component from the FMUs component list.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Keywords</strong></p><ul><li><code>popInstance::Bool=true</code>: If the Keyword <code>popInstance = true</code> the freed instance is deleted</li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L144-L165">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable</p><p>Disposes the given instance, unloads the loaded model, and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface. If a NULL pointer is provided for argument instance, the function call is ignored (does not have an effect).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L110-L114">source</a></section><section><div><pre><code class="language-julia hljs">fmi3FreeInstance!(fmu::FMU3)</code></pre><p>Wrapper for <code>fmi3FreeInstance!(c::FMU3Instance; popInstance::Bool = true)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetDebugLogging" href="#FMICore.fmi3SetDebugLogging"><code>FMICore.fmi3SetDebugLogging</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetDebugLogging(c::FMU3Instance, logginOn::fmi3Boolean, nCategories::UInt, categories::Ptr{Nothing})</code></pre><p>Control the use of the logging callback function, version independent.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>logginOn::fmi3Boolean</code>: If <code>loggingOn = fmi3True</code>, debug logging is enabled for the log categories specified in categories, otherwise it is disabled. Type <code>fmi3Boolean</code> is defined as an alias Type for the C-Type Boolean and is to be used with <code>fmi3True</code> and <code>fmi3False</code>.</li><li><code>nCategories::UInt</code>: Argument <code>nCategories</code> defines the length of the argument <code>categories</code>.</li><li><code>categories::Ptr{Nothing}</code>:</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.1. Super State: FMU State Setable</li></ul><p>See also <a href="#FMICore.fmi3SetDebugLogging"><code>fmi3SetDebugLogging</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L230-L257">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetDebugLogging(c::FMU3Instance)</code></pre><p>Set the DebugLogger for the FMU.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Returns</strong></p><ul><li>Returns a warning if <code>str.state</code> is not called in <code>fmi3InstanceStateInstantiated</code>.</li><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.1. Super State: FMU State Setable</li></ul><p>See also <a href="#FMICore.fmi3SetDebugLogging"><code>fmi3SetDebugLogging</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L12-L37">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable</p><p>The function controls debug logging that is output via the logger function callback. If loggingOn = fmi3True, debug logging is enabled, otherwise it is switched off.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L123-L127">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetDebugLogging(fmu::FMU3)</code></pre><p>Wrapper for <code>fmi3SetDebugLogging(c::FMU3Instance)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L52-L57">source</a></section></article><h3 id="Initialization,-Termination,-and-Resetting-an-FMU"><a class="docs-heading-anchor" href="#Initialization,-Termination,-and-Resetting-an-FMU">Initialization, Termination, and Resetting an FMU</a><a id="Initialization,-Termination,-and-Resetting-an-FMU-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization,-Termination,-and-Resetting-an-FMU" title="Permalink"></a></h3><p>This section documents functions that deal with initialization, termination, resetting of an FMU.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3EnterInitializationMode" href="#FMICore.fmi3EnterInitializationMode"><code>FMICore.fmi3EnterInitializationMode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3EnterInitializationMode(c::FMU3Instance, toleranceDefined::fmi3Boolean,
    tolerance::fmi3Float64,
    startTime::fmi3Float64,
    stopTimeDefined::fmi3Boolean,
    stopTime::fmi3Float64)</code></pre><p>Informs the FMU to enter Initialization Mode. Before calling this function, all variables with attribute &lt;Datatype initial = &quot;exact&quot; or &quot;approx&quot;&gt; can be set with the “fmi3SetXXX” functions (the ScalarVariable attributes are defined in the Model Description File, see section 2.4.7). Setting other variables is not allowed. Also sets the simulation start and stop time.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>toleranceDefined::fmi3Boolean</code>: Arguments <code>toleranceDefined</code> depend on the FMU type:<ul><li>fmuType = fmi3ModelExchange: If <code>toleranceDefined = fmi3True</code>, then the model is called with a numerical integration scheme where the step size is controlled by using <code>tolerance</code> for error estimation. In such a case, all numerical algorithms used inside the model (for example, to solve non-linear algebraic equations) should also operate with an error estimation of an appropriate smaller relative tolerance.</li><li>fmuType = fmi3CoSimulation: If <code>toleranceDefined = fmi3True</code>, then the communication interval of the slave is controlled by error estimation.  In case the slave utilizes a numerical integrator with variable step size and error estimation, it is suggested to use “tolerance” for the error estimation of the internal integrator (usually as relative tolerance). An FMU for Co-Simulation might ignore this argument.</li></ul></li><li><code>tolerance::fmi3Float64</code>: Argument <code>tolerance</code> is the desired tolerance</li><li><code>startTime::fmi3Float64</code>: Argument <code>startTime</code> can be used to check whether the model is valid within the given boundaries or to allocate memory which is necessary for storing results. It is the fixed initial value of the independent variable and if the independent variable is <code>time</code>, <code>startTime</code> is the starting time of initializaton.</li><li><code>stopTimeDefined::fmi3Boolean</code>:  If <code>stopTimeDefined = fmi3True</code>, then stopTime is the defined final value of the independent variable and if <code>stopTimeDefined = fmi3False</code>, then no final value</li></ul><p>of the independent variable is defined and argument <code>stopTime</code> is meaningless.</p><ul><li><code>stopTime::fmi3Float64</code>: Argument <code>stopTime</code> can be used to check whether the model is valid within the given boundaries or to allocate memory which is necessary for storing results. It is the fixed final value of the independent variable and if the independent variable is “time”, stopTime is the stop time of the simulation.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions</li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.2. State: Instantiated</li></ul><p>See also <a href="#FMICore.fmi3EnterInitializationMode"><code>fmi3EnterInitializationMode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L264-L301">source</a></section><section><div><pre><code class="language-julia hljs">fmi3EnterInitializationMode(c::FMU3Instance, startTime::Union{Real, Nothing} = nothing, stopTime::Union{Real, Nothing} = nothing; tolerance::Union{Real, Nothing} = nothing)</code></pre><p>FMU enters Initialization mode.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>startTime::Union{Real, Nothing} = nothing</code>: <code>startTime</code> is a real number which sets the value of starting time of the experiment. The default value is set automatically if doing nothing (default = <code>nothing</code>).</li><li><code>stopTime::Union{Real, Nothing} = nothing</code>: <code>stopTime</code> is a real number which sets the value of ending time of the experiment. The default value is set automatically if doing nothing (default = <code>nothing</code>).</li></ul><p><strong>Keywords</strong></p><ul><li><code>tolerance::Union{Real, Nothing} = nothing</code>: <code>tolerance</code> is a real number which sets the value of tolerance range. The default value is set automatically if doing nothing (default = <code>nothing</code>).</li></ul><p><strong>Returns</strong></p><ul><li>Returns a warning if <code>str.state</code> is not called in <code>fmi3InstanceStateInstantiated</code>.</li><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.2. State: Instantiated</li></ul><p>See also <a href="#FMICore.fmi3EnterInitializationMode"><code>fmi3EnterInitializationMode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L42-L72">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.2. State: Instantiated</p><p>Informs the FMU to enter Initialization Mode. Before calling this function, all variables with attribute &lt;Datatype initial = &quot;exact&quot; or &quot;approx&quot;&gt; can be set with the “fmi3SetXXX” functions (the ScalarVariable attributes are defined in the Model Description File, see section 2.4.7). Setting other variables is not allowed. Also sets the simulation start and stop time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L138-L143">source</a></section><section><div><pre><code class="language-julia hljs">fmi3EnterInitializationMode(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3EnterInitializationMode(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3ExitInitializationMode" href="#FMICore.fmi3ExitInitializationMode"><code>FMICore.fmi3ExitInitializationMode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3ExitInitializationMode(c::FMU3Instance)</code></pre><p>Informs the FMU to exit Initialization Mode.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions</li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.3. State: Initialization Mode</li></ul><p>See also <a href="#FMICore.fmi3ExitInitializationMode"><code>fmi3ExitInitializationMode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L320-L344">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.3. State: Initialization Mode</p><p>Informs the FMU to exit Initialization Mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L159-L163">source</a></section><section><div><pre><code class="language-julia hljs">fmi3ExitInitializationMode(fmu::FMU3)</code></pre><p>Wrapper for <code>fmi3ExitInitializationMode(c::FMU3Instance)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3EnterConfigurationMode" href="#FMICore.fmi3EnterConfigurationMode"><code>FMICore.fmi3EnterConfigurationMode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3EnterConfigurationMode(c::FMU3Instance; soft::Bool=false)</code></pre><p>If the importer needs to change structural parameters, it must move the FMU into Configuration Mode using fmi3EnterConfigurationMode.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Keywords</strong></p><ul><li><code>soft::Bool=false</code>: If the Keyword <code>soft = true</code> the <code>fmi3Teminate</code> needs to be called in state  <code>fmi3InstanceStateContinuousTimeMode</code> or <code>fmi3InstanceStateEventMode</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.2. State: Instantiated</li></ul><p>See also <a href="#FMICore.fmi3EnterConfigurationMode"><code>fmi3EnterConfigurationMode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2234-L2262">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.2. State: Instantiated</p><p>If the importer needs to change structural parameters, it must move the FMU into Configuration Mode using fmi3EnterConfigurationMode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1072-L1076">source</a></section><section><div><pre><code class="language-julia hljs">fmi3EnterConfigurationMode(fmu::FMU3)</code></pre><p>Wrapper for <code>fmi3EnterConfigurationMode(c::FMU3Instance)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L769-L774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3ExitConfigurationMode" href="#FMICore.fmi3ExitConfigurationMode"><code>FMICore.fmi3ExitConfigurationMode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3ExitConfigurationMode(c::FMU3Instance; soft::Bool=false)</code></pre><p>Exits the Configuration Mode and returns to state Instantiated.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Keywords</strong></p><ul><li><code>soft::Bool=false</code>: If the Keyword <code>soft = true</code> the <code>fmi3Teminate</code> needs to be called in state  <code>fmi3InstanceStateContinuousTimeMode</code> or <code>fmi3InstanceStateEventMode</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.6. State: Configuration Mode</li></ul><p>See also <a href="#FMICore.fmi3ExitConfigurationMode"><code>fmi3ExitConfigurationMode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2285-L2313">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.6. State: Configuration Mode</p><p>Exits the Configuration Mode and returns to state Instantiated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1087-L1091">source</a></section><section><div><pre><code class="language-julia hljs">fmi3ExitConfigurationMode(fmu::FMU3)</code></pre><p>Wrapper for <code>fmi3ExitConfigurationMode(c::FMU3Instance)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L879-L884">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Terminate" href="#FMICore.fmi3Terminate"><code>FMICore.fmi3Terminate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3Terminate(c::FMU3Instance; soft::Bool=false)</code></pre><p>Informs the FMU that the simulation run is terminated.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Keywords</strong></p><ul><li><code>soft::Bool=false</code>: If the Keyword <code>soft = true</code> the <code>fmi3Teminate</code> needs to be called in state  <code>fmi3InstanceStateContinuousTimeMode</code> or <code>fmi3InstanceStateEventMode</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.4. Super State: Initialized</li></ul><p>See also <a href="#FMICore.fmi3Terminate"><code>fmi3Terminate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L365-L392">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.4. Super State: Initialized</p><p>Informs the FMU that the simulation run is terminated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L175-L179">source</a></section><section><div><pre><code class="language-julia hljs">fmi3Terminate(fmu::FMU3)</code></pre><p>Wrapper for <code>fmi3Terminate(c::FMU3Instance)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Reset" href="#FMICore.fmi3Reset"><code>FMICore.fmi3Reset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3Reset(c::FMU3Instance; soft::Bool = false)</code></pre><p>Is called by the environment to reset the FMU after a simulation run. The FMU goes into the same state as if <code>fmi3InstantiateXXX</code> would have been called.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Keywords</strong></p><ul><li><code>soft::Bool=false</code>: If the Keyword <code>soft = true</code> the <code>fmi3Teminate</code> needs to be called in state <code>fmi3InstanceStateContinuousTimeMode</code> or <code>fmi3InstanceStateEventMode</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.1. Super State: FMU State Setable</li></ul><p>See also <a href="#FMICore.fmi3Reset"><code>fmi3Reset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L411-L438">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable</p><p>Is called by the environment to reset the FMU after a simulation run. The FMU goes into the same state as if fmi3InstantiateXXX would have been called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L187-L191">source</a></section><section><div><pre><code class="language-julia hljs">fmi3Reset(fmu::FMU3)</code></pre><p>Wrapper for <code>fmi3Reset(c::FMU3Instance)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L96-L101">source</a></section></article><h3 id="Getting-and-Setting-Variable-Values"><a class="docs-heading-anchor" href="#Getting-and-Setting-Variable-Values">Getting and Setting Variable Values</a><a id="Getting-and-Setting-Variable-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-and-Setting-Variable-Values" title="Permalink"></a></h3><p>All variable values of an FMU are identified with a variable handle called “value reference”. The handle is defined in the modelDescription.xml file (as attribute “valueReference” in element “ScalarVariable”). Element “valueReference” might not be unique for all variables. If two or more variables of the same base data type (such as fmi3Real) have the same valueReference, then they have identical values but other parts of the variable definition might be different [(for example, min/max attributes)].</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3Get" href="#FMIImport.fmi3Get"><code>FMIImport.fmi3Get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3Get(inst::FMU3Instance, vrs::fmi3ValueReferenceFormat)</code></pre><p>Returns the specific value of <code>fmi3Variable</code> containing the modelVariables with the identical fmi3ValueReference in an array.</p><p><strong>Arguments</strong></p><ul><li><code>inst::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vrs::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>dstArray::Array{Any,1}(undef, length(vrs))</code>: Stores the specific value of <code>fmi3Variable</code> containing the modelVariables with the identical fmi3ValueReference to the input variable vr (vr = vrs[i]). <code>dstArray</code> is a 1-Dimensional Array that has the same length as <code>vrs</code>.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L1161-L1180">source</a></section><section><div><pre><code class="language-julia hljs">fmi3Get(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3Get(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L569-L574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3Get!" href="#FMIImport.fmi3Get!"><code>FMIImport.fmi3Get!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3Get!(inst::FMU3Instance, vrs::fmi3ValueReferenceFormat, dstArray::AbstractArray)</code></pre><p>Stores the specific value of <code>fmi3Variable</code> containing the modelVariables with the identical fmi3ValueReference and returns an array that indicates the Status.</p><p><strong>Arguments</strong></p><ul><li><code>inst::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vrs::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>dstArray::AbstractArray</code>: Stores the specific value of <code>fmi3Variable</code> containing the modelVariables with the identical fmi3ValueReference to the input variable vr (vr = vrs[i]). <code>dstArray</code> has the same length as <code>vrs</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>retcodes::Array{fmi3Status}</code>: Returns an array of length length(vrs) with Type <code>fmi3Status</code>. Type <code>fmi3Status</code> is an enumeration and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L1075-L1099">source</a></section><section><div><pre><code class="language-julia hljs">fmi3Get!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3Get!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L580-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetFloat32" href="#FMIImport.fmi3GetFloat32"><code>FMIImport.fmi3GetFloat32</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetFloat32(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3Float32 variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3Float32}</code>: returns values of an array of fmi3Float32 variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetFloat32"><code>fmi3GetFloat32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L104-L124">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetFloat32(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetFloat32(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetFloat32!" href="#FMICore.fmi3GetFloat32!"><code>FMICore.fmi3GetFloat32!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetFloat32!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Float32}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Float32}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetFloat32!"><code>fmi3GetFloat32!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L476-L504">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetFloat32!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Float32})</code></pre><p>Writes the real values of an array of variables in the given field</p><p>fmi3GetFloat32! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3Float32}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetFloat32!"><code>fmi3GetFloat32!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L140-L169">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L200-L206">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetFloat32!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetFloat32!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetFloat64" href="#FMIImport.fmi3GetFloat64"><code>FMIImport.fmi3GetFloat64</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetFloat64(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3Float64 variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3Float64}</code>: returns values of an array of fmi3Float64 variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetFloat64"><code>fmi3GetFloat64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L221-L241">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetFloat64(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetFloat64(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetFloat64!" href="#FMICore.fmi3GetFloat64!"><code>FMICore.fmi3GetFloat64!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetFloat64!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Float64}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Float64}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions</li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetFloat64!"><code>fmi3GetFloat64!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L549-L577">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetFloat64!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Float64})</code></pre><p>Writes the real values of an array of variables in the given field</p><p>fmi3GetFloat64! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3Float64}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetFloat64!"><code>fmi3GetFloat64!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L257-L286">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L234-L240">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetFloat64!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetFloat64!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetInt8" href="#FMIImport.fmi3GetInt8"><code>FMIImport.fmi3GetInt8</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetInt8(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3Int8 variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3Int8}</code>: returns values of an array of fmi3Int8 variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetInt8"><code>fmi3GetInt8</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L339-L359">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetInt8(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetInt8(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetInt8!" href="#FMICore.fmi3GetInt8!"><code>FMICore.fmi3GetInt8!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetInt8!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int8}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Int8}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetInt8!"><code>fmi3GetInt8!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L623-L651">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetInt8!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Int8})</code></pre><p>Writes the integer values of an array of variables in the given field</p><p>fmi3GetInt8! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3Int8}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetInt8!"><code>fmi3GetInt8!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L375-L404">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L269-L275">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetInt8!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetInt8!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetInt16" href="#FMIImport.fmi3GetInt16"><code>FMIImport.fmi3GetInt16</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetInt16(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3Int16 variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3Int16}</code>: returns values of an array of fmi3Int16 variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetInt16"><code>fmi3GetInt16</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L573-L593">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetInt16(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetInt16(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetInt16!" href="#FMICore.fmi3GetInt16!"><code>FMICore.fmi3GetInt16!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetInt16!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int16}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Int16}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetInt16!"><code>fmi3GetInt16!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L768-L796">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetInt16!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Int16})</code></pre><p>Writes the integer values of an array of variables in the given field</p><p>fmi3GetInt16! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3Int16}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetInt16!"><code>fmi3GetInt16!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L609-L638">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L339-L345">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetInt16!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetInt16!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L250-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetInt32" href="#FMIImport.fmi3GetInt32"><code>FMIImport.fmi3GetInt32</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetInt32(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3Int32 variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3Int32}</code>: returns values of an array of fmi3Int32 variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetInt32"><code>fmi3GetInt32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L807-L827">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetInt32(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetInt32(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L305-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetInt32!" href="#FMICore.fmi3GetInt32!"><code>FMICore.fmi3GetInt32!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetInt32!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int32}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Int32}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetInt32!"><code>fmi3GetInt32!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L912-L940">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetInt32!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Int32})</code></pre><p>Writes the integer values of an array of variables in the given field</p><p>fmi3GetInt32! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3Int32}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetInt32!"><code>fmi3GetInt32!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L843-L872">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L408-L414">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetInt32!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetInt32!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L316-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetInt64" href="#FMIImport.fmi3GetInt64"><code>FMIImport.fmi3GetInt64</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetInt64(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3Int64 variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3Int64}</code>: returns values of an array of fmi3Int64 variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetInt64"><code>fmi3GetInt64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1041-L1061">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetInt64(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetInt64(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L371-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetInt64!" href="#FMICore.fmi3GetInt64!"><code>FMICore.fmi3GetInt64!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetInt64!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int64}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Int64}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetInt64!"><code>fmi3GetInt64!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1058-L1086">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetInt64!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Int64})</code></pre><p>Writes the integer values of an array of variables in the given field</p><p>fmi3GetInt64! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3Int64}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetInt64!"><code>fmi3GetInt64!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1077-L1106">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L478-L484">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetInt64!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetInt64!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetUInt8" href="#FMIImport.fmi3GetUInt8"><code>FMIImport.fmi3GetUInt8</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetUInt8(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3UInt8 variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3UInt8}</code>: returns values of an array of fmi3UInt8 variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetUInt8"><code>fmi3GetUInt8</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L456-L476">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetUInt8(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetUInt8(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L206-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetUInt8!" href="#FMICore.fmi3GetUInt8!"><code>FMICore.fmi3GetUInt8!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetUInt8!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt8}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3UInt8}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetUInt8!"><code>fmi3GetUInt8!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L695-L723">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetUInt8!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3UInt8})</code></pre><p>Writes the integer values of an array of variables in the given field</p><p>fmi3GetUInt8! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3UInt8}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetUInt8!"><code>fmi3GetUInt8!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L492-L521">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L304-L310">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetUInt8!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetUInt8!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L217-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetUInt16" href="#FMIImport.fmi3GetUInt16"><code>FMIImport.fmi3GetUInt16</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetUInt16(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3UInt16 variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3UInt16}</code>: returns values of an array of fmi3UInt16 variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetUInt16"><code>fmi3GetUInt16</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L690-L710">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetUInt16(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetUInt16(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L272-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetUInt16!" href="#FMICore.fmi3GetUInt16!"><code>FMICore.fmi3GetUInt16!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetUInt16(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt16}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3UInt16}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetUInt16!"><code>fmi3GetUInt16!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L841-L869">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetUInt16!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3UInt16})</code></pre><p>Writes the integer values of an array of variables in the given field</p><p>fmi3GetUInt16! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3UInt16}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetUInt16!"><code>fmi3GetUInt16!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L726-L755">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L374-L380">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetUInt16!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetUInt16!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L283-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetUInt32" href="#FMIImport.fmi3GetUInt32"><code>FMIImport.fmi3GetUInt32</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetUInt32(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3UInt32 variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3UInt32}</code>: returns values of an array of fmi3UInt32 variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetUInt32"><code>fmi3GetUInt32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L924-L944">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetUInt32(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetUInt32(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L338-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetUInt32!" href="#FMICore.fmi3GetUInt32!"><code>FMICore.fmi3GetUInt32!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetUInt32!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt32}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3UInt32}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetUInt32!"><code>fmi3GetUInt32!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L985-L1013">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetUInt32!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3UInt32})</code></pre><p>Writes the integer values of an array of variables in the given field</p><p>fmi3GetUInt32! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3UInt32}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetUInt32!"><code>fmi3GetUInt32!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L960-L989">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L443-L449">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetUInt32!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetUInt32!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L349-L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetUInt64" href="#FMIImport.fmi3GetUInt64"><code>FMIImport.fmi3GetUInt64</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetUInt64(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3UInt64 variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3UInt64}</code>: returns values of an array of fmi3UInt64 variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetUInt64"><code>fmi3GetUInt64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1158-L1178">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetUInt64(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetUInt64(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L404-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetUInt64!" href="#FMICore.fmi3GetUInt64!"><code>FMICore.fmi3GetUInt64!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetUInt64!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt64}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3UInt64}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetUInt64!"><code>fmi3GetUInt64!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1131-L1159">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetUInt64!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3UInt64})</code></pre><p>Writes the integer values of an array of variables in the given field</p><p>fmi3GetUInt64! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3UInt64}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetUInt64!"><code>fmi3GetUInt64!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1194-L1223">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L513-L519">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetUInt64!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetUInt64!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L415-L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetBoolean" href="#FMIImport.fmi3GetBoolean"><code>FMIImport.fmi3GetBoolean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetBoolean(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3Boolean variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3Boolean}</code>: returns values of an array of fmi3Boolean variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetBoolean"><code>fmi3GetBoolean</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1275-L1295">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetBoolean(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetBoolean(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L437-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetBoolean!" href="#FMICore.fmi3GetBoolean!"><code>FMICore.fmi3GetBoolean!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetBoolean!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Boolean}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Boolean}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetBoolean!"><code>fmi3GetBoolean!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1203-L1231">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetBoolean!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Boolean})</code></pre><p>Writes the boolean values of an array of variables in the given field</p><p>fmi3GetBoolean! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3Boolean}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetBoolean!"><code>fmi3GetBoolean!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1311-L1340">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L547-L553">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetBoolean!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetBoolean!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L448-L453">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetString" href="#FMIImport.fmi3GetString"><code>FMIImport.fmi3GetString</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetString(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3String variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3String}</code>: returns values of an array of fmi3String variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetString"><code>fmi3GetString</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1393-L1413">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetString(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetString(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L470-L475">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetString!" href="#FMICore.fmi3GetString!"><code>FMICore.fmi3GetString!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetString!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3String}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3String}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetString!"><code>fmi3GetString!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1276-L1304">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetString!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3String})</code></pre><p>Writes the string values of an array of variables in the given field</p><p>fmi3GetString! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3String}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetString!"><code>fmi3GetString!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1431-L1460">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L582-L588">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetString!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetString!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L481-L486">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetBinary" href="#FMIImport.fmi3GetBinary"><code>FMIImport.fmi3GetBinary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetBinary(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3Binary variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3Binary}</code>: returns values of an array of fmi3Binary variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetBinary"><code>fmi3GetBinary</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1516-L1536">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetBinary(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetBinary(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L503-L508">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetBinary!" href="#FMICore.fmi3GetBinary!"><code>FMICore.fmi3GetBinary!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetBinary!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, valueSizes::AbstractArray{Csize_t}, value::AbstractArray{fmi3Binary}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>valueSizes::AbstractArray{Csize_t}</code>: Argument <code>valueSizes</code> defines the size of a binary element of each variable.</li><li><code>value::AbstractArray{fmi3Binary}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetBinary!"><code>fmi3GetBinary!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1348-L1377">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetBinary!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Binary})</code></pre><p>Writes the binary values of an array of variables in the given field</p><p>fmi3GetBinary! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3Binary}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetBinary!"><code>fmi3GetBinary!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1552-L1581">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValues - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L616-L622">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetBinary!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetBinary!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L514-L519">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3Set" href="#FMIImport.fmi3Set"><code>FMIImport.fmi3Set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3Set(inst::FMU3Instance, vrs::fmi3ValueReferenceFormat, srcArray::AbstractArray; filter=nothing)</code></pre><p>Stores the specific value of <code>fmi3Variable</code> containing the modelVariables with the identical fmi3ValueReference and returns an array that indicates the Status.</p><p><strong>Arguments</strong></p><ul><li><code>inst::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vrs::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>srcArray::AbstractArray</code>: Stores the specific value of <code>fmi3Variable</code> containing the modelVariables with the identical fmi3ValueReference to the input variable vr (vr = vrs[i]). <code>srcArray</code> has the same length as <code>vrs</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>filter=nothing</code>: whether the individual values of &quot;fmi3Variable&quot; are to be stored</li></ul><p><strong>Returns</strong></p><ul><li><code>retcodes::Array{fmi3Status}</code>: Returns an array of length length(vrs) with Type <code>fmi3Status</code>. Type <code>fmi3Status</code> is an enumeration and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L1193-L1219">source</a></section><section><div><pre><code class="language-julia hljs">fmi3Set(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3Set(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L591-L596">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetFloat32" href="#FMICore.fmi3SetFloat32"><code>FMICore.fmi3SetFloat32</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetFloat32(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Float32}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Float32}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetFloat32"><code>fmi3SetFloat32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L513-L541">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetFloat32(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Float32}, fmi3Float32})</code></pre><p>Set the values of an array of real variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{fmi3Float32}, fmi3Float32}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetFloat32"><code>fmi3SetFloat32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L183-L210">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L217-L223">source</a></section><section><div><p>fmi3SetFloat32(fmu::FMU3, args...; kwargs...)</p><p>Wrapper for <code>fmi3SetFloat32(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L129-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetFloat64" href="#FMICore.fmi3SetFloat64"><code>FMICore.fmi3SetFloat64</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetFloat64(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Float64}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Float64}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions</li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetFloat64"><code>fmi3SetFloat64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L586-L614">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetFloat64(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Float64}, fmi3Float64})</code></pre><p>Set the values of an array of real variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{fmi3Float64}, fmi3Float64}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetFloat64"><code>fmi3SetFloat64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L301-L328">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L251-L257">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetFloat64(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetFloat64(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetInt8" href="#FMICore.fmi3SetInt8"><code>FMICore.fmi3SetInt8</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetInt8(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int8}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Int8}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L659-L686">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetInt8(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Int8}, fmi3Int8})</code></pre><p>Set the values of an array of integer variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{fmi3Int8}, fmi3Int8}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetInt8"><code>fmi3SetInt8</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L418-L445">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L286-L292">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetInt8(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetInt8(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L195-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetInt16" href="#FMICore.fmi3SetInt16"><code>FMICore.fmi3SetInt16</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetInt16(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int16}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Int16}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetInt16"><code>fmi3SetInt16</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L804-L832">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetInt16(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Int16}, fmi3Int16})</code></pre><p>Set the values of an array of integer variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{fmi3Int16}, fmi3Int16}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetInt16"><code>fmi3SetInt16</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L652-L679">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L356-L362">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetInt16(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetInt16(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L261-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetInt32" href="#FMICore.fmi3SetInt32"><code>FMICore.fmi3SetInt32</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetInt32(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int32}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Int32}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetInt32"><code>fmi3SetInt32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L948-L976">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetInt32(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Int32}, fmi3Int32})</code></pre><p>Set the values of an array of integer variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{fmi3Int32}, fmi3Int32}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetInt32"><code>fmi3SetInt32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L886-L913">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L425-L431">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetInt32(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetInt32(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L327-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetInt64" href="#FMICore.fmi3SetInt64"><code>FMICore.fmi3SetInt64</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetInt64(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int64}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Int64}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetInt64"><code>fmi3SetInt64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1094-L1122">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetInt64(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Int64}, fmi3Int64})</code></pre><p>Set the values of an array of integer variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{fmi3Int64}, fmi3Int64}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetInt64"><code>fmi3SetInt64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1120-L1147">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L495-L501">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetInt64(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetInt64(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L393-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetUInt8" href="#FMICore.fmi3SetUInt8"><code>FMICore.fmi3SetUInt8</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetUInt8(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt8}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3UInt8}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetUInt8"><code>fmi3SetUInt8</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L731-L760">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetUInt8(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3UInt8}, fmi3UInt8})</code></pre><p>Set the values of an array of integer variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{fmi3UInt8}, fmi3UInt8}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetUInt8"><code>fmi3SetUInt8</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L535-L562">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L321-L327">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetUInt8(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetUInt8(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetUInt16" href="#FMICore.fmi3SetUInt16"><code>FMICore.fmi3SetUInt16</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetUInt16(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt16}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3UInt16}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L877-L904">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetUInt16(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3UInt16}, fmi3UInt16})</code></pre><p>Set the values of an array of integer variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{fmi3UInt16}, fmi3UInt16}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetUInt16"><code>fmi3SetUInt16</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L769-L796">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L391-L397">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetUInt16(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetUInt16(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L294-L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetUInt32" href="#FMICore.fmi3SetUInt32"><code>FMICore.fmi3SetUInt32</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetInt32(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt32}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3UInt32}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetUInt32"><code>fmi3SetUInt32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1021-L1050">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetUInt32(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3UInt32}, fmi3UInt32})</code></pre><p>Set the values of an array of integer variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{fmi3UInt32}, fmi3UInt32}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetUInt32"><code>fmi3SetUInt32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1003-L1030">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L460-L466">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetUInt32(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetUInt32(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L360-L365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetUInt64" href="#FMICore.fmi3SetUInt64"><code>FMICore.fmi3SetUInt64</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetUInt64(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt64}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3UInt64}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:     - <code>fmi3OK</code>: all well     - <code>fmi3Warning</code>: things are not quite right, but the computation can continue     - <code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step     - <code>fmi3Error</code>: the communication step could not be carried out at all     - <code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetUInt64"><code>fmi3SetUInt64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1167-L1195">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetUInt64(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3UInt64}, fmi3UInt64})</code></pre><p>Set the values of an array of integer variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{fmi3UInt64}, fmi3UInt64}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetUInt64"><code>fmi3SetUInt64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1237-L1264">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L530-L536">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetUInt64(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetUInt64(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L426-L431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetBoolean" href="#FMICore.fmi3SetBoolean"><code>FMICore.fmi3SetBoolean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetBoolean(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Boolean}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3Boolean}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetBoolean"><code>fmi3SetBoolean</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1239-L1267">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetBoolean(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{Bool}, Bool})</code></pre><p>Set the values of an array of boolean variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{Bool}, Bool}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetBoolean"><code>fmi3SetBoolean</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1355-L1382">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L564-L570">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetBoolean(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetBoolean!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L459-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetString" href="#FMICore.fmi3SetString"><code>FMICore.fmi3SetString</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetString(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3String}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>values::AbstractArray{fmi3String}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetString"><code>fmi3SetString</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1312-L1340">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetString(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{String}, String})</code></pre><p>Set the values of an array of string variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{String}, String}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetString"><code>fmi3SetString</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1477-L1504">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L599-L605">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetString(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetString(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L492-L497">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetBinary" href="#FMICore.fmi3SetBinary"><code>FMICore.fmi3SetBinary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetBinary(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, valueSizes::AbstractArray{Csize_t}, value::AbstractArray{fmi3Binary}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>valueSizes::AbstractArray{Csize_t}</code>: Argument <code>valueSizes</code> defines the size of a binary element of each variable.</li><li><code>value::AbstractArray{fmi3Binary}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetBinary"><code>fmi3SetBinary</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1385-L1414">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetBinary(c::FMU3Instance, vr::fmi3ValueReferenceFormat, valueSizes::Union{AbstractArray{Csize_t}, Csize_t}, values::Union{AbstractArray{fmi3Binary}, fmi3Binary})</code></pre><p>Set the values of an array of binary variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>valueSizes::Union{AbstractArray{Csize_t}, Csize_t}</code>: Argument <code>valueSizes</code> defines the size of a binary element of each variable.</li><li><code>values::Union{AbstractArray{fmi3Binary}, fmi3Binary}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetBinary"><code>fmi3SetBinary</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1595-L1623">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L633-L639">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetBinary(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetBinary(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L525-L530">source</a></section></article><h3 id="Getting-and-Setting-the-Complete-FMU-State"><a class="docs-heading-anchor" href="#Getting-and-Setting-the-Complete-FMU-State">Getting and Setting the Complete FMU State</a><a id="Getting-and-Setting-the-Complete-FMU-State-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-and-Setting-the-Complete-FMU-State" title="Permalink"></a></h3><p>The FMU has an internal state consisting of all values that are needed to continue a simulation. This internal state consists especially of the values of the continuous-time states, iteration variables, parameter values, input values, delay buffers, file identifiers, and FMU internal status information. With the functions of this section, the internal FMU state can be copied and the pointer to this copy is returned to the environment. The FMU state copy can be set as actual FMU state, in order to continue the simulation from it.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetFMUState" href="#FMIImport.fmi3GetFMUState"><code>FMIImport.fmi3GetFMUState</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetFMUState(c::FMU3Instance)</code></pre><p>Makes a copy of the internal FMU state and returns a pointer to this copy.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>state</code> is a pointer to a copy of the internal FMU state.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State</li></ul><p>See also <a href="#FMIImport.fmi3GetFMUState"><code>fmi3GetFMUState</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1751-L1769">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetFMUstate(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetFMUstate(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L602-L607">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetFMUState!" href="#FMICore.fmi3GetFMUState!"><code>FMICore.fmi3GetFMUState!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetFMUState!(c::FMU3Instance, FMUstate::Ref{fmi3FMUState})</code></pre><p>Makes a copy of the internal FMU state and returns a pointer to this copy</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>FMUstate::Ref{fmi3FMUstate}</code>:If on entry <code>FMUstate == NULL</code>, a new allocation is required. If <code>FMUstate != NULL</code>, then <code>FMUstate</code> points to a previously returned <code>FMUstate</code> that has not been modified since.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State</li></ul><p>See also <a href="#FMICore.fmi3GetFMUState!"><code>fmi3GetFMUState!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1495-L1520">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State</p><p>fmi3GetFMUstate makes a copy of the internal FMU state and returns a pointer to this copy</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L685-L689">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetFMUState" href="#FMICore.fmi3SetFMUState"><code>FMICore.fmi3SetFMUState</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetFMUState(c::FMU3Instance, FMUstate::fmi3FMUState)</code></pre><p>Copies the content of the previously copied FMUstate back and uses it as actual new FMU state.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>FMUstate::fmi3FMUstate</code>: Argument <code>FMUstate</code> is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State</li></ul><p>See also <a href="#FMICore.fmi3SetFMUState"><code>fmi3SetFMUState</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1528-L1553">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State</p><p>fmi3SetFMUstate copies the content of the previously copied FMUstate back and uses it as actual new FMU state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L700-L704">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetFMUState(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetFMUState(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L613-L618">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3FreeFMUState!" href="#FMICore.fmi3FreeFMUState!"><code>FMICore.fmi3FreeFMUState!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3FreeFMUState!(c::FMU3Instance, FMUstate::Ref{fmi3FMUState})</code></pre><p>Frees all memory and other resources allocated with the <code>fmi3GetFMUstate</code> call for this FMUstate.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>FMUstate::fmi3FMUstate</code>: Argument <code>FMUstate</code> is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1561-L1585">source</a></section><section><div><pre><code class="language-julia hljs">fmi3FreeFMUState!(c::FMU3Instance, state::fmi3FMUState)</code></pre><p>Free the allocated memory for the FMU state.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>state::fmi3FMUState</code>: Argument <code>state</code> is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.</li></ul><p><strong>Returns</strong></p><ul><li>Return singleton instance of type <code>Nothing</code>, if there is no value to return (as in a C void function) or when a variable or field holds no value.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1778-L1795">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State</p><p>fmi3FreeFMUstate frees all memory and other resources allocated with the fmi3GetFMUstate call for this FMUstate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L715-L719">source</a></section><section><div><pre><code class="language-julia hljs">fmi3FreeFMUState!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3FreeFMUState!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L624-L629">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3SerializeFMUState" href="#FMIImport.fmi3SerializeFMUState"><code>FMIImport.fmi3SerializeFMUState</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SerializeFMUState(c::FMU3Instance, state::fmi3FMUState)</code></pre><p>Serializes the data referenced by the pointer FMUstate and copies this data into the byte vector serializedState of length size to be provided by the environment.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>state::fmi3FMUState</code>: Argument <code>state</code> is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.</li></ul><p><strong>Returns</strong></p><ul><li><code>serializedState:: Array{fmi3Byte}</code>: Return <code>serializedState</code> contains the copy of the serialized data referenced by the pointer FMUstate</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State</li></ul><p>See also <a href="#FMIImport.fmi3SerializeFMUState"><code>fmi3SerializeFMUState</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1829-L1848">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SerializeFMUState(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SerializeFMUState(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L646-L651">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SerializeFMUState!" href="#FMICore.fmi3SerializeFMUState!"><code>FMICore.fmi3SerializeFMUState!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SerializeFMUState!(c::FMU3Instance, FMUstate::fmi3FMUState, serialzedState::AbstractArray{fmi3Byte}, size::Csize_t)</code></pre><p>Serializes the data which is referenced by pointer <code>FMUState</code> and copies this data in to the byte vector <code>serializedState</code> of length <code>size</code>, that must be provided by the environment.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>FMUstate::fmi3FMUstate</code>: Argument <code>FMUstate</code> is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.</li><li><code>serialzedState::AbstractArray{fmi3Byte}</code>: Argument <code>serializedState</code> contains the copy of the serialized data referenced by the pointer FMUstate.</li><li><code>size::Ref{Csize_t}</code>: Argument <code>size</code> is an object that safely references a value of type <code>Csize_t</code> and defines the size of the byte vector in which the FMUstate can be stored.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State</li></ul><p>See also <a href="#FMICore.fmi3SerializeFMUState!"><code>fmi3SerializeFMUState!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1627-L1654">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State</p><p>fmi3SerializeFMUstate serializes the data which is referenced by pointer FMUstate and copies this data in to the byte vector serializedState of length size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L745-L749">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3SerializedFMUStateSize" href="#FMIImport.fmi3SerializedFMUStateSize"><code>FMIImport.fmi3SerializedFMUStateSize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SerializedFMUStateSize(c::FMU3Instance, state::fmi3FMUState)</code></pre><p>Returns the size of the byte vector in which the FMUstate can be stored.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>state::fmi3FMUState</code>: Argument <code>state</code> is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>size</code> is an object that safely references a value of type <code>Csize_t</code>.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State</li></ul><p>See also <a href="#FMIImport.fmi3SerializedFMUStateSize"><code>fmi3SerializedFMUStateSize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1802-L1821">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SerializedFMUStateSize(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SerializedFMUStateSize(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L635-L640">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SerializedFMUStateSize!" href="#FMICore.fmi3SerializedFMUStateSize!"><code>FMICore.fmi3SerializedFMUStateSize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SerializedFMUStateSize!(c::FMU3Instance, FMUstate::fmi3FMUState, size::Ref{Csize_t})</code></pre><p>Frees all memory and other resources allocated with the <code>fmi3GetFMUstate</code> call for this FMUstate.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>FMUstate::fmi3FMUstate</code>: Argument <code>FMUstate</code> is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.</li><li><code>size::Ref{Csize_t}</code>: Argument <code>size</code> is an object that safely references a value of type <code>Csize_t</code> and defines the size of the byte vector in which the FMUstate can be stored.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State</li></ul><p>See also <a href="#FMICore.fmi3SerializedFMUStateSize!"><code>fmi3SerializedFMUStateSize!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1593-L1619">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State</p><p>fmi3SerializedFMUstateSize returns the size of the byte vector which is needed to store FMUstate in it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L730-L734">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3DeSerializeFMUState" href="#FMIImport.fmi3DeSerializeFMUState"><code>FMIImport.fmi3DeSerializeFMUState</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fmi3SerializeFMUState(c::FMU3Instance, state::fmi3FMUState)</p><p>Serializes the data referenced by the pointer FMUstate and copies this data into the byte vector serializedState of length size to be provided by the environment.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>serializedState::Array{fmi3Byte}</code>: Argument <code>serializedState</code> contains the fmi3Byte field to be deserialized.</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>state</code> is a pointer to a copy of the internal FMU state.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State</li></ul><p>See also <a href="#FMIImport.fmi3DeSerializeFMUState"><code>fmi3DeSerializeFMUState</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1857-L1876">source</a></section><section><div><pre><code class="language-julia hljs">fmi3DeSerializeFMUState(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3DeSerializeFMUState(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L657-L662">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3DeSerializeFMUState!" href="#FMICore.fmi3DeSerializeFMUState!"><code>FMICore.fmi3DeSerializeFMUState!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3DeSerializeFMUState!(c::FMU3Instance, serialzedState::AbstractArray{fmi3Byte}, size::Csize_t, FMUstate::Ref{fmi3FMUState})</code></pre><p>Deserializes the byte vector serializedState of length size, constructs a copy of the FMU state and stores the FMU state in the given address of the reference <code>FMUstate</code>, the pointer to this copy.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>FMUstate::fmi3FMUstate</code>: Argument <code>FMUstate</code> is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.</li><li><code>serialzedState::AbstractArray{fmi3Byte}</code>: Argument <code>serializedState</code> contains the copy of the serialized data referenced by the pointer FMUstate.</li><li><code>size::Ref{Csize_t}</code>: Argument <code>size</code> is an object that safely references a value of type <code>Csize_t</code> and defines the size of the byte vector in which the FMUstate can be stored.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State</li></ul><p>See also <a href="#FMICore.fmi3DeSerializeFMUState!"><code>fmi3DeSerializeFMUState!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1662-L1689">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State</p><p>fmi3DeSerializeFMUstate deserializes the byte vector serializedState of length size, constructs a copy of the FMU state and returns FMUstate, the pointer to this copy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L760-L764">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3UpdateDiscreteStates" href="#FMICore.fmi3UpdateDiscreteStates"><code>FMICore.fmi3UpdateDiscreteStates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3UpdateDiscreteStates(c::FMU3Instance, discreteStatesNeedUpdate::Ref{fmi3Boolean}, terminateSimulation::Ref{fmi3Boolean}, 
                                nominalsOfContinuousStatesChanged::Ref{fmi3Boolean}, valuesOfContinuousStatesChanged::Ref{fmi3Boolean},
                                nextEventTimeDefined::Ref{fmi3Boolean}, nextEventTime::Ref{fmi3Float64})</code></pre><p>This function is called to signal a converged solution at the current super-dense time instant. fmi3UpdateDiscreteStates must be called at least once per super-dense time instant.</p><p><strong>TODO Arguments</strong></p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>discreteStatesNeedUpdate::Ref{fmi3Boolean}</code>: </li><li><code>terminateSimulation::Ref{fmi3Boolean}</code>: </li><li><code>nominalsOfContinuousStatesChanged::Ref{fmi3Boolean}</code>: </li><li><code>valuesOfContinuousStatesChanged::Ref{fmi3Boolean}</code>: </li><li><code>nextEventTimeDefined::Ref{fmi3Boolean}</code>: </li><li><code>nextEventTime::Ref{fmi3Float64}</code>: </li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.5. State: Event Mode</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2522-L2554">source</a></section><section><div><pre><code class="language-julia hljs">fmi3UpdateDiscreteStates(c::FMU3Instance)</code></pre><p>This function is called to signal a converged solution at the current super-dense time instant. fmi3UpdateDiscreteStates must be called at least once per super-dense time instant.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>TODO returns</strong></p><p><strong>Returns</strong></p><ul><li><code>discreteStatesNeedUpdate</code></li><li><code>terminateSimulation</code></li><li><code>nominalsOfContinuousStatesChanged</code></li><li><code>valuesOfContinuousStatesChanged</code></li><li><code>nextEventTimeDefined</code></li><li><code>nextEventTime</code></li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.3.5. State: Event Mode</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2583-L2605">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.5. State: Event Mode</p><p>This function is called to signal a converged solution at the current super-dense time instant. fmi3UpdateDiscreteStates must be called at least once per super-dense time instant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1190-L1194">source</a></section><section><div><pre><code class="language-julia hljs">fmi3UpdateDiscreteStates(fmu::FMU3)</code></pre><p>Wrapper for <code>fmi3UpdateDiscreteStates(c::FMU3Instance)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L846-L851">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3EvaluateDiscreteStates" href="#FMICore.fmi3EvaluateDiscreteStates"><code>FMICore.fmi3EvaluateDiscreteStates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3EvaluateDiscreteStates(c::FMU3Instance)</code></pre><p>This function is called to trigger the evaluation of fdisc to compute the current values of discrete states from previous values.  The FMU signals the support of fmi3EvaluateDiscreteStates via the capability flag providesEvaluateDiscreteStates.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.3. State: Initialization Mode</li></ul><p>See also <a href="#FMICore.fmi3EvaluateDiscreteStates"><code>fmi3EvaluateDiscreteStates</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2488-L2514">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.3. State: Initialization Mode</p><p>This function is called to trigger the evaluation of fdisc to compute the current values of discrete states from previous values.  The FMU signals the support of fmi3EvaluateDiscreteStates via the capability flag providesEvaluateDiscreteStates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1174-L1179">source</a></section><section><div><p>fmi3EvaluateDiscreteStates(fmu::FMU3)</p><p>Wrapper for <code>fmi3EvaluateDiscreteStates(c::FMU3Instance)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L835-L840">source</a></section></article><p>TODO: Clockstuff</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetIntervalDecimal!" href="#FMICore.fmi3GetIntervalDecimal!"><code>FMICore.fmi3GetIntervalDecimal!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetIntervalDecimal!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, intervals::AbstractArray{fmi3Float64}, qualifiers::fmi3IntervalQualifier)</code></pre><p>fmi3GetIntervalDecimal retrieves the interval until the next clock tick.</p><p>For input Clocks it is allowed to call this function to query the next activation interval. For changing aperiodic Clock, this function must be called in every Event Mode where this clock was activated. For countdown aperiodic Clock, this function must be called in every Event Mode. Clock intervals are computed in fmi3UpdateDiscreteStates (at the latest), therefore, this function should be called after fmi3UpdateDiscreteStates. For information about fmi3IntervalQualifiers, call ?fmi3IntervalQualifier</p><p><strong>TODO argmuents</strong></p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>intervals::AbstractArray{fmi3Float64}</code>: </li><li><code>qualifiers::fmi3IntervalQualifier</code>: </li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.9. Clocks</li></ul><p>See also <a href="#FMICore.fmi3GetIntervalDecimal!"><code>fmi3GetIntervalDecimal!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1768-L1803">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetIntervalFraction!" href="#FMICore.fmi3GetIntervalFraction!"><code>FMICore.fmi3GetIntervalFraction!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetIntervalFraction!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, intervalCounters::AbstractArray{fmi3UInt64}, resolutions::AbstractArray{fmi3UInt64}, qualifiers::fmi3IntervalQualifier)</code></pre><p>fmi3GetIntervalFraction retrieves the interval until the next clock tick.</p><p>For input Clocks it is allowed to call this function to query the next activation interval. For changing aperiodic Clock, this function must be called in every Event Mode where this clock was activated. For countdown aperiodic Clock, this function must be called in every Event Mode. Clock intervals are computed in fmi3UpdateDiscreteStates (at the latest), therefore, this function should be called after fmi3UpdateDiscreteStates. For information about fmi3IntervalQualifiers, call ?fmi3IntervalQualifier</p><p><strong>TODO argmuents</strong></p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>intervalCounters::AbstractArray{fmi3UInt64}</code>: </li><li><code>resolutions::AbstractArray{fmi3UInt64}</code>: </li><li><code>qualifiers::fmi3IntervalQualifier</code>: </li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.9. Clocks</li></ul><p>See also <a href="#FMICore.fmi3GetIntervalFraction!"><code>fmi3GetIntervalFraction!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1811-L1847">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetShiftDecimal!" href="#FMICore.fmi3GetShiftDecimal!"><code>FMICore.fmi3GetShiftDecimal!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetShiftDecimal!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, shifts::AbstractArray{fmi3Float64})</code></pre><p>fmi3GetShiftDecimal retrieves the delay to the first Clock tick from the FMU.</p><p><strong>TODO argmuents</strong></p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>shifts::AbstractArray{fmi3Float64}</code>:</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.9. Clocks</li></ul><p>See also <a href="#FMICore.fmi3GetShiftDecimal!"><code>fmi3GetShiftDecimal!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1855-L1883">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetShiftFraction!" href="#FMICore.fmi3GetShiftFraction!"><code>FMICore.fmi3GetShiftFraction!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetShiftFraction!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, shiftCounters::AbstractArray{fmi3UInt64}, resolutions::AbstractArray{fmi3UInt64})</code></pre><p>fmi3GetShiftFraction retrieves the delay to the first Clock tick from the FMU.</p><p><strong>TODO argmuents</strong></p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>shiftCounters::AbstractArray{fmi3UInt64}</code>:</li><li><code>resolutions::AbstractArray{fmi3UInt64}</code>:</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.9. Clocks</li></ul><p>See also <a href="#FMICore.fmi3GetShiftFraction!"><code>fmi3GetShiftFraction!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1891-L1920">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetClock" href="#FMIImport.fmi3GetClock"><code>FMIImport.fmi3GetClock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetClock(c::FMU3Instance, vr::fmi3ValueReferenceFormat)</code></pre><p>Get the values of an array of fmi3Clock variables.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li><code>values::Array{fmi3Clock}</code>: returns values of an array of fmi3Clock variables with the dimension of fmi3ValueReferenceFormat length.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMIImport.fmi3GetClock"><code>fmi3GetClock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1635-L1654">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetClock(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetClock(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L536-L541">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetClock!" href="#FMICore.fmi3GetClock!"><code>FMICore.fmi3GetClock!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetClock!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Clock}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>value::AbstractArray{fmi3Clock}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetClock!"><code>fmi3GetClock!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1423-L1451">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetClock!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Clock})</code></pre><p>Writes the clock values of an array of variables in the given field</p><p>fmi3GetClock! is only possible for arrays of values, please use an array instead of a scalar.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::AbstractArray{fmi3Clock}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3GetClock!"><code>fmi3GetClock!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1670-L1699">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L651-L657">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetClock!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetClock!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L547-L552">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetIntervalDecimal" href="#FMICore.fmi3SetIntervalDecimal"><code>FMICore.fmi3SetIntervalDecimal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetIntervalDecimal(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, intervals::AbstractArray{fmi3Float64})</code></pre><p>Sets the interval until the next clock tick</p><p><strong>TODO argmuents</strong></p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>intervals::AbstractArray{fmi3Float64}</code>: </li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.9. Clocks</li></ul><p>See also <a href="#FMICore.fmi3SetIntervalDecimal"><code>fmi3SetIntervalDecimal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1698-L1724">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetIntervalFraction" href="#FMICore.fmi3SetIntervalFraction"><code>FMICore.fmi3SetIntervalFraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetIntervalFraction(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, intervalCounters::AbstractArray{fmi3UInt64}, resolutions::AbstractArray{fmi3UInt64})</code></pre><p>Sets the interval until the next clock tick. Only allowed if the attribute &#39;supportsFraction&#39; is set.</p><p><strong>TODO argmuents</strong></p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>intervalCounters::AbstractArray{fmi3UInt64}</code>: </li><li><code>resolutions::AbstractArray{fmi3UInt64}</code>: </li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.9. Clocks</li></ul><p>See also <a href="#FMICore.fmi3SetIntervalFraction"><code>fmi3SetIntervalFraction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1732-L1760">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetClock" href="#FMICore.fmi3SetClock"><code>FMICore.fmi3SetClock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetClock(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Clock}, nvalue::Csize_t)</code></pre><p>Functions to get and set values of variables idetified by their valueReference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::AbstractArray{fmi3ValueReference}</code>: Argument <code>vr</code> is an AbstractArray of <code>nvr</code> value handels called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>value::AbstractArray{fmi3Clock}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li><li><code>nvalue::Csize_t</code>: Argument <code>nvalue</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetClock"><code>fmi3SetClock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1459-L1487">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetClock(c::FMU3Instance, vr::fmi3ValueReferenceFormat, valueSizes::Union{AbstractArray{Csize_t}, Csize_t}, values::Union{AbstractArray{fmi3Clock}, fmi3Clock})</code></pre><p>Set the values of an array of clock variables</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReferenceFormat</code>: Wildcards for how a user can pass a fmi[X]ValueReference</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><ul><li><code>values::Union{AbstractArray{fmi3Clock}, fmi3Clock}</code>: Argument <code>values</code> is an AbstractArray with the actual values of these variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.6.2. Getting and Setting Variable Values</li></ul><p>See also <a href="#FMICore.fmi3SetClock"><code>fmi3SetClock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1713-L1740">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values</p><p>Functions to get and set values of variables idetified by their valueReference.</p><p>nValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L668-L674">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetClock(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetClock(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L558-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3ActivateModelPartition" href="#FMICore.fmi3ActivateModelPartition"><code>FMICore.fmi3ActivateModelPartition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3ActivateModelPartition(c::FMU3Instance, vr::fmi3ValueReference, activationTime::AbstractArray{fmi3Float64})</code></pre><p>During Clock Activation Mode (see 5.2.2.) after <code>fmi3ActivateModelPartition</code> has been called for a calculated, tunable or changing Clock the FMU provides the information on when the Clock will tick again, i.e. when the corresponding model partition has to be scheduled the next time.</p><p>Each <code>fmi3ActivateModelPartition</code> call is associated with the computation of an exposed model partition of the FMU and therefore to an input Clock.</p><p><strong>TODO argmuents</strong></p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReference</code>: Argument <code>vr</code> is the value handel called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>activationTime::AbstractArray{fmi3Float64}</code>: </li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 5.2.2. State: Clock Activation Mode</li></ul><p>See also <a href="#FMICore.fmi3ActivateModelPartition"><code>fmi3ActivateModelPartition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1928-L1957">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3CallbackClockUpdate" href="#FMIImport.fmi3CallbackClockUpdate"><code>FMIImport.fmi3CallbackClockUpdate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3CallbackLogger(_instanceEnvironment::Ptr{FMU3InstanceEnvironment},
    _status::Cuint,
    _category::Ptr{Cchar},
    _message::Ptr{Cchar})</code></pre><p>A model partition of a Scheduled Execution FMU calls <code>fmi3CallbackClockUpdate</code> to signal that a triggered output Clock ticked or a new interval for a countdown Clock is available. <code>fmi3CallbackClockUpdate</code> switches the FMU itself then into the Clock Update Mode (see 5.2.3.). The callback may be called from several model partitions.</p><p><strong>Arguments</strong></p><ul><li><code>_instanceEnvironment::Ptr{FMU3InstanceEnvironment}</code>: is the instance name of the model that calls this function. </li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0, Version D5ef1c1: 5.2.2. State: Clock Activation Mode</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L120-L139">source</a></section></article><h3 id="Getting-Partial-Dervatives"><a class="docs-heading-anchor" href="#Getting-Partial-Dervatives">Getting Partial Dervatives</a><a id="Getting-Partial-Dervatives-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Partial-Dervatives" title="Permalink"></a></h3><p>It is optionally possible to provide evaluation of partial derivatives for an FMU. For Model Exchange, this means computing the partial derivatives at a particular time instant. For Co-Simulation, this means to compute the partial derivatives at a particular communication point. One function is provided to compute directional derivatives. This function can be used to construct the desired partial derivative matrices.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetDirectionalDerivative" href="#FMIImport.fmi3GetDirectionalDerivative"><code>FMIImport.fmi3GetDirectionalDerivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetDirectionalDerivative(c::FMU3Instance,
    unknowns::AbstractArray{fmi3ValueReference},
    knowns::AbstractArray{fmi3ValueReference},
    seed::AbstractArray{fmi3Float64})</code></pre><p>Wrapper Function call to compute the partial derivative with respect to the variables <code>unknowns</code>.</p><p>Computes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = 𝐡(knowns, rest)</p><ul><li><code>unknowns</code>: vector of unknown Real variables computed in the actual Mode:<ul><li>Initialization Mode: unkowns kisted under <code>&lt;ModelStructure&gt;&lt;InitialUnknown&gt;</code> that have type Real.</li><li>Continuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> and the variables listed as state derivatives under <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;)</code>.</li><li>Event Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>discrete</code>.</li><li>Step Mode (CoSimulation):  The variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> or <code>discrete</code>. If <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;</code> is present, also the variables listed here as state derivatives.</li></ul></li><li><code>knowns</code>: Real input variables of function h that changes its value in the actual Mode.</li><li><code>rest</code>: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes</li></ul><p>Computes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:</p><p>Δunknowns = (δh / δknowns) Δknowns</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code> Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>unknowns::AbstracArray{fmi3ValueReference}</code>: Argument <code>unknowns</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model. <code>unknowns</code> can be equated with <code>unknowns</code>(variable described above).</li><li><code>knowns::AbstractArray{fmi3ValueReference}</code>: Argument <code>knowns</code> contains values of type <code>fmi3ValueReference</code> which are identifiers of a variable value of the model.<code>knowns</code> can be equated with <code>knowns</code>(variable described above).</li><li><code>seed::AbstractArray{fmi3Float64}</code>:The vector values Compute the partial derivative with respect to the given entries in vector <code>knowns</code> with the matching evaluate of <code>sensitivity</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>sensitivity::Array{fmi3Float64}</code>: Return <code>sensitivity</code> contains the directional derivative vector values.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.11. Getting Partial Derivatives</li></ul><p>See also <a href="#FMIImport.fmi3GetDirectionalDerivative"><code>fmi3GetDirectionalDerivative</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1888-L1927">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetDirectionalDerivative(c::FMU3Instance,
    unknowns::AbstractArray{fmi3ValueReference},
    knowns::AbstractArray{fmi3ValueReference},
    seed::fmi3Float64)</code></pre><p>Wrapper Function call to compute the partial derivative with respect to the variables <code>unknowns</code>.</p><p>Computes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = 𝐡(knowns, rest)</p><ul><li><code>unknowns</code>: vector of unknown Real variables computed in the actual Mode:<ul><li>Initialization Mode: unkowns kisted under <code>&lt;ModelStructure&gt;&lt;InitialUnknown&gt;</code> that have type Real.</li><li>Continuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> and the variables listed as state derivatives under <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;)</code>.</li><li>Event Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>discrete</code>.</li><li>Step Mode (CoSimulation):  The variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> or <code>discrete</code>. If <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;</code> is present, also the variables listed here as state derivatives.</li></ul></li><li><code>knowns</code>: Real input variables of function h that changes its value in the actual Mode.</li><li><code>rest</code>: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes</li></ul><p>Computes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:</p><p>Δunknowns = (δh / δknowns) Δknowns</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code> Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>unknowns::AbstracArray{fmi3ValueReference}</code>: Argument <code>unknowns</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model. <code>unknowns</code> can be equated with <code>unknowns</code>(variable described above).</li><li><code>knowns::AbstractArray{fmi3ValueReference}</code>: Argument <code>knowns</code> contains values of type <code>fmi3ValueReference</code> which are identifiers of a variable value of the model.<code>knowns</code> can be equated with <code>knowns</code>(variable described above).</li><li><code>seed::fmi3Float64 = 1.0</code>:  If no seed value is passed the value <code>seed = 1.0</code> is used. Compute the partial derivative with respect to <code>knowns</code> with the value <code>seed = 1.0</code>.  # gehört das zu den v_rest values</li></ul><p><strong>Returns</strong></p><ul><li><code>sensitivity::Array{fmi3Float64}</code>: Return <code>sensitivity</code> contains the directional derivative vector values.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.11. Getting Partial Derivatives</li></ul><p>See also <a href="#FMIImport.fmi3GetDirectionalDerivative"><code>fmi3GetDirectionalDerivative</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2013-L2052">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetDirectionalDerivative(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetDirectionalDerivative(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L668-L673">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetDirectionalDerivative!" href="#FMICore.fmi3GetDirectionalDerivative!"><code>FMICore.fmi3GetDirectionalDerivative!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetDirectionalDerivative!(c::FMU3Instance,
                                   unknowns::AbstractArray{fmi3ValueReference},
                                   nUnknowns::Csize_t,
                                   knowns::AbstractArray{fmi3ValueReference},
                                   nKnowns::Csize_t,
                                   seed::AbstractArray{fmi3Float64},
                                   nSeed::Csize_t,
                                   sensitivity::AbstractArray{fmi3Float64},
                                   nSensitivity::Csize_t)</code></pre><p>Wrapper Function call to compute the partial derivative with respect to the variables <code>unknowns</code>.</p><p>Computes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = 𝐡(knowns, rest)</p><ul><li><code>unknowns</code>: vector of unknown Real variables computed in the actual Mode:</li><li>Initialization Mode: unkowns kisted under <code>&lt;ModelStructure&gt;&lt;InitialUnknown&gt;</code> that have type Real.</li><li>Continuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> and the variables listed as state derivatives under <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;)</code>.</li><li>Event Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>discrete</code>.</li><li>Step Mode (CoSimulation):  The variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> or <code>discrete</code>. If <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;</code> is present, also the variables listed here as state derivatives.</li><li><code>knowns</code>: Real input variables of function h that changes its value in the actual Mode.</li><li><code>rest</code>: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes</li></ul><p>Computes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:</p><p>Δunknowns = (δh / δknowns) Δknowns</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code> Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>unknowns::AbstracArray{fmi3ValueReference}</code>: Argument <code>unknowns</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model. <code>unknowns</code> can be equated with <code>unknowns</code>(variable described above).</li><li><code>nUnknowns::Csize_t</code>:</li><li><code>knowns::AbstractArray{fmi3ValueReference}</code>: Argument <code>knowns</code> contains values of type <code>fmi3ValueReference</code> which are identifiers of a variable value of the model.<code>knowns</code> can be equated with <code>knowns</code>(variable described above).</li><li><code>nKnowns::Csize_t</code>:</li><li><code>seed::AbstractArray{fmi3Float64}</code>:The vector values Compute the partial derivative with respect to the given entries in vector <code>knowns</code> with the matching evaluate of <code>sensitivity</code>.</li><li><code>nKnowns::Csize_t</code>:</li><li><code>sensitivity::AbstractArray{fmi3Float64}</code>: Stores the directional derivative vector values.</li><li><code>nKnowns::Csize_t</code>:</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.11. Getting Partial Derivatives</li></ul><p>See also <a href="#FMIImport.fmi3GetDirectionalDerivative"><code>fmi3GetDirectionalDerivative</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2047-L2102">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetDirectionalDerivative!(c::FMU3Instance,
    unknowns::AbstractArray{fmi3ValueReference},
    knowns::AbstractArray{fmi3ValueReference},
    sensitivity::AbstractArray{fmi3Float64},
    seed::AbstractArray{fmi3Float64})</code></pre><p>Wrapper Function call to compute the partial derivative with respect to the variables <code>unknowns</code>.</p><p>Computes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = 𝐡(knowns, rest)</p><ul><li><code>unknowns</code>: vector of unknown Real variables computed in the actual Mode:<ul><li>Initialization Mode: unkowns kisted under <code>&lt;ModelStructure&gt;&lt;InitialUnknown&gt;</code> that have type Real.</li><li>Continuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> and the variables listed as state derivatives under <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;)</code>.</li><li>Event Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>discrete</code>.</li><li>Step Mode (CoSimulation):  The variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> or <code>discrete</code>. If <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;</code> is present, also the variables listed here as state derivatives.</li></ul></li><li><code>knowns</code>: Real input variables of function h that changes its value in the actual Mode.</li><li><code>rest</code>: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes</li></ul><p>Computes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:</p><p>Δunknowns = (δh / δknowns) Δknowns</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code> Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>unknowns::AbstracArray{fmi3ValueReference}</code>: Argument <code>unknowns</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model. <code>unknowns</code> can be equated with <code>unknowns</code>(variable described above).</li><li><code>knowns::AbstractArray{fmi3ValueReference}</code>: Argument <code>knowns</code> contains values of type <code>fmi3ValueReference</code> which are identifiers of a variable value of the model.<code>knowns</code> can be equated with <code>knowns</code>(variable described above).</li><li><code>sensitivity::AbstractArray{fmi3Float64}</code>: Stores the directional derivative vector values.</li><li><code>seed::AbstractArray{fmi3Float64}</code>:The vector values Compute the partial derivative with respect to the given entries in vector <code>knowns</code> with the matching evaluate of <code>sensitivity</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.11. Getting Partial Derivatives</li></ul><p>See also <a href="#FMICore.fmi3GetDirectionalDerivative!"><code>fmi3GetDirectionalDerivative!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L1943-L1991">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.11. Getting Partial Derivatives</p><p>This function computes the directional derivatives v<em>{sensitivity} = J ⋅ v</em>{seed} of an FMU.</p><p>unknowns - contains value references to the unknowns.</p><p>nUnknowns - contains the length of argument unknowns.</p><p>knowns - contains value references of the knowns.</p><p>nKnowns - contains the length of argument knowns.</p><p>seed - contains the components of the seed vector.</p><p>nSeed - contains the length of seed.</p><p>sensitivity - contains the components of the sensitivity vector.</p><p>nSensitivity - contains the length of sensitivity.</p><p>This function can only be called if the &#39;ProvidesDirectionalDerivatives&#39; tag in the ModelDescription is set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L960-L982">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetDirectionalDerivative!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetDirectionalDerivative!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L679-L684">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetContinuousStateDerivatives" href="#FMIImport.fmi3GetContinuousStateDerivatives"><code>FMIImport.fmi3GetContinuousStateDerivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetContinuousStateDerivatives(c::FMU3Instance)</code></pre><p>Compute state derivatives at the current time instant and for the current states.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Returns</strong></p><ul><li><code>derivatives::Array{fmi3Float64}</code>: Returns an array of <code>fmi3Float64</code> values representing the <code>derivatives</code> for the current states. The ordering of the elements of the derivatives vector is identical to the ordering of the state</li></ul><p>vector.</p><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 3.2.1. State: Continuous-Time Mode</li></ul><p>See also <a href="#FMIImport.fmi3GetContinuousStateDerivatives"><code>fmi3GetContinuousStateDerivatives</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2521-L2540">source</a></section><section><div><p>fmi3GetContinuousStateDerivatives(fmu::FMU3)</p><p>Wrapper for <code>fmi3GetContinuousStateDerivatives(c::FMU3Instance)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L912-L917">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetContinuousStateDerivatives!" href="#FMICore.fmi3GetContinuousStateDerivatives!"><code>FMICore.fmi3GetContinuousStateDerivatives!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetContinuousStateDerivatives!(c::FMU3Instance,
                        derivatives::AbstractArray{fmi3Float64},
                        nx::Csize_t)</code></pre><p>Compute state derivatives at the current time instant and for the current states.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>derivatives::AbstractArray{fmi3Float64}</code>: Argument <code>derivatives</code> contains values of type <code>fmi3Float64</code> which is a alias type for <code>Real</code> data type.<code>derivatives</code> is the <code>AbstractArray</code> which contains the <code>Real</code> values of the vector that represent the derivatives. The ordering of the elements of the derivatives vector is identical to the ordering of the state vector.</li><li><code>nx::Csize_t</code>: Argument <code>nx</code> defines the length of vector <code>derivatives</code> and is provided for checking purposes</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 3.2.1. State: Continuous-Time Mode</li></ul><p>See also <a href="#FMICore.fmi3GetContinuousStateDerivatives!"><code>fmi3GetContinuousStateDerivatives!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2739-L2768">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetContinuousStateDerivatives!(c::FMU3Instance, derivatives::Array{fmi3Float64})</code></pre><p>Compute state derivatives at the current time instant and for the current states.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>derivatives::AbstractArray{fmi3Float64}</code>: Argument <code>derivatives</code> contains values of type <code>fmi3Float64</code> which is a alias type for <code>Real</code> data type.<code>derivatives</code> is the <code>AbstractArray</code> which contains the <code>Real</code> values of the vector that represent the derivatives. The ordering of the elements of the derivatives vector is identical to the ordering of the state vector.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 3.2.1. State: Continuous-Time Mode</li></ul><p>See also <a href="#FMICore.fmi3GetContinuousStateDerivatives!"><code>fmi3GetContinuousStateDerivatives!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2548-L2574">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode</p><p>Compute first-oder state derivatives at the current time instant and for the current states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1270-L1274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetAdjointDerivative!" href="#FMICore.fmi3GetAdjointDerivative!"><code>FMICore.fmi3GetAdjointDerivative!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetAdjointDerivative!(c::FMU3Instance,
            unknowns::AbstractArray{fmi3ValueReference},
            nUnknowns::Csize_t,
            knowns::AbstractArray{fmi3ValueReference},
            nKnowns::Csize_t,
            seed::AbstractArray{fmi3Float64},
            nSeed::Csize_t,
            sensitivity::AbstractArray{fmi3Float64},
            nSensitivity::Csize_t)</code></pre><p>Wrapper Function call to compute the partial derivative with respect to the variables <code>unknowns</code>.</p><p>Computes the adjoint derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = 𝐡(knowns, rest)</p><ul><li><code>unknowns</code>: vector of unknown Real variables computed in the actual Mode:</li><li>Initialization Mode: unkowns kisted under <code>&lt;ModelStructure&gt;&lt;InitialUnknown&gt;</code> that have type Real.</li><li>Continuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> and the variables listed as state derivatives under <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;)</code>.</li><li>Event Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>discrete</code>.</li><li>Step Mode (CoSimulation):  The variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> or <code>discrete</code>. If <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;</code> is present, also the variables listed here as state derivatives.</li><li><code>knowns</code>: Real input variables of function h that changes its value in the actual Mode.</li><li><code>rest</code>: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes</li></ul><p>Computes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:</p><p>Δunknowns = (δh / δknowns) Δknowns</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>unknowns::AbstracArray{fmi3ValueReference}</code>: Argument <code>unknowns</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model. <code>unknowns</code> can be equated with <code>unknowns</code>(variable described above).</li><li><code>nUnknowns::Csize_t</code>:</li><li><code>knowns::AbstractArray{fmi3ValueReference}</code>: Argument <code>knowns</code> contains values of type <code>fmi3ValueReference</code> which are identifiers of a variable value of the model.<code>knowns</code> can be equated with <code>knowns</code>(variable described above).</li><li><code>nKnowns::Csize_t</code>:</li><li><code>seed::AbstractArray{fmi3Float64}</code>:The vector values Compute the partial derivative with respect to the given entries in vector <code>knowns</code> with the matching evaluate of <code>sensitivity</code>.</li><li><code>nKnowns::Csize_t</code>:</li><li><code>sensitivity::AbstractArray{fmi3Float64}</code>: Stores the adjoint derivative vector values.</li><li><code>nKnowns::Csize_t</code>:</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.11. Getting Partial Derivatives</li></ul><p>See also <a href="#FMICore.fmi3GetAdjointDerivative!"><code>fmi3GetAdjointDerivative!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2122-L2177">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetAdjointDerivative!(c::FMU3Instance,
    unknowns::AbstractArray{fmi3ValueReference},
    knowns::AbstractArray{fmi3ValueReference},
    sensitivity::AbstractArray{fmi3Float64},
    seed::AbstractArray{fmi3Float64})</code></pre><p>Wrapper Function call to compute the partial derivative with respect to the variables <code>unknowns</code>.</p><p>Computes the adjoint derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = 𝐡(knowns, rest)</p><ul><li><code>unknowns</code>: vector of unknown Real variables computed in the actual Mode:<ul><li>Initialization Mode: unkowns kisted under <code>&lt;ModelStructure&gt;&lt;InitialUnknown&gt;</code> that have type Real.</li><li>Continuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> and the variables listed as state derivatives under <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;)</code>.</li><li>Event Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>discrete</code>.</li><li>Step Mode (CoSimulation):  The variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> or <code>discrete</code>. If <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;</code> is present, also the variables listed here as state derivatives.</li></ul></li><li><code>knowns</code>: Real input variables of function h that changes its value in the actual Mode.</li><li><code>rest</code>: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes</li></ul><p>Computes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:</p><p>Δunknowns = (δh / δknowns) Δknowns</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code> Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>unknowns::AbstracArray{fmi3ValueReference}</code>: Argument <code>unknowns</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model. <code>unknowns</code> can be equated with <code>unknowns</code>(variable described above).</li><li><code>knowns::AbstractArray{fmi3ValueReference}</code>: Argument <code>knowns</code> contains values of type <code>fmi3ValueReference</code> which are identifiers of a variable value of the model.<code>knowns</code> can be equated with <code>knowns</code>(variable described above).</li><li><code>sensitivity::AbstractArray{fmi3Float64}</code>: Stores the directional derivative vector values.</li><li><code>seed::AbstractArray{fmi3Float64}</code>:The vector values Compute the partial derivative with respect to the given entries in vector <code>knowns</code> with the matching evaluate of <code>sensitivity</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.11. Getting Partial Derivatives</li></ul><p>See also <a href="#FMICore.fmi3GetAdjointDerivative!"><code>fmi3GetAdjointDerivative!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2114-L2162">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.11. Getting Partial Derivatives</p><p>This function computes the adjoint derivatives v^T<em>{sensitivity}= v^T</em>{seed} ⋅ J of an FMU.</p><p>unknowns - contains value references to the unknowns.</p><p>nUnknowns - contains the length of argument unknowns.</p><p>knowns - contains value references of the knowns.</p><p>nKnowns - contains the length of argument knowns.</p><p>seed - contains the components of the seed vector.</p><p>nSeed - contains the length of seed.</p><p>sensitivity - contains the components of the sensitivity vector.</p><p>nSensitivity - contains the length of sensitivity.</p><p>This function can only be called if the &#39;ProvidesAdjointDerivatives&#39; tag in the ModelDescription is set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1003-L1025">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetAdjointDerivative!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetAdjointDerivative!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L702-L707">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetOutputDerivatives" href="#FMIImport.fmi3GetOutputDerivatives"><code>FMIImport.fmi3GetOutputDerivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fmi3GetOutputDerivatives!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nValueReferences::Csize<em>t, order::AbstractArray{fmi3Int32}, values::AbstractArray{fmi3Float64}, nValues::Csize</em>t)</p><p>Retrieves the n-th derivative of output values.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::Array{fmi3ValueReference}</code>: Argument <code>vr</code> is an array of <code>nValueReferences</code> value handels called &quot;ValueReference&quot; that t define the variables whose derivatives shall be set.</li><li><code>order::Array{fmi3Int32}</code>: Argument <code>order</code> is an array of fmi3Int32 values witch specifys the corresponding order of derivative of the real input variable.</li></ul><p><strong>Returns</strong></p><ul><li><code>value::AbstactArray{fmi3Float64}</code>: Return <code>value</code> is an array which represents a vector with the values of the derivatives.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.12. Getting Derivatives of Continuous Outputs</li></ul><p>See also <a href="#FMIImport.fmi3GetOutputDerivatives"><code>fmi3GetOutputDerivatives</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2232-L2252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetOutputDerivatives!" href="#FMICore.fmi3GetOutputDerivatives!"><code>FMICore.fmi3GetOutputDerivatives!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetOutputDerivatives!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nValueReferences::Csize_t, order::AbstractArray{fmi3Int32}, values::AbstractArray{fmi3Float64}, nValues::Csize_t)</code></pre><p>Retrieves the n-th derivative of output values.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::Array{fmi3ValueReference}</code>: Argument <code>vr</code> is an array of <code>nValueReferences</code> value handels called &quot;ValueReference&quot; that t define the variables whose derivatives shall be set.</li><li><code>nValueReferences::Csize_t</code>: Argument <code>nValueReferences</code> defines the size of <code>vr</code>.</li><li><code>order::Array{fmi3Int32}</code>: Argument <code>order</code> is an array of fmi3Int32 values witch specifys the corresponding order of derivative of the real input variable.</li><li><code>values::Array{fmi3Float64}</code>: Argument <code>values</code> is an array with the actual values of these variables.</li><li><code>nValues::Csize_t</code>: Argument <code>nValues</code> defines the size of <code>values</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.12. Getting Derivatives of Continuous Outputs</li></ul><p>See also <a href="#FMICore.fmi3GetOutputDerivatives!"><code>fmi3GetOutputDerivatives!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2196-L2226">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.2.12. Getting Derivatives of Continuous Outputs</p><p>Retrieves the n-th derivative of output values.</p><p>valueReferences - is a vector of value references that define the variables whose derivatives shall be retrieved. If multiple derivatives of a variable shall be retrieved, list the value reference multiple times.</p><p>nValueReferences - is the dimension of the arguments valueReferences and orders.</p><p>orders - contains the orders of the respective derivative (1 means the first derivative, 2 means the second derivative, …, 0 is not allowed).  If multiple derivatives of a variable shall be retrieved, provide a list of them in the orders array, corresponding to a multiply occurring value reference in the valueReferences array. The highest order of derivatives retrievable can be determined by the &#39;maxOutputDerivativeOrder&#39; tag in the ModelDescription.</p><p>values - is a vector with the values of the derivatives. The order of the values elements is derived from a twofold serialization: the outer level corresponds to the combination of a value reference (e.g., valueReferences[k]) and order (e.g., orders[k]), and the inner level to the serialization of variables as defined in Section 2.2.6.1. The inner level does not exist for scalar variables.</p><p>nValues - is the size of the argument values. nValues only equals nValueReferences if all corresponding output variables are scalar variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1045-L1061">source</a></section></article><h2 id="FMI-for-Model-Exchange"><a class="docs-heading-anchor" href="#FMI-for-Model-Exchange">FMI for Model Exchange</a><a id="FMI-for-Model-Exchange-1"></a><a class="docs-heading-anchor-permalink" href="#FMI-for-Model-Exchange" title="Permalink"></a></h2><p>This chapter contains the interface description to access the equations of a dynamic system from a C program.</p><h3 id="Providing-Independent-Variables-and-Re-initialization-of-Caching"><a class="docs-heading-anchor" href="#Providing-Independent-Variables-and-Re-initialization-of-Caching">Providing Independent Variables and Re-initialization of Caching</a><a id="Providing-Independent-Variables-and-Re-initialization-of-Caching-1"></a><a class="docs-heading-anchor-permalink" href="#Providing-Independent-Variables-and-Re-initialization-of-Caching" title="Permalink"></a></h3><p>Depending on the situation, different variables need to be computed. In order to be efficient, it is important that the interface requires only the computation of variables that are needed in the present context. The state derivatives shall be reused from the previous call. This feature is called “caching of variables” in the sequel. Caching requires that the model evaluation can detect when the input arguments, like time or states, have changed.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetTime" href="#FMICore.fmi3SetTime"><code>FMICore.fmi3SetTime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetTime(c::FMU3Instance, time::fmi3Float64)</code></pre><p>Set a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>time::fmi3Float64</code>: Argument <code>time</code> contains a value of type <code>fmi3Float64</code> which is a alias type for <code>Real</code> data type. <code>time</code> sets the independent variable time t.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 3.2.1. State: Continuous-Time Mode</li></ul><p>See also <a href="#FMICore.fmi3SetTime"><code>fmi3SetTime</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2660-L2686">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetTime(c::FMU3Instance, time::Real)</code></pre><p>Set a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>t::Real</code>: Argument <code>t</code> contains a value of type <code>Real</code> which is a alias type for <code>Real</code> data type. <code>time</code> sets the independent variable time t.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 3.2.1. State: Continuous-Time Mode</li></ul><p>See also <a href="#FMICore.fmi3SetTime"><code>fmi3SetTime</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2453-L2478">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode</p><p>Set a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1238-L1242">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetTime(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetTime(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L890-L895">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3SetContinuousStates" href="#FMICore.fmi3SetContinuousStates"><code>FMICore.fmi3SetContinuousStates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SetContinuousStates(c::FMU3Instance,
    x::AbstractArray{fmi3Float64},
    nx::Csize_t)</code></pre><p>Set a new (continuous) state vector and re-initialize caching of variables that depend on the states. Argument nx is the length of vector x and is provided for checking purposes</p><p>If <code>fmi3UpdateDiscreteStates</code> returned with <code>nominalsOfContinuousStatesChanged == fmi3True</code>, then at least one nominal value of the states has changed and can be inquired with <code>fmi3GetNominalsOfContinuousStates</code>. Not allowed in Co-Simulation and Scheduled Execution.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.</li><li><code>x::AbstractArray{fmi3Float64}</code>: Argument <code>x</code> contains values of type <code>fmi3Float64</code> which is a alias type for <code>Real</code> data type. <code>x</code> is the <code>AbstractArray</code> which contains the <code>Real</code> values of the vector that represent the nominal values of the continuous states.</li><li><code>nx::Csize_t</code>: Argument <code>nx</code> defines the length of vector <code>x</code> and is provided for checking purposes</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 3.2.1. State: Continuous-Time Mode</li></ul><p>See also <a href="#FMICore.fmi3SetContinuousStates"><code>fmi3SetContinuousStates</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2698-L2729">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetContinuousStates(c::FMU3Instance, x::Union{AbstractArray{Float32}, AbstractArray{Float64}})</code></pre><p>Set a new (continuous) state vector and re-initialize caching of variables that depend on the states. Argument nx is the length of vector x and is provided for checking purposes</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.</li><li><code>x::Union{AbstractArray{Float32},AbstractArray{Float64}}</code>:Argument <code>x</code> is the <code>AbstractArray</code> of the vector values of <code>Float64</code> or <code>Float32</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 3.2.1. State: Continuous-Time Mode</li></ul><p>See also <a href="#FMICore.fmi3SetContinuousStates"><code>fmi3SetContinuousStates</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2485-L2511">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode</p><p>Set a new (continuous) state vector and re-initialize caching of variables that depend on the states. Argument nx is the length of vector x and is provided for checking purposes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1253-L1257">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SetContinuousStates(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SetContinuousStates(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L901-L906">source</a></section></article><h3 id="Evaluation-of-Model-Equations"><a class="docs-heading-anchor" href="#Evaluation-of-Model-Equations">Evaluation of Model Equations</a><a id="Evaluation-of-Model-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-of-Model-Equations" title="Permalink"></a></h3><p>This section contains the core functions to evaluate the model equations.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3EnterEventMode" href="#FMICore.fmi3EnterEventMode"><code>FMICore.fmi3EnterEventMode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3EnterEventMode(c::FMU3Instance, stepEvent::fmi3Boolean, stateEvent::fmi3Boolean, rootsFound::AbstractArray{fmi3Int32}, nEventIndicators::Csize_t, timeEvent::fmi3Boolean; soft::Bool=false)</code></pre><p>The model enters Event Mode from the Continuous-Time Mode in ModelExchange oder Step Mode in CoSimulation and discrete-time equations may become active (and relations are not “frozen”).</p><p><strong>TODO argmuents</strong></p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>stepEvent::fmi3Boolean</code>: </li><li><code>stateEvent::fmi3Boolean</code>: </li><li><code>rootsFound::AbstractArray{fmi3Int32}</code>: </li><li><code>nEventIndicators::Csize_t</code>: </li><li><code>timeEvent::fmi3Boolean</code>: </li><li><code>soft::Bool=false</code>: </li></ul><p><strong>Keywords</strong></p><ul><li><code>soft::Bool=false</code>: If the Keyword <code>soft = true</code> the <code>fmi3Teminate</code> needs to be called in state  <code>fmi3InstanceStateContinuousTimeMode</code> or <code>fmi3InstanceStateEventMode</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 3.2.1. State: Continuous-Time Mode</li></ul><p>See also <a href="#FMICore.fmi3EnterEventMode"><code>fmi3EnterEventMode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2856-L2891">source</a></section><section><div><pre><code class="language-julia hljs">fmi3EnterEventMode(c::FMU3Instance, stepEvent::Bool, stateEvent::Bool, rootsFound::AbstractArray{fmi3Int32}, nEventIndicators::Csize_t, timeEvent::Bool)</code></pre><p>The model enters Event Mode from the Continuous-Time Mode in ModelExchange oder Step Mode in CoSimulation and discrete-time equations may become active (and relations are not “frozen”).</p><p><strong>TODO argmuents</strong></p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>stepEvent::Bool</code>:  </li><li><code>stateEvent::Bool</code>: </li><li><code>rootsFound::AbstractArray{fmi3Int32}</code>: </li><li><code>nEventIndicators::Csize_t</code>: </li><li><code>timeEvent::Bool</code>: </li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 3.2.1. State: Continuous-Time Mode</li></ul><p>See also <a href="#FMICore.fmi3EnterEventMode"><code>fmi3EnterEventMode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2703-L2734">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode</p><p>The model enters Event Mode from the Continuous-Time Mode in ModelExchange oder Step Mode in CoSimulation and discrete-time equations may become active (and relations are not “frozen”).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1322-L1326">source</a></section><section><div><pre><code class="language-julia hljs">fmi3EnterEventMode(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3EnterEventMode(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L945-L950">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3EnterContinuousTimeMode" href="#FMICore.fmi3EnterContinuousTimeMode"><code>FMICore.fmi3EnterContinuousTimeMode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3EnterContinuousTimeMode(c::FMU3Instance; soft::Bool=false)</code></pre><p>The model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are “frozen”. This function has to be called when changing from Event Mode (after the global event iteration in Event Mode over all involved FMUs and other models has converged) into Continuous-Time Mode.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Keywords</strong></p><ul><li><code>soft::Bool=false</code>: If the Keyword <code>soft = true</code> the <code>fmi3Teminate</code> needs to be called in state  <code>fmi3InstanceStateContinuousTimeMode</code> or <code>fmi3InstanceStateEventMode</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.5. State: Event Mode</li></ul><p>See also <a href="#FMICore.fmi3EnterContinuousTimeMode"><code>fmi3EnterContinuousTimeMode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2564-L2593">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.5. State: Event Mode</p><p>The model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are “frozen”. This function has to be called when changing from Event Mode (after the global event iteration in Event Mode over all involved FMUs and other models has converged) into Continuous-Time Mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1207-L1212">source</a></section><section><div><pre><code class="language-julia hljs">fmi3EnterContinuousTimeMode(fmu::FMU3)</code></pre><p>Wrapper for <code>fmi3EnterContinuousTimeMode(c::FMU3Instance)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L857-L862">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3CompletedIntegratorStep" href="#FMIImport.fmi3CompletedIntegratorStep"><code>FMIImport.fmi3CompletedIntegratorStep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3CompletedIntegratorStep!(c::FMU3Instance, noSetFMUStatePriorToCurrentPoint::fmi3Boolean)</code></pre><p>This function must be called by the environment after every completed step</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>noSetFMUStatePriorToCurrentPoint::fmi3Boolean</code>: Argument <code>noSetFMUStatePriorToCurrentPoint = fmi3True</code> if <code>fmi3SetFMUState</code>  will no longer be called for time instants prior to current time in this simulation run.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li><li><code>enterEventMode::Array{fmi3Boolean, 1}</code>: Returns <code>enterEventMode[1]</code> to signal to the environment if the FMU shall call <code>fmi2EnterEventMode</code></li><li><code>terminateSimulation::Array{fmi3Boolean, 1}</code>: Returns <code>terminateSimulation[1]</code> to signal if the simulation shall be terminated.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 3.2.1. State: Continuous-Time Mode</li></ul><p>See also <a href="#FMIImport.fmi3CompletedIntegratorStep"><code>fmi3CompletedIntegratorStep</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2658-L2686">source</a></section><section><div><p>fmi3CompletedIntegratorStep(fmu::FMU3, args...; kwargs...)</p><p>Wrapper for <code>fmi3CompletedIntegratorStep(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L934-L939">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3CompletedIntegratorStep!" href="#FMICore.fmi3CompletedIntegratorStep!"><code>FMICore.fmi3CompletedIntegratorStep!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3CompletedIntegratorStep!(c::FMU3Instance,
                                  noSetFMUStatePriorToCurrentPoint::fmi3Boolean,
                                  enterEventMode::Ref{fmi3Boolean},
                                  terminateSimulation::Ref{fmi3Boolean})</code></pre><p>This function must be called by the environment after every completed step of the integrator provided the capability flag <code>needsCompletedIntegratorStep == true</code>. If <code>enterEventMode == fmi3True</code>, the event mode must be entered If <code>terminateSimulation == fmi3True</code>, the simulation shall be terminated</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>noSetFMUStatePriorToCurrentPoint::fmi3Boolean</code>: Argument <code>noSetFMUStatePriorToCurrentPoint = fmi3True</code> if <code>fmi3SetFMUState</code>  will no longer be called for time instants prior to current time in this simulation run.</li><li><code>enterEventMode::Ref{fmi3Boolean}</code>: Argument <code>enterEventMode</code> points to the return value (fmi3Boolean) which signals to the environment if the FMU shall call <code>fmi3EnterEventMode</code>. <code>fmi3Boolean</code> is an alias type for <code>Boolean</code> data type.</li><li><code>terminateSimulation::Ref{fmi3Boolean}</code>: Argument <code>terminateSimulation</code> points to the return value (fmi3Boolean) which signals signal if the simulation shall be terminated. <code>fmi3Boolean</code> is an alias type for <code>Boolean</code> data type.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 3.2.1. State: Continuous-Time Mode</li></ul><p>See also <a href="#FMICore.fmi3CompletedIntegratorStep!"><code>fmi3CompletedIntegratorStep!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2813-L2845">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode</p><p>This function must be called by the environment after every completed step of the integrator provided the capability flag needsCompletedIntegratorStep = true. If enterEventMode == fmi3True, the event mode must be entered If terminateSimulation == fmi3True, the simulation shall be terminated</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1302-L1308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetEventIndicators!" href="#FMICore.fmi3GetEventIndicators!"><code>FMICore.fmi3GetEventIndicators!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetEventIndicators!(c::FMU3Instance, eventIndicators::AbstractArray{fmi3Float64}, ni::Csize_t)</code></pre><p>Compute event indicators at the current time instant and for the current states. EventIndicators signal Events by their sign change.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>eventIndicators::AbstractArray{fmi3Float64}</code>: Argument <code>eventIndicators</code> contains values of type <code>fmi3Float64</code> which is a alias type for <code>Real</code> data type.<code>eventIndicators</code> is the <code>AbstractArray</code> which contains the <code>Real</code> values of the vector that represent the event indicators.</li><li><code>ni::Csize_t</code>: Argument <code>ni</code> defines the length of vector <code>eventIndicators</code> and is provided for checking purposes</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 3.2.1. State: Continuous-Time Mode</li></ul><p>See also <a href="#FMICore.fmi3GetEventIndicators!"><code>fmi3GetEventIndicators!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2778-L2805">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode</p><p>Compute event indicators at the current time instant and for the current states. EventIndicators signal Events by their sign change.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1287-L1291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetContinuousStates!" href="#FMICore.fmi3GetContinuousStates!"><code>FMICore.fmi3GetContinuousStates!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetContinuousStates!(c::FMU3Instance, nominals::AbstractArray{fmi3Float64}, nContinuousStates::Csize_t)</code></pre><p>Return the states at the current time instant.</p><p>This function must be called if <code>fmi3UpdateDiscreteStates</code> returned with <code>valuesOfContinuousStatesChanged == fmi3True</code>. Not allowed in Co-Simulation and Scheduled Execution.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.</li><li><code>nominals::AbstractArray{fmi3Float64}</code>: Argument <code>nominals</code> contains values of type <code>fmi3Float64</code> which is a alias type for <code>Real</code> data type. <code>nominals</code> is the <code>AbstractArray</code> which contains the <code>Real</code> values of the vector that represent the new state vector.</li><li><code>nContinuousStates::Csize_t</code>: Argument <code>nContinuousStates</code> defines the length of vector <code>nominals</code> and is provided for checking purposes</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.3. State: Initialization Mode</li></ul><p>See also <a href="#FMICore.fmi3GetContinuousStates!"><code>fmi3GetContinuousStates!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2412-L2441">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.3. State: Initialization Mode</p><p>Return the states at the current time instant.</p><p>This function must be called if fmi3UpdateDiscreteStates returned with valuesOfContinuousStatesChanged == fmi3True. Not allowed in Co-Simulation and Scheduled Execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1138-L1144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetNominalsOfContinuousStates!" href="#FMICore.fmi3GetNominalsOfContinuousStates!"><code>FMICore.fmi3GetNominalsOfContinuousStates!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetNominalsOfContinuousStates!(c::FMU3Instance, x_nominal::AbstractArray{fmi3Float64}, nx::Csize_t)</code></pre><p>Return the nominal values of the continuous states.</p><p>If <code>fmi3UpdateDiscreteStates</code> returned with <code>nominalsOfContinuousStatesChanged == fmi3True</code>, then at least one nominal value of the states has changed and can be inquired with <code>fmi3GetNominalsOfContinuousStates</code>. Not allowed in Co-Simulation and Scheduled Execution.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.</li><li><code>x_nominal::AbstractArray{fmi3Float64}</code>: Argument <code>x_nominal</code> contains values of type <code>fmi3Float64</code> which is a alias type for <code>Real</code> data type. <code>x_nominal</code> is the <code>AbstractArray</code> which contains the <code>Real</code> values of the vector that represent the nominal values of the continuous states.</li><li><code>nx::Csize_t</code>: Argument <code>nx</code> defines the length of vector <code>x_nominal</code> and is provided for checking purposes</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.3. State: Initialization Mode</li></ul><p>See also <a href="#FMICore.fmi3GetNominalsOfContinuousStates!"><code>fmi3GetNominalsOfContinuousStates!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2449-L2479">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.3. State: Initialization Mode</p><p>Return the nominal values of the continuous states.</p><p>If fmi3UpdateDiscreteStates returned with nominalsOfContinuousStatesChanged == fmi3True, then at least one nominal value of the states has changed and can be inquired with fmi3GetNominalsOfContinuousStates. Not allowed in Co-Simulation and Scheduled Execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1155-L1162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetNumberOfContinuousStates" href="#FMIImport.fmi3GetNumberOfContinuousStates"><code>FMIImport.fmi3GetNumberOfContinuousStates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetNumberOfContinuousStates(c::FMU3Instance)</code></pre><p>This function returns the number of continuous states. This function can only be called in Model Exchange. </p><p><code>fmi3GetNumberOfContinuousStates</code> must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Returns</strong></p><ul><li><code>size::Integer</code>: Return <code>size</code> is the number of continuous states of this instance </li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.3.2. State: Instantiated</li></ul><p>See also <a href="#FMIImport.fmi3GetNumberOfContinuousStates"><code>fmi3GetNumberOfContinuousStates</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2267-L2287">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetNumberOfContinuousStates(fmu::FMU3)</code></pre><p>Wrapper for <code>fmi3GetNumberOfContinuousStates(c::FMU3Instance)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L780-L785">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetNumberOfContinuousStates!" href="#FMICore.fmi3GetNumberOfContinuousStates!"><code>FMICore.fmi3GetNumberOfContinuousStates!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetNumberOfContinuousStates!(c::FMU3Instance, nContinuousStates::Ref{Csize_t})</code></pre><p>This function returns the number of continuous states. This function can only be called in Model Exchange. </p><p><code>fmi3GetNumberOfContinuousStates</code> must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>nContinuousStates::Ref{Csize_t}</code>: Stores the number of continuous states returned by the function</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.2. State: Instantiated</li></ul><p>See also <a href="#FMICore.fmi3GetNumberOfContinuousStates!"><code>fmi3GetNumberOfContinuousStates!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2340-L2368">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.2. State: Instantiated</p><p>This function returns the number of continuous states. This function can only be called in Model Exchange. </p><p>fmi3GetNumberOfContinuousStates must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1102-L1109">source</a></section></article><h2 id="FMI-for-Co-Simulation"><a class="docs-heading-anchor" href="#FMI-for-Co-Simulation">FMI for Co-Simulation</a><a id="FMI-for-Co-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#FMI-for-Co-Simulation" title="Permalink"></a></h2><p>This chapter defines the Functional Mock-up Interface (FMI) for the coupling of two or more simulation models in a Co-Simulation environment (FMI for Co-Simulation). Co-Simulation is a rather general approach to the simulation of coupled technical systems and coupled physical phenomena in engineering with focus on instationary (time-dependent) problems.</p><h3 id="Transfer-of-Input-/-Output-Values-and-Parameters"><a class="docs-heading-anchor" href="#Transfer-of-Input-/-Output-Values-and-Parameters">Transfer of Input / Output Values and Parameters</a><a id="Transfer-of-Input-/-Output-Values-and-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Transfer-of-Input-/-Output-Values-and-Parameters" title="Permalink"></a></h3><p>In order to enable the slave to interpolate the continuous real inputs between communication steps, the derivatives of the inputs with respect to time can be provided. Also, higher derivatives can be set to allow higher order interpolation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3CallbackIntermediateUpdate" href="#FMIImport.fmi3CallbackIntermediateUpdate"><code>FMIImport.fmi3CallbackIntermediateUpdate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3CallbackIntermediateUpdate(instanceEnvironment::Ptr{Cvoid},
    intermediateUpdateTime::fmi3Float64,
    intermediateVariableSetRequested::fmi3Boolean,
    intermediateVariableGetAllowed::fmi3Boolean,
    intermediateStepFinished::fmi3Boolean,
    canReturnEarly::fmi3Boolean,
    earlyReturnRequested::Ptr{fmi3Boolean},
    earlyReturnTime::Ptr{fmi3Float64})</code></pre><p>When a Co-Simulation FMU provides values for its output variables at intermediate points between two consecutive communication points, and is able to receive new values for input variables at these intermediate points, the Intermediate Update Callback function is called. This is typically required when the FMU uses a numerical solver to integrate the FMU&#39;s internal state between communication points in <code>fmi3DoStep</code>.  The callback function switches the FMU from Step Mode (see 4.2.1.) in the Intermediate Update Mode (see 4.2.2.) and returns to Step Mode afterwards. If the ModelDescription has the &quot;providesIntermediateUpdate&quot; flag, the Intermediate update callback function is called. That flag is ignored in ModelExchange and ScheduledExecution.</p><p><strong>Arguments</strong></p><ul><li><code>instanceEnvironment::Ptr{FMU3InstanceEnvironment}</code>: is the instance name of the model that calls this function. </li><li><code>intermediateUpdateTime::fmi3Float64</code>: is the internal value of the independent variable [typically simulation time] of the FMU at which the callback has been called for intermediate and final steps. If an event happens or an output Clock ticks, intermediateUpdateTime is the time of event or output Clock tick. In Co-Simulation, intermediateUpdateTime is restricted by the arguments to fmi3DoStep as follows:   currentCommunicationPoint ≤ intermediateUpdateTime ≤ (currentCommunicationPoint + communicationStepSize).   The FMU must not call the callback function fmi3CallbackIntermediateUpdate with an intermediateUpdateTime that is smaller than the intermediateUpdateTime given in a previous call of fmi3CallbackIntermediateUpdate with intermediateStepFinished == fmi3True.</li><li><code>intermediateVariableSetRequested::fmi3Boolean</code>: If <code>intermediateVariableSetRequested == fmi3True</code>, the co-simulation algorithm may provide intermediate values for continuous input variables with <code>intermediateUpdate = true</code> by calling fmi3Set{VariableType}. The set of variables for which the co-simulation algorithm will provide intermediate values is declared through the requiredIntermediateVariables argument to <code>fmi3InstantiateXXX</code>. If a co-simulation algorithm does not provide a new value for any of the variables contained in the set it registered, the last value set remains.</li><li><code>intermediateVariableGetAllowed::fmi3Boolean</code>: If <code>intermediateVariableGetAllowed == fmi3True</code>, the co-simulation algorithm may collect intermediate output variables by calling fmi3Get{VariableType} for variables with <code>intermediateUpdate = true</code>. The set of variables for which the co-simulation algorithm can get values is supplied through the requiredIntermediateVariables argument to <code>fmi3InstantiateXXX</code>.</li><li><code>intermediateStepFinished::fmi3Boolean</code>: If <code>intermediateStepFinished == fmi3False</code>, the intermediate outputs of the FMU that the co-simulation algorithm inquires with fmi3Get{VariableType} resulting from tentative internal solver states and may still change for the same intermediateUpdateTime [e.g., if the solver deems the tentative state to cause a too high approximation error, it may go back in time and try to re-estimate the state using smaller internal time steps].                             If <code>intermediateStepFinished == fmi3True</code>, intermediate outputs inquired by the co-simulation algorithm with fmi3Get{VariableType} correspond to accepted internal solver step.</li><li><code>canReturnEarly::fmi3Boolean</code>: When <code>canReturnEarly == fmi3True</code> the FMU signals to the co-simulation algorithm its ability to return early from the current <code>fmi3DoStep</code>.</li><li><code>earlyReturnRequested::Ptr{fmi3Boolean}</code>: If and only if <code>canReturnEarly == fmi3True</code>, the co-simulation algorithm may request the FMU to return early from <code>fmi3DoStep</code> by setting <code>earlyReturnRequested == fmi3True</code>.</li><li><code>earlyReturnTime::Ptr{fmi3Float64}</code>: is used to signal the FMU at which time to return early from the current <code>fmi3DoStep</code>, if the return value of <code>earlyReturnRequested == fmi3True</code>. If the earlyReturnTime is greater than the last signaled intermediateUpdateTime, the FMU may integrate up to the time instant earlyReturnTime.</li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 4.2.2. State: Intermediate Update Mode</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L74-L108">source</a></section></article><h3 id="Computation"><a class="docs-heading-anchor" href="#Computation">Computation</a><a id="Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Computation" title="Permalink"></a></h3><p>The computation of time steps is controlled by the following function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3EnterStepMode" href="#FMICore.fmi3EnterStepMode"><code>FMICore.fmi3EnterStepMode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3EnterStepMode(c::FMU3Instance; soft::Bool=false)</code></pre><p>This function must be called to change from Event Mode into Step Mode in Co-Simulation (see 4.2.).</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li></ul><p><strong>Keywords</strong></p><ul><li><code>soft::Bool=false</code>: If the Keyword <code>soft = true</code> the <code>fmi3Teminate</code> needs to be called in state  <code>fmi3InstanceStateContinuousTimeMode</code> or <code>fmi3InstanceStateEventMode</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.3.5. State: Event Mode</li></ul><p>See also <a href="#FMICore.fmi3EnterStepMode"><code>fmi3EnterStepMode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2612-L2640">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.3.5. State: Event Mode</p><p>This function must be called to change from Event Mode into Step Mode in Co-Simulation (see 4.2.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1223-L1227">source</a></section><section><div><pre><code class="language-julia hljs">fmi3EnterStepMode(fmu::FMU3)</code></pre><p>Wrapper for <code>fmi3EnterStepMode(c::FMU3Instance)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L868-L873">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3DoStep!" href="#FMICore.fmi3DoStep!"><code>FMICore.fmi3DoStep!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3DoStep!(c::FMU3Instance, currentCommunicationPoint::fmi3Float64, communicationStepSize::fmi3Float64, noSetFMUStatePriorToCurrentPoint::fmi3Boolean,
                eventEncountered::Ref{fmi3Boolean}, terminateSimulation::Ref{fmi3Boolean}, earlyReturn::Ref{fmi3Boolean}, lastSuccessfulTime::Ref{fmi3Float64})</code></pre><p>The computation of a time step is started.</p><p><strong>TODO argmuents</strong></p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>currentCommunicationPoint::fmi3Float64</code>:  </li><li><code>communicationStepSize::fmi3Float64</code>: </li><li><code>noSetFMUStatePriorToCurrentPoint::fmi3Boolean</code>: </li><li><code>eventEncountered::Ref{fmi3Boolean}</code>: </li><li><code>terminateSimulation::Ref{fmi3Boolean}</code>: </li><li><code>earlyReturn::Ref{fmi3Boolean}</code>: </li><li><code>lastSuccessfulTime::Ref{fmi3Float64}</code>: </li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions</li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 4.2.1. State: Step Mode</li></ul><p>See also <a href="#FMICore.fmi3DoStep!"><code>fmi3DoStep!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2911-L2945">source</a></section><section><div><pre><code class="language-julia hljs">fmi3DoStep!(c::FMU3Instance, currentCommunicationPoint::Union{Real, Nothing} = nothing, communicationStepSize::Union{Real, Nothing} = nothing, noSetFMUStatePriorToCurrentPoint::Bool = true,
    eventEncountered::fmi3Boolean = fmi3False, terminateSimulation::fmi3Boolean = fmi3False, earlyReturn::fmi3Boolean = fmi3False, lastSuccessfulTime::fmi3Float64 = 0.0)</code></pre><p>The computation of a time step is started.</p><p><strong>TODO argmuents</strong></p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>currentCommunicationPoint::Union{Real, Nothing} = nothing</code></li><li><code>communicationStepSize::Union{Real, Nothing} = nothing</code></li><li><code>noSetFMUStatePriorToCurrentPoint::Bool = true</code></li><li><code>eventEncountered::fmi3Boolean = fmi3False</code></li><li><code>terminateSimulation::fmi3Boolean = fmi3False</code></li><li><code>earlyReturn::fmi3Boolean = fmi3False</code></li><li><code>lastSuccessfulTime::fmi3Float64 = 0.0</code></li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions</li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 4.2.1. State: Step Mode</li></ul><p>See also <a href="#FMICore.fmi3DoStep!"><code>fmi3DoStep!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/int.jl#L2739-L2772">source</a></section><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 4.2.1. State: Step Mode</p><p>The computation of a time step is started.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cfunc.jl#L1337-L1341">source</a></section><section><div><pre><code class="language-julia hljs">fmi3DoStep!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3DoStep!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L956-L961">source</a></section></article><h3 id="Retrieving-Status-Information-from-the-Slave"><a class="docs-heading-anchor" href="#Retrieving-Status-Information-from-the-Slave">Retrieving Status Information from the Slave</a><a id="Retrieving-Status-Information-from-the-Slave-1"></a><a class="docs-heading-anchor-permalink" href="#Retrieving-Status-Information-from-the-Slave" title="Permalink"></a></h3><p>Status information is retrieved from the slave by the following functions:</p><h2 id="non-FMI-spec-functions"><a class="docs-heading-anchor" href="#non-FMI-spec-functions">non FMI-spec functions</a><a id="non-FMI-spec-functions-1"></a><a class="docs-heading-anchor-permalink" href="#non-FMI-spec-functions" title="Permalink"></a></h2><p>These new functions, that are useful, but not part of the FMI-spec. (example: <code>fmi3Load</code>, <code>fmi3SampleJacobian</code>)</p><h3 id="Opening-and-closing-FMUs"><a class="docs-heading-anchor" href="#Opening-and-closing-FMUs">Opening and closing FMUs</a><a id="Opening-and-closing-FMUs-1"></a><a class="docs-heading-anchor-permalink" href="#Opening-and-closing-FMUs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3Unzip" href="#FMIImport.fmi3Unzip"><code>FMIImport.fmi3Unzip</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3Unzip(pathToFMU::String; unpackPath=nothing, cleanup=true)</code></pre><p>Create a copy of the .fmu file as a .zip folder and unzips it. Returns the paths to the zipped and unzipped folders.</p><p><strong>Arguments</strong></p><ul><li><code>pathToFMU::String</code>: The folder path to the .zip folder.</li></ul><p><strong>Keywords</strong></p><ul><li><code>unpackPath=nothing</code>: Via optional argument <code>unpackPath</code>, a path to unpack the FMU can be specified (default: system temporary directory).</li><li><code>cleanup=true</code>: The cleanup option controls whether the temporary directory is automatically deleted when the process exits.</li></ul><p><strong>Returns</strong></p><ul><li><code>unzippedAbsPath::String</code>: Contains the Path to the uzipped Folder.</li><li><code>zipAbsPath::String</code>: Contains the Path to the zipped Folder.</li></ul><p>See also <a href="https://docs.julialang.org/en/v1/base/file/#Base.Filesystem.mktempdir-Tuple{AbstractString}"><code>mktempdir</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L13-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3Unload" href="#FMIImport.fmi3Unload"><code>FMIImport.fmi3Unload</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function fmi3Unload(fmu::FMU3, cleanUp::Bool = true)</code></pre><p>Unload a FMU. Free the allocated memory, close the binaries and remove temporary zip and unziped FMU model description.</p><p><strong>Arguments</strong></p><ul><li><code>fmu::FMU3</code>: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.</li><li><code>cleanUp::Bool= true</code>: Defines if the file, link, or empty directory should be deleted.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L707-L717">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3Load" href="#FMIImport.fmi3Load"><code>FMIImport.fmi3Load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3Load(pathToFMU::String; unpackPath=nothing, type=nothing, cleanup=true)</code></pre><p>Sets the properties of the fmu by reading the modelDescription.xml. Retrieves all the pointers of binary functions.</p><p><strong>Arguments</strong></p><ul><li><code>pathToFMU::String</code>: The folder path to the .fmu file.</li></ul><p><strong>Keywords</strong></p><ul><li><code>unpackPath=nothing</code>: Via optional argument <code>unpackPath</code>, a path to unpack the FMU can be specified (default: system temporary directory).</li><li><code>type=nothing</code>: Defines whether a Co-Simulation or Model Exchange is present</li><li><code>cleanup=true</code>: The cleanup option controls whether the temporary directory is automatically deleted when the process exits.</li></ul><p><strong>Returns</strong></p><ul><li>Returns the instance of the FMU struct.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec2.0.2: 2.4.7  Model Variables</li></ul><p>See also .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L95-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3Reload" href="#FMIImport.fmi3Reload"><code>FMIImport.fmi3Reload</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3Reload(fmu::FMU3)</code></pre><p>Reloads the FMU-binary. This is useful, if the FMU does not support a clean reset implementation.</p><p><strong>Arguments</strong></p><ul><li><code>fmu::FMU3</code>: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.4.7 Model Variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L689-L701">source</a></section></article><h3 id="Conversion-functions"><a class="docs-heading-anchor" href="#Conversion-functions">Conversion functions</a><a id="Conversion-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3StringToValueReference" href="#FMIImport.fmi3StringToValueReference"><code>FMIImport.fmi3StringToValueReference</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns an array of ValueReferences coresponding to the variable names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/convert.jl#L33-L35">source</a></section><section><div><p>Returns the ValueReference coresponding to the variable name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/convert.jl#L62-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3ModelVariablesForValueReference" href="#FMIImport.fmi3ModelVariablesForValueReference"><code>FMIImport.fmi3ModelVariablesForValueReference</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the model variable(s) fitting the value reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/convert.jl#L49-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3ValueReferenceToString" href="#FMIImport.fmi3ValueReferenceToString"><code>FMIImport.fmi3ValueReferenceToString</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns an array of variable names matching a fmi3ValueReference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/convert.jl#L79-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3IntervalQualifierToString" href="#FMICore.fmi3IntervalQualifierToString"><code>FMICore.fmi3IntervalQualifierToString</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3IntervalQualifierToString(c::fmi3IntervalQualifier)</code></pre><p>Convert <a href="#FMICore.fmi3IntervalQualifier"><code>fmi3IntervalQualifier</code></a> <code>c</code> to the corresponding String (&quot;intervalNotYetKnown&quot;, &quot;intervalUnchanged&quot;, &quot;intervalChanged&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StringToIntervalQualifier" href="#FMICore.fmi3StringToIntervalQualifier"><code>FMICore.fmi3StringToIntervalQualifier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3StringToIntervalQualifier(s::AbstractString)</code></pre><p>Convert <code>s</code> (&quot;intervalNotYetKnown&quot;, &quot;intervalUnchanged&quot;, &quot;intervalChanged&quot;) to the corresponding <a href="#FMICore.fmi3IntervalQualifier"><code>fmi3IntervalQualifier</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3Causality" href="#FMICore.fmi3Causality"><code>FMICore.fmi3Causality</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Source: FMISpec3.0, Version D5ef1c1: 2.4.7.4. Variable Attributes Enumeration that defines the causality of the variable. Allowed values of this enumeration:</p><p>parameter - A data value that is constant during the simulation (except for tunable parameters, see there) and is provided by the environment and cannot be used in connections, except for parameter propagation in terminals as described in Section 2.4.9.2.6. variability must be fixed or tunable. These parameters can be changed independently, unlike calculated parameters. initial must be exact or not present (meaning exact).</p><p>calculatedParameter - A data value that is constant during the simulation and is computed during initialization or when tunable parameters change. variability must be fixed or tunable. initial must be approx, calculated or not present (meaning calculated).</p><p>input - The variable value can be provided by the importer. [For example, the importer could forward the output of another FMU into this input.]</p><p>output -  The variable value can be used by the importer. [For example, this value can be forwarded to an input of another FMU.] The algebraic relationship to the inputs can be defined via the dependencies attribute of &lt;fmiModelDescription&gt;&lt;ModelStructure&gt;&lt;Output&gt;.</p><p>local -  Local variables are:</p><ul><li>continuous states and their ContinuousStateDerivatives, ClockedStates, EventIndicators or InitialUnknowns. These variables are listed in the &lt;fmiModelDescription&gt;&lt;ModelStructure&gt;.</li><li>internal, intermediate variables or local clocks which can be read for debugging purposes and are not listed in the &lt;fmiModelDescription&gt;&lt;ModelStructure&gt;.</li></ul><p>Setting of local variables:</p><ul><li>In Initialization Mode and before, local variables need to be set if they do have start values or are listed as &lt;InitialUnknown&gt;.</li><li>In super state Initialized, fmi3Set{VariableType} must not be called on any of the local variables. Only in Model Exchange, continuous states can be set with fmi3SetContinuousStates. Local variable values must not be used as input to another model or FMU.</li></ul><p>independent - The independent variable (usually time [but could also be, for example, angle]). All variables are a function of this independent variable. variability must be continuous. Exactly one variable of an FMU must be defined as independent.  For Model Exchange the value is the last value set by fmi3SetTime. For Co-Simulation the value of the independent variable is lastSuccessfulTime return by the last call to fmi3DoStep or the value of argument intermediateUpdateTime of fmi3CallbackIntermediateUpdate. For Scheduled Execution the value of the independent variable is not defined. [The main purpose of this variable in Scheduled Execution is to define a quantity and unit for the independent variable.] The initial value of the independent variable is the value of the argument startTime of fmi3EnterInitializationMode for both Co-Simulation and Model Exchange.  If the unit for the independent variable is not defined, it is implicitly s (seconds). If one variable is defined as independent, it must be defined with a floating point type without a start attribute. It is not allowed to call function fmi3Set{VariableType} on an independent variable. Instead, its value is initialized with fmi3EnterInitializationMode and after initialization set by fmi3SetTime for Model Exchange and by arguments currentCommunicationPoint and communicationStepSize of fmi3DoStep for Co-Simulation FMUs. [The actual value can be inquired with fmi3Get{VariableType}.]</p><p>structuralParameter - The variable value can only be changed in Configuration Mode or Reconfiguration Mode. The variability attribute must be fixed or tunable. The initial attribute must be exact or not present (meaning exact). The start attribute is mandatory. A structural parameter must not have a &lt;Dimension&gt; element. A structural parameter may be referenced in &lt;Dimension&gt; elements. If a structural parameters is referenced in &lt;Dimension&gt; elements, it must be of type &lt;UInt64&gt; and its start attribute must be larger than 0. The min attribute might still be 0.</p><p>The default of causality is local. A continuous-time state or an event indicator must have causality = local or output, see also Section 2.4.8.</p><p>[causality = calculatedParameter and causality = local with variability = fixed or tunable are similar. The difference is that a calculatedParameter can be used in another model or FMU, whereas a local variable cannot. For example, when importing an FMU in a Modelica environment, a calculatedParameter should be imported in a public section as final parameter, whereas a local variable should be imported in a protected section of the model.]</p><p>The causality of variables of type Clock must be either input or output.</p><p>Added prefix &quot;fmi3&quot; to help with redefinition of constans in enums.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/cconst.jl#L71-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StringToCausality" href="#FMICore.fmi3StringToCausality"><code>FMICore.fmi3StringToCausality</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3StringToCausality(s::AbstractString)</code></pre><p>Convert <code>s</code> (&quot;parameter&quot;, &quot;calculatedParameter&quot;, &quot;structuralParameter&quot;, &quot;input&quot;, &quot;output&quot;, &quot;local&quot;, &quot;independent&quot;) to the corresponding <a href="#FMICore.fmi3Causality"><code>fmi3Causality</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3CausalityToString" href="#FMICore.fmi3CausalityToString"><code>FMICore.fmi3CausalityToString</code></a> — <span class="docstring-category">Function</span></header><section><div><p>ToDo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L51-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3InitialToString" href="#FMICore.fmi3InitialToString"><code>FMICore.fmi3InitialToString</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3InitialToString(c::fmi3Initial)</code></pre><p>Convert <a href="#FMICore.fmi3Initial"><code>fmi3Initial</code></a> <code>c</code> to the corresponding String (&quot;approx&quot;, &quot;exact&quot;, &quot;calculated&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StringToInitial" href="#FMICore.fmi3StringToInitial"><code>FMICore.fmi3StringToInitial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3StringToInitial(s::AbstractString)</code></pre><p>Convert <code>s</code> (&quot;approx&quot;, &quot;exact&quot;, &quot;calculated&quot;) to the corresponding <a href="#FMICore.fmi3Initial"><code>fmi3Initial</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L163-L167">source</a></section></article><h3 id="External/Additional-functions"><a class="docs-heading-anchor" href="#External/Additional-functions">External/Additional functions</a><a id="External/Additional-functions-1"></a><a class="docs-heading-anchor-permalink" href="#External/Additional-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetJacobian" href="#FMIImport.fmi3GetJacobian"><code>FMIImport.fmi3GetJacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetJacobian(inst::FMU3Instance,
    rdx::AbstractArray{fmi3ValueReference},
    rx::AbstractArray{fmi3ValueReference};
    steps::Union{AbstractArray{fmi3Float64}, Nothing} = nothing)</code></pre><p>Builds the jacobian over the FMU <code>fmu</code> for FMU value references <code>rdx</code> and <code>rx</code>, so that the function returns the jacobian ∂rdx / ∂rx.</p><p>If FMI built-in directional derivatives are supported, they are used. As fallback, directional derivatives will be sampled with central differences. For optimization, if the FMU&#39;s model description has the optional entry &#39;dependencies&#39;, only dependent variables are sampled/retrieved. This drastically boosts performance for systems with large variable count (like CFD).</p><p><strong>Arguments</strong></p><ul><li><code>inst::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>rdx::AbstractArray{fmi3ValueReference}</code>: Argument <code>rdx</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model.</li><li><code>rx::AbstractArray{fmi3ValueReference}</code>: Argument <code>rx</code> contains values of type <code>fmi3ValueReference</code> which are identifiers of a variable value of the model.</li></ul><p><strong>Keywords</strong></p><ul><li><code>steps::Union{AbstractArray{fmi3Float64}, Nothing} = nothing)</code>: If sampling is used, sampling step size can be set (for each direction individually) using optional argument <code>steps</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>mat::Array{fmi3Float64}</code>: Return <code>mat</code> contains the jacobian ∂rdx / ∂rx.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.4.7 Model Variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L863-L890">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetJacobian(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetJacobian(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L747-L752">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetJacobian!" href="#FMIImport.fmi3GetJacobian!"><code>FMIImport.fmi3GetJacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function fmi3GetJacobian!(jac::AbstractMatrix{fmi3Float64},
    comp::FMU3Instance,
    rdx::AbstractArray{fmi3ValueReference},
    rx::AbstractArray{fmi3ValueReference};
    steps::Union{AbstractArray{fmi3Float64}, Nothing} = nothing)</code></pre><p>Fills the jacobian over the FMU <code>fmu</code> for FMU value references <code>rdx</code> and <code>rx</code>, so that the function stores the jacobian ∂rdx / ∂rx in an AbstractMatrix <code>jac</code>.</p><p>If FMI built-in directional derivatives are supported, they are used. As fallback, directional derivatives will be sampled with central differences. For optimization, if the FMU&#39;s model description has the optional entry &#39;dependencies&#39;, only dependent variables are sampled/retrieved. This drastically boosts performance for systems with large variable count (like CFD).</p><p><strong>Arguments</strong></p><ul><li><code>jac::AbstractMatrix{fmi3Float64}</code>: Stores the the jacobian ∂rdx / ∂rx.</li><li><code>inst::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>rdx::AbstractArray{fmi3ValueReference}</code>: Argument <code>rdx</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model.</li><li><code>rx::AbstractArray{fmi3ValueReference}</code>: Argument <code>rx</code> contains values of type <code>fmi3ValueReference</code> which are identifiers of a variable value of the model.</li></ul><p><strong>Keywords</strong></p><ul><li><code>steps::Union{AbstractArray{fmi3Float64}, Nothing} = nothing)</code>: If sampling is used, sampling step size can be set (for each direction individually) using optional argument <code>steps</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.4.7 Model Variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L900-L929">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetJacobian!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetJacobian!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L736-L741">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetFullJacobian" href="#FMIImport.fmi3GetFullJacobian"><code>FMIImport.fmi3GetFullJacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetFullJacobian(inst::FMU3Instance,
    rdx::AbstractArray{fmi3ValueReference},
    rx::AbstractArray{fmi3ValueReference};
    steps::Union{AbstractArray{fmi3Float64}, Nothing} = nothing)</code></pre><p>Builds the jacobian over the FMU <code>fmu</code> for FMU value references <code>rdx</code> and <code>rx</code>, so that the function returns the jacobian ∂rdx / ∂rx.</p><p>If FMI built-in directional derivatives are supported, they are used. As fallback, directional derivatives will be sampled with central differences. No performance optimization, for an optimized version use <code>fmi3GetJacobian</code>.</p><p><strong>Arguments</strong></p><ul><li><code>inst::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>rdx::AbstractArray{fmi3ValueReference}</code>: Argument <code>rdx</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model.</li><li><code>rx::AbstractArray{fmi3ValueReference}</code>: Argument <code>rx</code> contains values of type <code>fmi3ValueReference</code> which are identifiers of a variable value of the model.</li></ul><p><strong>Keywords</strong></p><ul><li><code>steps::Union{AbstractArray{fmi3Float64}, Nothing} = nothing)</code>: If sampling is used, sampling step size can be set (for each direction individually) using optional argument <code>steps</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>mat::Array{fmi3Float64}</code>: Return <code>mat</code> contains the jacobian ∂rdx / ∂rx.</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.4.7 Model Variables</li></ul><p>See also <a href="#FMIImport.fmi3GetFullJacobian!"><code>fmi3GetFullJacobian!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L983-L1013">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetFullJacobian!" href="#FMIImport.fmi3GetFullJacobian!"><code>FMIImport.fmi3GetFullJacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetFullJacobian!(jac::Matrix{fmi3Float64},
    inst::FMU3Instance,
    rdx::AbstractArray{fmi3ValueReference},
    rx::AbstractArray{fmi3ValueReference};
    steps::Union{AbstractArray{fmi3Float64}, Nothing} = nothing)</code></pre><p>Fills the jacobian over the FMU <code>fmu</code> for FMU value references <code>rdx</code> and <code>rx</code>, so that the function returns the jacobian ∂rdx / ∂rx.</p><p>If FMI built-in directional derivatives are supported, they are used. As fallback, directional derivatives will be sampled with central differences. No performance optimization, for an optimized version use <code>fmi3GetJacobian</code>.</p><p><strong>Arguments</strong></p><ul><li><code>jac::AbstractMatrix{fmi3Float64}</code>: Stores the the jacobian ∂rdx / ∂rx.</li><li><code>inst::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>rdx::AbstractArray{fmi3ValueReference}</code>: Argument <code>rdx</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model.</li><li><code>rx::AbstractArray{fmi3ValueReference}</code>: Argument <code>rx</code> contains values of type <code>fmi3ValueReference</code> which are identifiers of a variable value of the model.</li></ul><p><strong>Keywords</strong></p><ul><li><code>steps::Union{AbstractArray{fmi3Float64}, Nothing} = nothing)</code>: If sampling is used, sampling step size can be set (for each direction individually) using optional argument <code>steps</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L1023-L1049">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3GetStartValue" href="#FMIImport.fmi3GetStartValue"><code>FMIImport.fmi3GetStartValue</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetStartValue(md::fmi3ModelDescription, vrs::fmi3ValueReferenceFormat = md.valueReferences)</code></pre><p>Returns the start/default value for a given value reference.</p><p><strong>Arguments</strong></p><ul><li><code>md::fmi3ModelDescription</code>: Struct which provides the static information of ModelVariables.</li><li><code>vrs::fmi3ValueReferenceFormat = md.valueReferences</code>: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li>first optional function: <code>starts::Array{fmi3ValueReferenceFormat}</code>: start/default value for a given value reference</li><li>second optional function:<code>starts::fmi3ValueReferenceFormat</code>: start/default value for a given value reference</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.4.7 Model Variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L1288-L1306">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetStartValue(fmu::FMU3, vrs::fmi3ValueReferenceFormat = fmu.modelDescription.valueReferences)</code></pre><p>Returns the start/default value for a given value reference.</p><p><strong>Arguments</strong></p><ul><li><code>fmu::FMU3</code>: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.</li><li><code>vrs::fmi3ValueReferenceFormat = md.valueReferences</code>: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li>first optional function: <code>starts::Array{fmi3ValueReferenceFormat}</code>: start/default value for a given value reference</li><li>second optional function:<code>starts::fmi3ValueReferenceFormat</code>: start/default value for a given value reference</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.4.7 Model Variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L1330-L1348">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetStartValue(c::FMU3Instance, vrs::fmi3ValueReferenceFormat = c.fmu.modelDescription.valueReferences)</code></pre><p>Returns the start/default value for a given value reference.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vrs::fmi3ValueReferenceFormat = md.valueReferences</code>: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)</li></ul><p>More detailed: <code>fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}</code></p><p><strong>Returns</strong></p><ul><li>first optional function: <code>starts::Array{fmi3ValueReferenceFormat}</code>: start/default value for a given value reference</li><li>second optional function:<code>starts::fmi3ValueReferenceFormat</code>: start/default value for a given value reference</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.4.7 Model Variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L1353-L1371">source</a></section><section><div><pre><code class="language-julia hljs">fmi3GetStartValue(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3GetStartValue(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L968-L973">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetNumberOfVariableDependencies!" href="#FMICore.fmi3GetNumberOfVariableDependencies!"><code>FMICore.fmi3GetNumberOfVariableDependencies!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetNumberOfVariableDependencies!(c::FMU3Instance, vr::fmi3ValueReference, nvr::Ref{Csize_t})</code></pre><p>The number of dependencies of a given variable, which may change if structural parameters are changed, can be retrieved by calling fmi3GetNumberOfVariableDependencies.</p><p>This information can only be retrieved if the &#39;providesPerElementDependencies&#39; tag in the ModelDescription is set.</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReference</code>: Argument <code>vr</code> is the value handel called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.10. Dependencies of Variables</li></ul><p>See also <a href="#FMICore.fmi3GetNumberOfVariableDependencies!"><code>fmi3GetNumberOfVariableDependencies!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L1966-L1993">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3GetVariableDependencies!" href="#FMICore.fmi3GetVariableDependencies!"><code>FMICore.fmi3GetVariableDependencies!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3GetVariableDependencies!(c::FMU3Instance, vr::fmi3ValueReference, elementIndiceOfDependents::AbstractArray{Csize_t}, independents::AbstractArray{fmi3ValueReference},  
    elementIndiceOfInpendents::AbstractArray{Csize_t}, dependencyKind::AbstractArray{fmi3DependencyKind}, ndependencies::Csize_t)</code></pre><p>The actual dependencies (of type dependenciesKind) can be retrieved by calling the function fmi3GetVariableDependencies:</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Argument <code>c</code> is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vr::fmi3ValueReference</code>: Argument <code>vr</code> is the value handel called &quot;ValueReference&quot; that define the variable that shall be inquired.</li><li><code>nvr::Csize_t</code>: Argument <code>nvr</code> defines the size of <code>vr</code>.</li><li><code>elementIndiceOfDependents::AbstractArray{Csize_t}</code>: must point to a buffer of size_t values of size <code>nDependencies</code> allocated by the calling environment.    It is filled in by this function with the element index of the dependent variable that dependency information is provided for. The element indices start with 1. Using the element index 0 means all elements of the variable. (Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in Section 2.2.6.1.)</li><li><code>independents::AbstractArray{fmi3ValueReference}</code>:  must point to a buffer of <code>fmi3ValueReference</code> values of size <code>nDependencies</code> allocated by the calling environment.    It is filled in by this function with the value reference of the independent variable that this dependency entry is dependent upon.</li><li><code>elementIndiceOfInpendents::AbstractArray{Csize_t}</code>: must point to a buffer of size_t <code>values</code> of size <code>nDependencies</code> allocated by the calling environment.    It is filled in by this function with the element index of the independent variable that this dependency entry is dependent upon. The element indices start with 1. Using the element index 0 means all elements of the variable. (Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in Section 2.2.6.1.)</li><li><code>dependencyKind::AbstractArray{fmi3DependencyKind}</code>: must point to a buffer of dependenciesKind values of size <code>nDependencies</code> allocated by the calling environment.    It is filled in by this function with the enumeration value describing the dependency of this dependency entry.</li><li><code>ndependencies::Csize_t</code>: specifies the number of dependencies that the calling environment allocated space for in the result buffers, and should correspond to value obtained by calling <code>fmi3GetNumberOfVariableDependencies</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status::fmi3Status</code>: Return <code>status</code> is an enumeration of type <code>fmi3Status</code> and indicates the success of the function call.</li></ul><p>More detailed:</p><ul><li><code>fmi3OK</code>: all well</li><li><code>fmi3Warning</code>: things are not quite right, but the computation can continue</li><li><code>fmi3Discard</code>: if the slave computed successfully only a subinterval of the communication step</li><li><code>fmi3Error</code>: the communication step could not be carried out at all</li><li><code>fmi3Fatal</code>: if an error occurred which corrupted the FMU irreparably</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.2.3 Platform Dependent Definitions </li><li>FMISpec3.0: 2.2.4 Status Returned by Functions</li><li>FMISpec3.0: 2.2.10. Dependencies of Variables</li></ul><p>See also <a href="#FMICore.fmi3GetVariableDependencies!"><code>fmi3GetVariableDependencies!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/c.jl#L2001-L2037">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3SampleDirectionalDerivative" href="#FMIImport.fmi3SampleDirectionalDerivative"><code>FMIImport.fmi3SampleDirectionalDerivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SampleDirectionalDerivative(c::FMU3Instance,
vUnknown_ref::AbstractArray{fmi3ValueReference},
vKnown_ref::AbstractArray{fmi3ValueReference},
steps::Union{AbstractArray{fmi3Float64}, Nothing} = nothing)</code></pre><p>This function samples the directional derivative by manipulating corresponding values (central differences).</p><p>Computes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1). In every Mode, the general form of the FMU equations are: 𝐯<em>unknown = 𝐡(𝐯</em>known, 𝐯_rest)</p><ul><li><code>v_unknown</code>: vector of unknown Real variables computed in the actual Mode:</li><li>Initialization Mode: unkowns kisted under <code>&lt;ModelStructure&gt;&lt;InitialUnknown&gt;</code> that have type Real.</li><li>Continuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> and the variables listed as state derivatives under <code>&lt;ModelStructure&gt;&lt;Derivatives&gt;)</code>.</li><li>Event Mode (ModelExchange): The same variables as in the Continuous-Time Mode and additionally variables under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>discrete</code>.</li><li>Step Mode (CoSimulation):  The variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> or <code>discrete</code>. If <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;</code> is present, also the variables listed here as state derivatives.</li><li><code>v_known</code>: Real input variables of function h that changes its value in the actual Mode.</li><li><code>v_rest</code>:Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes</li></ul><p>Computes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:</p><p>Δv<em>unknown = (δh / δv</em>known) Δv_known</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vUnknown_ref::AbstractArray{fmi3ValueReference}</code>: Argument <code>vUnknown_ref</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model. <code>vUnknown_ref</code> can be equated with <code>v_unknown</code>(variable described above).</li><li><code>vKnown_ref::AbstractArray{fmi3ValueReference}</code>: Argument <code>vKnown_ref</code> contains values of type <code>fmi3ValueReference</code> which are identifiers of a variable value of the model.<code>vKnown_ref</code> can be equated with <code>v_known</code>(variable described above).</li><li><code>steps::Union{AbstractArray{fmi3Float64}, Nothing} = nothing)</code>: If sampling is used, sampling step size can be set (for each direction individually) using optional argument <code>steps</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>dvUnkonwn::Array{fmi3Float64}</code>: Argument <code>vUnknown_ref</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model. <code>vUnknown_ref</code> can be equated with <code>v_unknown</code>(see function fmi3GetDirectionalDerivative!).</li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.4.7  Model Variables</li></ul><p>See also <a href="#FMICore.fmi3GetDirectionalDerivative!"><code>fmi3GetDirectionalDerivative!</code></a> ,<a href="#FMIImport.fmi3GetDirectionalDerivative"><code>fmi3GetDirectionalDerivative</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L739-L776">source</a></section><section><div><pre><code class="language-julia hljs">function fmi3SampleDirectionalDerivative(c::FMU3Instance,
    vUnknown_ref::Array{fmi3ValueReference},
    vKnown_ref::Array{fmi3ValueReference},
    steps::Array{fmi3Float64} = ones(fmi3Float64, length(vKnown_ref)).*1e-5)</code></pre><p>Wrapper for <a href="#FMIImport.fmi3SampleDirectionalDerivative!"><code>fmi3SampleDirectionalDerivative!</code></a> with <code>dvUnknown</code> initialized with zeros</p><p>Returning dvUnknown, modified by <code>fmi3SampleDirectionalDerivative!</code> call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L1428-L1437">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SampleDirectionalDerivative(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SampleDirectionalDerivative(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L725-L730">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMIImport.fmi3SampleDirectionalDerivative!" href="#FMIImport.fmi3SampleDirectionalDerivative!"><code>FMIImport.fmi3SampleDirectionalDerivative!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3SampleDirectionalDerivative!(c::FMU3Instance,
vUnknown_ref::AbstractArray{fmi3ValueReference},
vKnown_ref::AbstractArray{fmi3ValueReference},
steps::Union{AbstractArray{fmi3Float64}, Nothing} = nothing)</code></pre><p>This function samples the directional derivative by manipulating corresponding values (central differences).</p><p>Computes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1). In every Mode, the general form of the FMU equations are: 𝐯<em>unknown = 𝐡(𝐯</em>known, 𝐯_rest)</p><ul><li><code>v_unknown</code>: vector of unknown Real variables computed in the actual Mode:</li><li>Initialization Mode: unkowns kisted under <code>&lt;ModelStructure&gt;&lt;InitialUnknown&gt;</code> that have type Real.</li><li>Continuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> and the variables listed as state derivatives under <code>&lt;ModelStructure&gt;&lt;Derivatives&gt;)</code>.</li><li>Event Mode (ModelExchange): The same variables as in the Continuous-Time Mode and additionally variables under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>discrete</code>.</li><li>Step Mode (CoSimulation):  The variables listed under <code>&lt;ModelStructure&gt;&lt;Output&gt;</code> with type Real and variability = <code>continuous</code> or <code>discrete</code>. If <code>&lt;ModelStructure&gt;&lt;ContinuousStateDerivative&gt;</code> is present, also the variables listed here as state derivatives.</li><li><code>v_known</code>: Real input variables of function h that changes its value in the actual Mode.</li><li><code>v_rest</code>:Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes</li></ul><p>Computes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:</p><p>Δv<em>unknown = (δh / δv</em>known) Δv_known</p><p><strong>Arguments</strong></p><ul><li><code>c::FMU3Instance</code>: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.</li><li><code>vUnknown_ref::AbstractArray{fmi3ValueReference}</code>: Argument <code>vUnknown_ref</code> contains values of type<code>fmi3ValueReference</code> which are identifiers of a variable value of the model. <code>vUnknown_ref</code> can be equated with <code>v_unknown</code>(variable described above).</li><li><code>vKnown_ref::AbstractArray{fmi3ValueReference}</code>: Argument <code>vKnown_ref</code> contains values of type <code>fmi3ValueReference</code> which are identifiers of a variable value of the model.<code>vKnown_ref</code> can be equated with <code>v_known</code>(variable described above).</li><li><code>steps::Union{AbstractArray{fmi3Float64}, Nothing} = nothing)</code>: If sampling is used, sampling step size can be set (for each direction individually) using optional argument <code>steps</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Source</strong></p><ul><li>FMISpec3.0 Link: <a href="https://fmi-standard.org/">https://fmi-standard.org/</a></li><li>FMISpec3.0: 2.4.7  Model Variables</li></ul><p>See also <a href="#FMICore.fmi3GetDirectionalDerivative!"><code>fmi3GetDirectionalDerivative!</code></a> ,<a href="#FMIImport.fmi3GetDirectionalDerivative"><code>fmi3GetDirectionalDerivative</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMIImport.jl/blob/v0.16.3/src/FMI3/ext.jl#L790-L827">source</a></section><section><div><pre><code class="language-julia hljs">fmi3SampleDirectionalDerivative!(fmu::FMU3, args...; kwargs...)</code></pre><p>Wrapper for <code>fmi3SampleDirectionalDerivative!(c::FMU3Instance, args...; kwargs...)</code> without a provided FMU3Instance. (Instance <code>c</code> gets selected from <code>fmu</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMI.jl/blob/9e96d6850b8a15ddd605e66da1dcde0cddc5e0cb/src/FMI3/comp_wraps.jl#L714-L719">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3StringToType" href="#FMICore.fmi3StringToType"><code>FMICore.fmi3StringToType</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3StringToType(s::AbstractString)</code></pre><p>Convert <code>s</code> (&quot;coSimulation&quot;, &quot;modelExchange&quot;, &quot;scheduledExecution&quot;) to the corresponding <a href="#FMICore.fmi3Type"><code>fmi3Type</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L279-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FMICore.fmi3TypeToString" href="#FMICore.fmi3TypeToString"><code>FMICore.fmi3TypeToString</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmi3TypeToString(c::fmi3Type)</code></pre><p>Convert <a href="#FMICore.fmi3Type"><code>fmi3Type</code></a> <code>c</code> to the corresponding String (&quot;coSimulation&quot;, &quot;modelExchange&quot;, &quot;scheduledExecution&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ThummeTo/FMICore.jl/blob/v0.19.1/src/FMI3/convert.jl#L261-L265">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fmi2_lowlevel_librarys/">« FMI2 specific content</a><a class="docs-footer-nextpage" href="../index_library/">API Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Tuesday 21 November 2023 15:35">Tuesday 21 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
