var documenterSearchIndex = {"docs":
[{"location":"examples/multiprocessing/#Multiprocessing","page":"Multiprocessing","title":"Multiprocessing","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Tutorial by Jonas Wilfert, Tobias Thummerer","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"üöß This tutorial is under revision and will be replaced by an up-to-date version soon üöß","category":"page"},{"location":"examples/multiprocessing/#License","page":"Multiprocessing","title":"License","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar, Jonas Wilfert\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/multiprocessing/#Motivation","page":"Multiprocessing","title":"Motivation","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/multiprocessing/#Introduction-to-the-example","page":"Multiprocessing","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"This example shows how to parallelize the computation of an FMU in FMI.jl. We can compute a batch of FMU-evaluations in parallel with different initial settings. Parallelization can be achieved using multithreading or using multiprocessing. This example shows multiprocessing, check multithreading.ipynb for multithreading. Advantage of multithreading is a lower communication overhead as well as lower RAM usage. However in some cases multiprocessing can be faster as the garbage collector is not shared.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"The model used is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"(Image: svg)  ","category":"page"},{"location":"examples/multiprocessing/#Target-group","page":"Multiprocessing","title":"Target group","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/multiprocessing/#Other-formats","page":"Multiprocessing","title":"Other formats","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/multiprocessing/#Getting-started","page":"Multiprocessing","title":"Getting started","text":"","category":"section"},{"location":"examples/multiprocessing/#Installation-prerequisites","page":"Multiprocessing","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install FMICore via add FMICore add \" https://github.com/ThummeTo/FMICore.jl \"\n5. Install BenchmarkTools via add BenchmarkTools ","category":"page"},{"location":"examples/multiprocessing/#Code-section","page":"Multiprocessing","title":"Code section","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Adding your desired amount of processes:","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"using Distributed\nn_procs = 2\naddprocs(n_procs; exeflags=`--project=$(Base.active_project()) --threads=auto`, restrict=false)","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"# imports\n@everywhere using FMI\n@everywhere using FMIZoo\n@everywhere using BenchmarkTools","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Checking that we workers have been correctly initialized:","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"workers()\n\n@everywhere println(\"Hello World!\")\n\n# The following lines can be uncommented for more advanced informations about the subprocesses\n# @everywhere println(pwd())\n# @everywhere println(Base.active_project())\n# @everywhere println(gethostname())\n# @everywhere println(VERSION)\n# @everywhere println(Threads.nthreads())","category":"page"},{"location":"examples/multiprocessing/#Simulation-setup","page":"Multiprocessing","title":"Simulation setup","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Next, the batch size and input values are defined.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"\n# Best if batchSize is a multiple of the threads/cores\nbatchSize = 16\n\n# Define an array of arrays randomly\ninput_values = collect(collect.(eachrow(rand(batchSize,2))))","category":"page"},{"location":"examples/multiprocessing/#Shared-Module","page":"Multiprocessing","title":"Shared Module","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"For Distributed we need to embed the FMU into its own module. This prevents Distributed from trying to serialize and send the FMU over the network, as this can cause issues. This module needs to be made available on all processes using @everywhere.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@everywhere module SharedModule\n    using FMIZoo\n    using FMI\n\n    t_start = 0.0\n    t_step = 0.1\n    t_stop = 10.0\n    tspan = (t_start, t_stop)\n    tData = collect(t_start:t_step:t_stop)\n\n    model_fmu = FMIZoo.fmiLoad(\"SpringPendulum1D\", \"Dymola\", \"2022x\")\nend","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"We define a helper function to calculate the FMU and combine it into an Matrix.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@everywhere function runCalcFormatted(fmu, x0, recordValues=[\"mass.s\", \"mass.v\"])\n    data = fmiSimulateME(fmu, SharedModule.tspan; recordValues=recordValues, saveat=SharedModule.tData, x0=x0, showProgress=false, dtmax=1e-4)\n    return reduce(hcat, data.states.u)\nend","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Running a single evaluation is pretty quick, therefore the speed can be better tested with BenchmarkTools.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@benchmark data = runCalcFormatted(SharedModule.model_fmu, rand(2))","category":"page"},{"location":"examples/multiprocessing/#Single-Threaded-Batch-Execution","page":"Multiprocessing","title":"Single Threaded Batch Execution","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"To compute a batch we can collect multiple evaluations. In a single threaded context we can use the same FMU for every call.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"println(\"Single Threaded\")\n@benchmark collect(runCalcFormatted(SharedModule.model_fmu, i) for i in input_values)","category":"page"},{"location":"examples/multiprocessing/#Multithreaded-Batch-Execution","page":"Multiprocessing","title":"Multithreaded Batch Execution","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"In a multithreaded context we have to provide each thread it's own fmu, as they are not thread safe. To spread the execution of a function to multiple processes, the function pmap can be used.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"println(\"Multi Threaded\")\n@benchmark pmap(i -> runCalcFormatted(SharedModule.model_fmu, i), input_values)","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"As you can see, there is a significant speed-up in the median execution time. But: The speed-up is often much smaller than n_procs (or the number of physical cores of your CPU), this has different reasons. For a rule of thumb, the speed-up should be around n/2 on a n-core-processor with n Julia processes.","category":"page"},{"location":"examples/multiprocessing/#Unload-FMU","page":"Multiprocessing","title":"Unload FMU","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"After calculating the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@everywhere fmiUnload(SharedModule.model_fmu)","category":"page"},{"location":"examples/multiprocessing/#Summary","page":"Multiprocessing","title":"Summary","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"In this tutorial it is shown how multi processing with Distributed.jl can be used to improve the performance for calculating a Batch of FMUs.","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#Working-with-the-FMI-model-description","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"The FMI model description provides all human readable information on the model. The following functions can be used to obtain all information provided by the model description, which in turn can be extracted from the fmu.","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#Loading/Parsing","page":"Working with the FMI model description","title":"Loading/Parsing","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2LoadModelDescription","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#general-information-about-the-FMU","page":"Working with the FMI model description","title":"general information about the FMU","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2GetGenerationTool fmi2GetGenerationDateAndTime","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#technical-information-about-the-FMU","page":"Working with the FMI model description","title":"technical information about the FMU","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2GetVersion\nfmi2GetTypesPlatform\n","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMICore.fmi2GetVersion","page":"Working with the FMI model description","title":"FMICore.fmi2GetVersion","text":"Source: FMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\n\nReturns the version of the ‚Äúfmi2Functions.h‚Äù header file which was used to compile the functions of the FMU. The function returns ‚ÄúfmiVersion‚Äù which is defined in this header file. The standard header file as documented in this specification has version ‚Äú2.0‚Äù\n\n\n\n\n\nfmi2GetVersion(fmu::FMU2)\n\nReturns the version of the ‚Äúfmi2Functions.h‚Äù header file which was used to compile the functions of the FMU.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns a string from the address of a C-style (NUL-terminated) string. The string represents the version of the ‚Äúfmi2Functions.h‚Äù header file which was used to compile the functions of the FMU. The function returns ‚ÄúfmiVersion‚Äù which is defined in this header file. The standard header file as documented in this specification has version ‚Äú2.0‚Äù\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMICore.fmi2GetTypesPlatform","page":"Working with the FMI model description","title":"FMICore.fmi2GetTypesPlatform","text":"Source: FMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\n\nReturns the string to uniquely identify the ‚Äúfmi2TypesPlatform.h‚Äù header file used for compilation of the functions of the FMU. The standard header file, as documented in this specification, has fmi2TypesPlatform set to ‚Äúdefault‚Äù (so this function usually returns ‚Äúdefault‚Äù).\n\n\n\n\n\nfmi2GetTypesPlatform(fmu::FMU2)\n\nReturns the string to uniquely identify the ‚Äúfmi2TypesPlatform.h‚Äù header file used for compilation of the functions of the FMU. The standard header file, as documented in this specification, has fmi2TypesPlatform set to ‚Äúdefault‚Äù (so this function usually returns ‚Äúdefault‚Äù).\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns the string to uniquely identify the ‚Äúfmi2TypesPlatform.h‚Äù header file used for compilation of the functions of the FMU.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMU-capabilities","page":"Working with the FMI model description","title":"FMU capabilities","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"canGetSetFMUState\nisModelStructureAvailable\nisModelStructureDerivativesAvailable","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMIBase.canGetSetFMUState","page":"Working with the FMI model description","title":"FMIBase.canGetSetFMUState","text":"canGetSetFMUState(md::fmi2ModelDescription)\n\nReturns true, if the FMU supports the getting/setting of states\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU supports the getting/setting of states.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMIImport.isModelStructureAvailable","page":"Working with the FMI model description","title":"FMIImport.isModelStructureAvailable","text":"isModelStructureAvailable(md::fmi2ModelDescription)\n\nReturns true if the FMU model description contains dependency information.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU model description contains dependency information.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMIImport.isModelStructureDerivativesAvailable","page":"Working with the FMI model description","title":"FMIImport.isModelStructureDerivativesAvailable","text":"isModelStructureDerivativesAvailable(md::fmi2ModelDescription)\n\nReturns if the FMU model description contains dependency information for derivatives.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU model description contains dependency information for derivatives.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2DependenciesSupported fmi2DerivativeDependenciesSupported fmi2CanSerializeFMUstate fmi2ProvidesDirectionalDerivative","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#value-references","page":"Working with the FMI model description","title":"value references","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getModelVariableIndices","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMIBase.getModelVariableIndices","page":"Working with the FMI model description","title":"FMIBase.getModelVariableIndices","text":"getModelVariableIndices(md::fmi2ModelDescription; vrs=md.valueReferences)\n\nReturns a array of indices corresponding to value references vrs\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.valueReferences: Additional attribute valueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\n\nReturns\n\nnames::Array{Integer}: Returns a array of indices corresponding to value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2GetValueReferencesAndNames fmi2GetNames","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#In-/Outputs","page":"Working with the FMI model description","title":"In-/Outputs","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2GetOutputValueReferencesAndNames","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"Depth = 2","category":"page"},{"location":"fmi3_lowlevel_SE_functions/#FMI-for-Scheduled-Execution","page":"FMI for Scheduled Execution","title":"FMI for Scheduled Execution","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/#Working-with-the-FMI-model-description","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"The FMI model description provides all human readable information on the model. The following functions can be used to obtain all information provided by the model description, which in turn can be extracted from the fmu.","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#Loading/Parsing","page":"Working with the FMI model description","title":"Loading/Parsing","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2LoadModelDescription","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#general-information-about-the-FMU","page":"Working with the FMI model description","title":"general information about the FMU","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getGUID\ngetInstantiationToken\ngetGenerationDateAndTime\ngetGenerationTool","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIImport.getGUID","page":"Working with the FMI model description","title":"FMIImport.getGUID","text":"getGUID(md::fmi2ModelDescription)\n\nReturns the tag 'guid' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nguid::String: Returns the tag 'guid' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getInstantiationToken","page":"Working with the FMI model description","title":"FMIBase.getInstantiationToken","text":"Returns the tag 'instantionToken' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getGenerationDateAndTime","page":"Working with the FMI model description","title":"FMIBase.getGenerationDateAndTime","text":"getGenerationDateAndTime(md::fmi2ModelDescription)\n\nReturns the tag 'generationdateandtime' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.generationDateAndTime::DateTime: Returns the tag 'generationdateandtime' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getGenerationTool","page":"Working with the FMI model description","title":"FMIBase.getGenerationTool","text":"getGenerationTool(md::fmi2ModelDescription)\n\nReturns the tag 'generationtool' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.generationTool::Union{String, Nothing}: Returns the tag 'generationtool' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#technical-information-about-the-FMU","page":"Working with the FMI model description","title":"technical information about the FMU","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getNumberOfEventIndicators\ngetModelIdentifier\ngetVariableNamingConvention","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getNumberOfEventIndicators","page":"Working with the FMI model description","title":"FMIBase.getNumberOfEventIndicators","text":"getNumberOfEventIndicators(md::fmi2ModelDescription)\n\nReturns the tag 'numberOfEventIndicators' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.numberOfEventIndicators::Union{UInt, Nothing}: Returns the tag 'numberOfEventIndicators' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getModelIdentifier","page":"Working with the FMI model description","title":"FMIBase.getModelIdentifier","text":"getModelIdentifier(md::fmiModelDescription; type=nothing)\n\nReturns the tag 'modelIdentifier' from CS or ME section.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\ntype=nothing: Defines whether a Co-Simulation or Model Exchange is present. (default = nothing)\n\nReturns\n\nmd.modelExchange.modelIdentifier::String: Returns the tag modelIdentifier from ModelExchange section.\nmd.coSimulation.modelIdentifier::String: Returns the tag modelIdentifier from CoSimulation section.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getVariableNamingConvention","page":"Working with the FMI model description","title":"FMIBase.getVariableNamingConvention","text":"getVariableNamingConvention(md::fmi2ModelDescription)\n\nReturns the tag 'varaiblenamingconvention' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.variableNamingConvention::Union{fmi2VariableNamingConvention, Nothing}: Returns the tag 'variableNamingConvention' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2GetVersion fmi2GetTypesPlatform","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#default-experiment-settings","page":"Working with the FMI model description","title":"default experiment settings","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getDefaultStartTime\ngetDefaultStepSize\ngetDefaultStopTime\ngetDefaultTolerance","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getDefaultStartTime","page":"Working with the FMI model description","title":"FMIBase.getDefaultStartTime","text":"getDefaultStartTime(md::fmi2ModelDescription)\n\nReturns startTime from DefaultExperiment if defined else defaults to nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.defaultExperiment.startTime::Union{Real,Nothing}: Returns a real value startTime from the DefaultExperiment if defined else defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getDefaultStepSize","page":"Working with the FMI model description","title":"FMIBase.getDefaultStepSize","text":"getDefaultStepSize(md::fmi2ModelDescription)\n\nReturns stepSize from DefaultExperiment if defined else defaults to nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.defaultExperiment.stepSize::Union{Real,Nothing}: Returns a real value setpSize from the DefaultExperiment if defined else defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getDefaultStopTime","page":"Working with the FMI model description","title":"FMIBase.getDefaultStopTime","text":"getDefaultStopTime(md::fmi2ModelDescription)\n\nReturns stopTime from DefaultExperiment if defined else defaults to nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.defaultExperiment.stopTime::Union{Real,Nothing}: Returns a real value stopTime from the DefaultExperiment if defined else defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getDefaultTolerance","page":"Working with the FMI model description","title":"FMIBase.getDefaultTolerance","text":"getDefaultTolerance(md::fmi2ModelDescription)\n\nReturns tolerance from DefaultExperiment if defined else defaults to nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.defaultExperiment.tolerance::Union{Real,Nothing}: Returns a real value tolerance from the DefaultExperiment if defined else defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMU-capabilities","page":"Working with the FMI model description","title":"FMU capabilities","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"canSerializeFMUState\nprovidesDirectionalDerivatives\nprovidesAdjointDerivatives","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.canSerializeFMUState","page":"Working with the FMI model description","title":"FMIBase.canSerializeFMUState","text":"canSerializeFMUState(md::fmi2ModelDescription)\n\nReturns true, if the FMU state can be serialized\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU state can be serialized\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.providesDirectionalDerivatives","page":"Working with the FMI model description","title":"FMIBase.providesDirectionalDerivatives","text":"providesDirectionalDerivative(md::fmi2ModelDescription)\n\nReturns true, if the FMU provides directional derivatives\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU provides directional derivatives\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.providesAdjointDerivatives","page":"Working with the FMI model description","title":"FMIBase.providesAdjointDerivatives","text":"Returns true, if the FMU provides adjoint derivatives\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"canGetSetFMUState fmi2DependenciesSupported fmi2DerivativeDependenciesSupported fmi2ProvidesDirectionalDerivative","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#value-references","page":"Working with the FMI model description","title":"value references","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getValueReferencesAndNames\ngetNames\ndataTypeForValueReference\nprepareValueReference\nprepareValue","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getValueReferencesAndNames","page":"Working with the FMI model description","title":"FMIBase.getValueReferencesAndNames","text":"getValueReferencesAndNames(obj; vrs=md.valueReferences)\n\nwith:\n\nobj ‚àà (fmi2ModelDescription, FMU2)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of value references and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.valueReferences: Additional attribute valueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getNames","page":"Working with the FMI model description","title":"FMIBase.getNames","text":"getNames(md::fmi2ModelDescription; vrs=md.valueReferences, mode=:first)\n\nReturns a array of names corresponding to value references vrs.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.valueReferences: Additional attribute valueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.dataTypeForValueReference","page":"Working with the FMI model description","title":"FMIBase.dataTypeForValueReference","text":"dataTypeForValueReference(obj, vr::fmi2ValueReference)\n\nwhere:\n\nobj ‚àà (fmi2ModelDescription, FMU2)\n\nReturns the fmi2DataType (fmi2Real, fmi2Integer, fmi2Boolean, fmi2String) for a given value reference vr.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.prepareValueReference","page":"Working with the FMI model description","title":"FMIBase.prepareValueReference","text":"prepareValueReference(obj, vrs)\n\nwhere: \n\nobj ‚àà (fmi2ModelDescription, fmi3ModelDescription, FMU2, FMU3, FMU2Component, FMU3Instance) vrs ‚àà (fmi2ValueReference, AbstractVector{fmi2ValueReference},         fmi3ValueReference, AbstractVector{fmi3ValueReference},         String, AbstractVector{String},         Integer, AbstractVector{Integer},        :states, :derivatives, :inputs, :outputs, :all, :none,        Nothing)\n\nReceives one or an array of value references in an arbitrary format (see fmi2ValueReferenceFormat) and converts it into an Array{fmi2ValueReference} (if not already).\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.prepareValue","page":"Working with the FMI model description","title":"FMIBase.prepareValue","text":"prepareValue(value)\n\nPrepares a value for a FMI ccall (they only accept arrays). Technically, the value is packed into an array - if not already.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#In-/Outputs","page":"Working with the FMI model description","title":"In-/Outputs","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getInputNames\ngetInputValueReferencesAndNames\ngetInputNamesAndStarts\ngetOutputNames\ngetOutputValueReferencesAndNames","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getInputNames","page":"Working with the FMI model description","title":"FMIBase.getInputNames","text":"getInputNames(md::fmi2ModelDescription; vrs=md.inputvalueReferences, mode=:first)\n\nReturns names of inputs.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.inputvalueReferences: Additional attribute inputvalueReferences::Array{fmi2ValueReference} of the Model Description that is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getInputValueReferencesAndNames","page":"Working with the FMI model description","title":"FMIBase.getInputValueReferencesAndNames","text":"getInputValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dict with (vrs, names of inputs).\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of inputs)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getInputNamesAndStarts","page":"Working with the FMI model description","title":"FMIBase.getInputNamesAndStarts","text":"getInputNamesAndStarts(md::fmi2ModelDescription)\n\nReturns a dictionary of input variables with their starting values.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{String, Array{fmi2ValueReferenceFormat}}: Returns a dictionary that constructs a hash table with keys of type String and values of type fmi2ValueReferenceFormat. So returns a dict with ( md.modelVariables[i].name::String, starts:: Array{fmi2ValueReferenceFormat} ). (Creates a tuple (name, starts) for each i in inputIndices)\n\nSee also getStartValue.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getOutputNames","page":"Working with the FMI model description","title":"FMIBase.getOutputNames","text":"fmi2GetOutputNames(md::fmi2ModelDescription; vrs=md.outputvalueReferences, mode=:first)\n\nReturns names of outputs.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.outputvalueReferences: Additional attribute outputvalueReferences::Array{fmi2ValueReference} of the Model Description that is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.outputvalueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getOutputValueReferencesAndNames","page":"Working with the FMI model description","title":"FMIBase.getOutputValueReferencesAndNames","text":"getOutputValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of value references and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.outputvalueReferences: Additional attribute outputvalueReferences::Array{fmi2ValueReference} of the Model Description that is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.outputvalueReferences::Array{fmi2ValueReference})\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}.So returns a dict with (vrs, names of outputs)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#Parameters","page":"Working with the FMI model description","title":"Parameters","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getParameterValueReferencesAndNames\ngetParameterNames","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getParameterValueReferencesAndNames","page":"Working with the FMI model description","title":"FMIBase.getParameterValueReferencesAndNames","text":"getParameterValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of parameterValueReferences and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of parameters).\n\nSee also getValueReferencesAndNames.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getParameterNames","page":"Working with the FMI model description","title":"FMIBase.getParameterNames","text":"fmi2GetParameterNames(md::fmi2ModelDescription; vrs=md.parameterValueReferences, mode=:first)\n\nReturns names of parameters.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.parameterValueReferences: Additional attribute parameterValueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.parameterValueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to parameter value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#States","page":"Working with the FMI model description","title":"States","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getStateNames\ngetStateValueReferencesAndNames","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getStateNames","page":"Working with the FMI model description","title":"FMIBase.getStateNames","text":"fmi2GetStateNames(fmu::FMU2; vrs=md.stateValueReferences, mode=:first)\n\nReturns names of states.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.stateValueReferences: Additional attribute parameterValueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.stateValueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to parameter value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getStateValueReferencesAndNames","page":"Working with the FMI model description","title":"FMIBase.getStateValueReferencesAndNames","text":"fmi2GetStateValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of state value references and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of states)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#Derivatives","page":"Working with the FMI model description","title":"Derivatives","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getDerivateValueReferencesAndNames\ngetDerivativeNames","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getDerivateValueReferencesAndNames","page":"Working with the FMI model description","title":"FMIBase.getDerivateValueReferencesAndNames","text":"fmi2GetDerivateValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of derivative value references and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of derivatives)\n\nSee also getValueReferencesAndNames\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getDerivativeNames","page":"Working with the FMI model description","title":"FMIBase.getDerivativeNames","text":"fmi2GetDerivativeNames(md::fmi2ModelDescription; vrs=md.derivativeValueReferences, mode=:first)\n\nReturns names of derivatives.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.derivativeValueReferences: Additional attribute derivativeValueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.derivativeValueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to parameter value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#Variables","page":"Working with the FMI model description","title":"Variables","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getNamesAndInitials\ngetNamesAndDescriptions\ngetNamesAndUnits","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getNamesAndInitials","page":"Working with the FMI model description","title":"FMIBase.getNamesAndInitials","text":"getNamesAndInitials(md::fmi2ModelDescription)\n\nReturns a dictionary of variables with their initials.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{String, Cuint}: Returns a dictionary that constructs a hash table with keys of type String and values of type Cuint. So returns a dict with ( md.modelVariables[i].name::String, md.modelVariables[i].inital::Union{fmi2Initial, Nothing}). (Creates a tuple (name,initial) for each i in 1:length(md.modelVariables))\n\nSee also getInitial.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getNamesAndDescriptions","page":"Working with the FMI model description","title":"FMIBase.getNamesAndDescriptions","text":"getNamesAndDescriptions(md::fmi2ModelDescription)\n\nReturns a dictionary of variables with their descriptions.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{String, String}: Returns a dictionary that constructs a hash table with keys of type String and values of type String. So returns a dict with ( md.modelVariables[i].name::String, md.modelVariables[i].description::Union{String, Nothing}). (Creates a tuple (name, description) for each i in 1:length(md.modelVariables))\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getNamesAndUnits","page":"Working with the FMI model description","title":"FMIBase.getNamesAndUnits","text":"getNamesAndUnits(md::fmi2ModelDescription)\n\nReturns a dictionary of variables with their units.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{String, String}: Returns a dictionary that constructs a hash table with keys of type String and values of type String. So returns a dict with ( md.modelVariables[i].name::String, md.modelVariables[i]._Real.unit::Union{String, Nothing}). (Creates a tuple (name, unit) for each i in 1:length(md.modelVariables))\n\nSee also getUnit.\n\n\n\n\n\n","category":"function"},{"location":"examples/workshops/","page":"Pluto Workshops","title":"Pluto Workshops","text":"Pluto based notebooks, that can easyly be executed on your own Pluto-Setup.","category":"page"},{"location":"examples/workshops/","page":"Pluto Workshops","title":"Pluto Workshops","text":"<iframe src=\"../pluto-src/index.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"fmi_lowlevel_library_constants/#Types-in-FMI-Import/Core-.jl","page":"Types in FMI Import/Core .jl","title":"Types in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi_lowlevel_library_constants/","page":"Types in FMI Import/Core .jl","title":"Types in FMI Import/Core .jl","text":"FMU\nFMUInstance\nFMUSolution\nFMUEvent\nFMUSnapshot\nFMUExecutionConfiguration\nFMULogLevel\nFMUInputFunction","category":"page"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMU","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMU","text":"FMU\n\nThe abstract type for FMUs (FMI 2 & 3).\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMUInstance","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMUInstance","text":"FMUInstance\n\nAn instance of a FMU. This was called component in FMI2, but was corrected to instance in FMI3.\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMUSolution","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMUSolution","text":"The mutable struct representing a specific Solution of a FMI2 FMU.\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMUEvent","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMUEvent","text":"Container for event related information.\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMUSnapshot","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMUSnapshot","text":"ToDo \n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMUExecutionConfiguration","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMUExecutionConfiguration","text":"A mutable struct representing the excution configuration of a FMU. For FMUs that have issues with calls like fmi2Reset or fmi2FreeInstance, this is pretty useful.\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMULogLevel","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMULogLevel","text":"Log levels for non-standard printing of infos, warnings and errors.\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMUInputFunction","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMUInputFunction","text":"FMUInputFunction(inputFunction, vrs)\n\nStruct container for inplace input functions for FMUs.\n\nArguments\n\ninputFunction: The input function (inplace) that gets called when new inputs are needed, must match one of the patterns described under Input function patterns.\nvrs::AbstractVector: A vector of value refernces to be set by the input function\n\nInput function patterns\n\nAvailable input patterns are [c: current component, u: current state ,t: current time, returning array of values to be passed to fmi2SetReal(..., inputValueReferences, inputFunction(...)) or fmi3SetFloat64]:\n\ninputFunction(t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, u::AbstractVector{<:Real})\ninputFunction(x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#Constants-in-FMI-Import/Core-.jl","page":"Types in FMI Import/Core .jl","title":"Constants in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi_lowlevel_library_constants/","page":"Types in FMI Import/Core .jl","title":"Types in FMI Import/Core .jl","text":"","category":"page"},{"location":"fmi2_lowlevel_CS_functions/#FMI-for-Co-Simulation","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"","category":"section"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"This chapter defines the Functional Mock-up Interface (FMI) for the coupling of two or more simulation models in a Co-Simulation environment (FMI for Co-Simulation). Co-Simulation is a rather general approach to the simulation of coupled technical systems and coupled physical phenomena in engineering with focus on instationary (time-dependent) problems.","category":"page"},{"location":"fmi2_lowlevel_CS_functions/#Transfer-of-Input-/-Output-Values-and-Parameters","page":"FMI for Co-Simulation","title":"Transfer of Input / Output Values and Parameters","text":"","category":"section"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"In order to enable the slave to interpolate the continuous real inputs between communication steps, the derivatives of the inputs with respect to time can be provided. Also, higher derivatives can be set to allow higher order interpolation.","category":"page"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"fmi2GetRealOutputDerivatives","category":"page"},{"location":"fmi2_lowlevel_CS_functions/#FMIImport.fmi2GetRealOutputDerivatives","page":"FMI for Co-Simulation","title":"FMIImport.fmi2GetRealOutputDerivatives","text":"fmi2GetRealOutputDerivatives(c::FMU2Component, vr::fmi2ValueReferenceFormat, order::AbstractArray{fmi2Integer})\n\nSets the n-th time derivative of real input variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\norder::Array{fmi2Integer}: Argument order is an array of fmi2Integer values witch specifys the corresponding order of derivative of the real input variable.\n\nReturns\n\nvalue::AbstactArray{fmi2Integer}: Return value is an array which represents a vector with the values of the derivatives.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#Computation","page":"FMI for Co-Simulation","title":"Computation","text":"","category":"section"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"The computation of time steps is controlled by the following function.","category":"page"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"fmi2DoStep\nfmi2CancelStep","category":"page"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2DoStep","page":"FMI for Co-Simulation","title":"FMICore.fmi2DoStep","text":"Source: FMISpec2.0.2[p.104]: 4.2.2 Computation\n\nThe computation of a time step is started.\n\n\n\n\n\nfmi2DoStep(c::FMU2Component, \n                currentCommunicationPoint::fmi2Real, \n                communicationStepSize::fmi2Real, \n                noSetFMUStatePriorToCurrentPoint::fmi2Boolean)\n\nThe computation of a time step is started.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ncurrentCommunicationPoint::fmi2Real:  Argument currentCommunicationPoint contains a value of type fmi2Real which is a identifier for a variable value . currentCommunicationPoint defines the current communication point of the master.\ncommunicationStepSize::fmi2Real: Argument communicationStepSize contains a value of type fmi2Real which is a identifier for a variable value. communicationStepSize defines the communiction step size.\n\nnoSetFMUStatePriorToCurrentPoint::Bool = true: Argument noSetFMUStatePriorToCurrentPoint contains a value of type Boolean. If no argument is passed the default value true is used. noSetFMUStatePriorToCurrentPoint indicates whether fmi2SetFMUState is no longer called for times before the currentCommunicationPoint in this simulation run Simulation run.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.2 Computation\n\nSee also fmi2DoStep.\n\n\n\n\n\nfmi2DoStep(c::FMU2Component, \n                communicationStepSize::Union{Real, Nothing} = nothing; \n                currentCommunicationPoint::Union{Real, Nothing} = nothing,\n                noSetFMUStatePriorToCurrentPoint::Bool = true)\n\nDoes one step in the CoSimulation FMU\n\nArguments\n\nC::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ncommunicationStepSize::Union{Real, Nothing} = nothing: Argument communicationStepSize contains a value of type Real or Nothing , if no argument is passed the default value nothing is used. communicationStepSize defines the communiction step size.\n\nKeywords\n\ncurrentCommunicationPoint::Union{Real, Nothing} = nothing: Argument currentCommunicationPoint contains a value of type Real or type Nothing. If no argument is passed the default value nothing is used. currentCommunicationPoint defines the current communication point of the master.\nnoSetFMUStatePriorToCurrentPoint::Bool = true: Argument noSetFMUStatePriorToCurrentPoint contains a value of type Boolean. If no argument is passed the default value true is used. noSetFMUStatePriorToCurrentPoint indicates whether fmi2SetFMUState is no longer called for times before the currentCommunicationPoint in this simulation run Simulation run.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.2 Computation\n\nSee also fmi2DoStep.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2CancelStep","page":"FMI for Co-Simulation","title":"FMICore.fmi2CancelStep","text":"Source: FMISpec2.0.2[p.105]: 4.2.2 Computation\n\nCan be called if fmi2DoStep returned fmi2Pending in order to stop the current asynchronous execution.\n\n\n\n\n\nfmi2CancelStep(c::FMU2Component)\n\nCan be called if fmi2DoStep returned fmi2Pending in order to stop the current asynchronous execution.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.2 Computation\n\nSee also fmi2DoStep.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#Retrieving-Status-Information-from-the-Slave","page":"FMI for Co-Simulation","title":"Retrieving Status Information from the Slave","text":"","category":"section"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"Status information is retrieved from the slave by the following functions:","category":"page"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"fmi2GetStatus\nfmi2GetStatus!\nfmi2GetRealStatus!\nfmi2GetIntegerStatus!\nfmi2GetBooleanStatus!\nfmi2GetStringStatus!","category":"page"},{"location":"fmi2_lowlevel_CS_functions/#FMIImport.fmi2GetStatus","page":"FMI for Co-Simulation","title":"FMIImport.fmi2GetStatus","text":"ToDo\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2GetStatus!","page":"FMI for Co-Simulation","title":"FMICore.fmi2GetStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetStatus!(c::FMU2Component, \n                    s::fmi2StatusKind, \n                    value::Ref{fmi2Status})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue::Ref{fmi2Status}: The value argument points to a status flag that was requested.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2GetRealStatus!","page":"FMI for Co-Simulation","title":"FMICore.fmi2GetRealStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetRealStatus!(c::FMU2Component, \n                        s::fmi2StatusKind, \n                        value::Ref{fmi2Real})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue::Ref{fmi2Real}: Argument value points to the return value (fmi2Real) which was requested. fmi2Real is a alias type for Real data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetRealStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2GetIntegerStatus!","page":"FMI for Co-Simulation","title":"FMICore.fmi2GetIntegerStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetIntegerStatus!(c::FMU2Component, \n                            s::fmi2StatusKind, \n                            value::Ref{fmi2Integer})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue::Ref{fmi2Integer}: Argument value points to the return value (fmi2Integer) which was requested. fmi2Integer is a alias type for Integer data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetIntegerStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2GetBooleanStatus!","page":"FMI for Co-Simulation","title":"FMICore.fmi2GetBooleanStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetBooleanStatus!(c::FMU2Component, \n                        s::fmi2StatusKind, \n                        value::Ref{fmi2Boolean})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue::Ref{fmi2Boolean}: Argument value points to the return value (fmi2Boolean) which was requested. fmi2Boolean is a alias type for Boolean data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetBooleanStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2GetStringStatus!","page":"FMI for Co-Simulation","title":"FMICore.fmi2GetStringStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetStringStatus!(c::FMU2Component, \n                        s::fmi2StatusKind, \n                        value::Ref{fmi2String})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue:Ref{fmi2String}: Argument value points to the return value (fmi2String) which was requested. fmi2String is a alias type for String data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetStringStatus!.\n\n\n\n\n\n","category":"function"},{"location":"examples/manipulation/#Manipulate-a-function","page":"Manipulation","title":"Manipulate a function","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Tutorial by Tobias Thummerer, Johannes Stoljar","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"üöß This tutorial is under revision and will be replaced by an up-to-date version soon üöß","category":"page"},{"location":"examples/manipulation/#License","page":"Manipulation","title":"License","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/manipulation/#Introduction-to-the-example","page":"Manipulation","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"This example shows how to overwrite a FMI function with a custom C-function. For this the FMU model is simulated first without changes. Then the function fmi2GetReal() is overwritten and simulated again. Both simulations are displayed in a graph to show the change caused by overwriting the function. The model used is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"(Image: svg)  ","category":"page"},{"location":"examples/manipulation/#Other-formats","page":"Manipulation","title":"Other formats","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/manipulation/#Code-section","page":"Manipulation","title":"Code section","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# imports\nusing FMI\nusing FMI: fmiSetFctGetReal\nusing FMIZoo\nusing FMICore\nusing Plots","category":"page"},{"location":"examples/manipulation/#Simulation-setup","page":"Manipulation","title":"Simulation setup","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Next, the start time and end time of the simulation are set.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"tStart = 0.0\ntStop = 8.0","category":"page"},{"location":"examples/manipulation/#Import-FMU","page":"Manipulation","title":"Import FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Next, the FMU model from FMIZoo.jl is loaded.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# we use an FMU from the FMIZoo.jl\nfmu = fmiLoad(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\"; type=:ME)","category":"page"},{"location":"examples/manipulation/#Simulate-FMU","page":"Manipulation","title":"Simulate FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In the next steps the recorded value is defined. The recorded value is the position of the mass. In the function fmiSimulateME() the FMU is simulated in model-exchange mode (ME) with an adaptive step size. In addition, the start and end time and the recorded variables are specified.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# an array of value references... or just one\nvrs = [\"mass.s\"]\n\nsimData = fmiSimulate(fmu, (tStart, tStop); recordValues=vrs)","category":"page"},{"location":"examples/manipulation/#Plotting-FMU","page":"Manipulation","title":"Plotting FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"After the simulation is finished, the result of the FMU for the model-exchange mode can be plotted. In the plot for the FMU it can be seen that the oscillation continues to decrease due to the effect of the friction. If you simulate long enough, the oscillation comes to a standstill in a certain time.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"fig = plot(simData, states=false)","category":"page"},{"location":"examples/manipulation/#Override-Function","page":"Manipulation","title":"Override Function","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"After overwriting a function, the previous one is no longer accessible. The original function fmi2GetReal() is cached by storing the address of the pointer. The addresses of the pointers are kept in the FMU and are thus accessible.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# save, where the original `fmi2GetReal` function was stored, so we can access it in our new function\noriginalGetReal = fmu.cGetReal","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"To overwrite the function fmi2GetReal!(), the function header of the new custom function must be identical to the previous one. The function header looks like fmi2GetReal!(cfunc::Ptr{Nothing}, c::fmi2Component, vr::Union{Array{fmi2ValueReference}, Ptr{fmi2ValueReference}}, nvr::Csize_t, value::Union{Array{fmi2Real}, Ptr{fmi2Real}})::fmi2Status. The information how the FMI2 function are structured can be seen from FMICore.jl, the api of fmi2GetReal! or the FMI2.0.3-specification.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In the new implementation the original function is called by the previously stored pointer. Next there is a special handling if value is a pointer to an array. In this case the pointer is treated as an array, so that the entries are accessible. Otherwise, each value in value is multiplied by two. Finally, the original state of the original function is output.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"function myGetReal!(c::fmi2Component, vr::Union{Array{fmi2ValueReference}, Ptr{fmi2ValueReference}}, \n                    nvr::Csize_t, value::Union{Array{fmi2Real}, Ptr{fmi2Real}})\n    # first, we do what the original function does\n    status = fmi2GetReal!(originalGetReal, c, vr, nvr, value)\n\n    # if we have a pointer to an array, we must interprete it as array to access elements\n    if isa(value, Ptr{fmi2Real})\n        value = unsafe_wrap(Array{fmi2Real}, value, nvr, own=false)\n    end\n\n    # now, we multiply every value by two (just for fun!)\n    for i in 1:nvr \n        value[i] *= 2.0 \n    end \n\n    # return the original status\n    return status\nend","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In the next command the original function is overwritten with the new defined function, for which the command fmiSetFctGetReal() is called.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# no we overwrite the original function\nfmiSetFctGetReal(fmu, myGetReal!)","category":"page"},{"location":"examples/manipulation/#Simulate-and-Plot-FMU-with-modified-function","page":"Manipulation","title":"Simulate and Plot FMU with modified function","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"As before, the identical command is called here for simulation. This is also a model exchange simulation. Immediately afterwards, the results are added to the previous graph as a dashed line.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"simData = fmiSimulate(fmu, (tStart, tStop); recordValues=vrs)\nplot!(fig, simData; states=false, style=:dash)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"As expected by overwriting the function, all values are doubled.","category":"page"},{"location":"examples/manipulation/#Unload-FMU","page":"Manipulation","title":"Unload FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"fmiUnload(fmu)","category":"page"},{"location":"examples/manipulation/#Summary","page":"Manipulation","title":"Summary","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In this tutorial it is shown how an existing function of the library can be replaced by an own implementation.","category":"page"},{"location":"library/#FMI.jl-Library-Functions","page":"User Level API - FMI.jl","title":"FMI.jl Library Functions","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"Many of the functions in this library are based on already defined functions of the FMIImport.jl library. ","category":"page"},{"location":"library/#Simulate-FMUs","page":"User Level API - FMI.jl","title":"Simulate FMUs","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"loadFMU\nsimulate\nsimulateCS\nsimulateSE\nsimulateME\nunloadFMU\nreload","category":"page"},{"location":"library/#FMIImport.loadFMU","page":"User Level API - FMI.jl","title":"FMIImport.loadFMU","text":"loadFMU(pathToFMU; unpackPath, cleanup, type)\n\nLoads an FMU, independent of the used FMI-version (the version is checked during unpacking the archive).\n\nArguments\n\npath::String the path pointing on the FMU file.\n\nKeywords\n\nunpackPath::Union{String, Nothing}=nothing the optional unpack path, if nothing a temporary directory depending on the OS is picked.\ncleanup::Bool=true a boolean indicating whether the temporary directory should be cleaned automatically.\ntype::Union{Symbol, Nothing}=nothing the type of FMU (:CS, :ME, :SE), if multiple types are available. If nothing one of the available types is chosen automatically with the priority CS > ME > SE.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.simulate","page":"User Level API - FMI.jl","title":"FMI.simulate","text":"simulate(fmu, instance=nothing, tspan=nothing; kwargs...)\nsimulate(fmu, tspan; kwargs...)\nsimulate(instance, tspan; kwargs...)\n\nStarts a simulation of the FMU2 for the instantiated type: CS, ME or SE (this is selected automatically or during loading of the FMU). You can force a specific simulation mode by calling simulateCS, simulateME or simulateSE directly.\n\nArguments\n\nfmu::FMU: The FMU to be simulated.\nc::Union{FMUInstance, Nothing}=nothing: The instance (FMI3) or component (FMI2) of the FMU, nothing if not available. \ntspan::Union{Tuple{Float64, Float64}, Nothing}=nothing: Simulation-time-span as tuple (default = nothing: use default value from FMU's model description or (0.0, 1.0) if not specified)\n\nKeyword arguments\n\nrecordValues::fmi2ValueReferenceFormat = nothing: Array of variables (Strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues\nsaveat = nothing: Time points to save (interpolated) values at (default = nothing: save at each solver timestep)\nsetup::Bool: call fmi2SetupExperiment, fmi2EnterInitializationMode and fmi2ExitInitializationMode before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nreset::Bool: call fmi2Reset before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\ninstantiate::Bool: call fmi2Instantiate! before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nfreeInstance::Bool: call fmi2FreeInstance after each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nterminate::Bool: call fmi2Terminate after each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\ninputValueReferences::fmi2ValueReferenceFormat = nothing: Input variables (Strings or variableIdentifiers) to set at each simulation step \ninputFunction = nothing: Function to get values for the input variables at each simulation step. \nparameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing: Dict of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization\nshowProgress::Bool = true: print simulation progress meter in REPL\n\nInput function pattern\n\n[c: current component, u: current state ,t: current time, returning array of values to be passed to fmi2SetReal(..., inputValueReferences, inputFunction(...)) or fmi3SetFloat64]:\n\ninputFunction(t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, u::AbstractVector{<:Real})\ninputFunction(x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\n\nReturns:\n\nA FMUSolution struct.\n\nSee also simulate, simulateME, simulateCS, simulateSE.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.simulateCS","page":"User Level API - FMI.jl","title":"FMI.simulateCS","text":"simulateCS(fmu, instance=nothing, tspan=nothing; kwargs...)\nsimulateCS(fmu, tspan; kwargs...)\nsimulateCS(instance, tspan; kwargs...)\n\nSimulate CS-FMU for the given simulation time interval. State- and Time-Events are handled internally by the FMU.\n\nArguments\n\nfmu::FMU: The FMU to be simulated.\nc::Union{FMUInstance, Nothing}=nothing: The instance (FMI3) or component (FMI2) of the FMU, nothing if not available. \ntspan::Union{Tuple{Float64, Float64}, Nothing}=nothing: Simulation-time-span as tuple (default = nothing: use default value from FMU's model description or (0.0, 1.0) if not specified)\n\nKeyword arguments\n\ntolerance::Union{Real, Nothing} = nothing: The tolerance for the internal FMU solver.\nrecordValues::fmi2ValueReferenceFormat = nothing: Array of variables (Strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues\nsaveat = nothing: Time points to save (interpolated) values at (default = nothing: save at each solver timestep)\nsetup::Bool: call fmi2SetupExperiment, fmi2EnterInitializationMode and fmi2ExitInitializationMode before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nreset::Bool: call fmi2Reset before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\ninstantiate::Bool: call fmi2Instantiate! before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nfreeInstance::Bool: call fmi2FreeInstance after each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nterminate::Bool: call fmi2Terminate after each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\ninputValueReferences::fmi2ValueReferenceFormat = nothing: Input variables (Strings or variableIdentifiers) to set at each simulation step \ninputFunction = nothing: Function to get values for the input variables at each simulation step. \nparameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing: Dict of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization\nshowProgress::Bool = true: print simulation progress meter in REPL\n\nInput function pattern\n\n[c: current component, u: current state ,t: current time, returning array of values to be passed to fmi2SetReal(..., inputValueReferences, inputFunction(...)) or fmi3SetFloat64]:\n\ninputFunction(t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, u::AbstractVector{<:Real})\ninputFunction(x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\n\nReturns:\n\nA FMUSolution struct.\n\nSee also simulate, simulateME, simulateSE.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.simulateSE","page":"User Level API - FMI.jl","title":"FMI.simulateSE","text":"simulateSE(fmu, instance=nothing, tspan=nothing; kwargs...)\nsimulateSE(fmu, tspan; kwargs...)\nsimulateSE(instance, tspan; kwargs...)\n\nTo be implemented ...\n\nArguments\n\nfmu::FMU3: The FMU to be simulated. Note: SE is only available in FMI3.\nc::Union{FMU3Instance, Nothing}=nothing: The instance (FMI3) of the FMU, nothing if not available. \ntspan::Union{Tuple{Float64, Float64}, Nothing}=nothing: Simulation-time-span as tuple (default = nothing: use default value from FMU's model description or (0.0, 1.0) if not specified)\n\nKeyword arguments\n\nTo be implemented ...\n\nReturns:\n\nA FMUSolution struct.\n\nSee also simulate, simulateME, simulateCS.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.simulateME","page":"User Level API - FMI.jl","title":"FMI.simulateME","text":"simulateME(fmu, instance=nothing, tspan=nothing; kwargs...)\nsimulateME(fmu, tspan; kwargs...)\nsimulateME(instance, tspan; kwargs...)\n\nSimulate ME-FMU for the given simulation time interval. State- and Time-Events are handled correctly.\n\nArguments\n\nfmu::FMU: The FMU to be simulated.\nc::Union{FMUInstance, Nothing}=nothing: The instance (FMI3) or component (FMI2) of the FMU, nothing if not available. \ntspan::Union{Tuple{Float64, Float64}, Nothing}=nothing: Simulation-time-span as tuple (default = nothing: use default value from FMU's model description or (0.0, 1.0) if not specified)\n\nKeyword arguments\n\nsolver = nothing: Any Julia-supported ODE-solver (default = nothing: use DifferentialEquations.jl default solver)\nrecordValues::fmi2ValueReferenceFormat = nothing: Array of variables (Strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues\nrecordEventIndicators::Union{AbstractArray{<:Integer, 1}, UnitRange{<:Integer}, Nothing} = nothing: Array or Range of event indicators to record\nrecordEigenvalues::Bool=false: compute and record eigenvalues\nsaveat = nothing: Time points to save (interpolated) values at (default = nothing: save at each solver timestep)\nx0::Union{AbstractArray{<:Real}, Nothing} = nothing: initial fmu State (default = nothing: use current or default-initial fmu state)\nsetup::Bool: call fmi2SetupExperiment, fmi2EnterInitializationMode and fmi2ExitInitializationMode before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nreset::Bool: call fmi2Reset before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\ninstantiate::Bool: call fmi2Instantiate! before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nfreeInstance::Bool: call fmi2FreeInstance after each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nterminate::Bool: call fmi2Terminate after each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\ninputValueReferences::fmi2ValueReferenceFormat = nothing: Input variables (Strings or variableIdentifiers) to set at each simulation step \ninputFunction = nothing: Function to get values for the input variables at each simulation step. \nparameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing: Dict of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization\ncallbacksBefore = []: callbacks to call before the internal callbacks for state- and time-events are called\ncallbacksAfter = []: callbacks to call after the internal callbacks for state- and time-events are called\nshowProgress::Bool = true: print simulation progress meter in REPL\nsolveKwargs...: keyword arguments that get passed onto the solvers solve call\n\nInput function pattern\n\n[c: current component, u: current state ,t: current time, returning array of values to be passed to fmi2SetReal(..., inputValueReferences, inputFunction(...)) or fmi3SetFloat64]:\n\ninputFunction(t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, u::AbstractVector{<:Real})\ninputFunction(x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\n\nReturns:\n\nA FMUSolution struct.\n\nSee also simulate, simulateCS, simulateSE.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIImport.unloadFMU","page":"User Level API - FMI.jl","title":"FMIImport.unloadFMU","text":"unloadFMU(fmu::FMU2, cleanUp::Bool=true; secure_pointers::Bool=true)\n\nUnload a FMU. Free the allocated memory, close the binaries and remove temporary zip and unziped FMU model description.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\ncleanUp::Bool= true: Defines if the file and directory should be deleted.\n\nKeywords\n\nsecure_pointers=true whether pointers to C-functions should be overwritten with dummies with Julia assertions, instead of pointing to dead memory (slower, but more user safe)\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIImport.reload","page":"User Level API - FMI.jl","title":"FMIImport.reload","text":"reload(fmu::FMU2)\n\nReloads the FMU-binary. This is useful, if the FMU does not support a clean reset implementation.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\n\n\n\n\n","category":"function"},{"location":"library/#Handling-Value-References","page":"User Level API - FMI.jl","title":"Handling Value References","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"stringToValueReference","category":"page"},{"location":"library/#FMIBase.stringToValueReference","page":"User Level API - FMI.jl","title":"FMIBase.stringToValueReference","text":"stringToValueReference(obj, names)\n\nFinds the value reference for a given name.\n\nArguments\n\nobj ‚àà (fmi2ModelDescription, fmi3ModelDescription, FMU2, FMU3) the FMI object\nnames ‚àà (String, AbstractVector{String}) the value refernce name or multiple names\n\nReturn\n\nReturns a single or an array of fmi2ValueReferences (FMI2) or fmi3ValueReferences (FMI3) corresponding to the variable name(s).\n\n\n\n\n\n","category":"function"},{"location":"library/#External/additional-functions","page":"User Level API - FMI.jl","title":"External/additional functions","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"info\ngetModelName\ngetNumberOfStates\nisModelExchange\nisScheduledExecution\nisCoSimulation\ngetState\ngetTime\ngetStateDerivative","category":"page"},{"location":"library/#FMIImport.info","page":"User Level API - FMI.jl","title":"FMIImport.info","text":" info(fmu)\n\nPrint information about the FMU.\n\nArguments\n\nfmu::FMU: The FMU you are interessted in.\n\nFurther reading\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.getModelName","page":"User Level API - FMI.jl","title":"FMIBase.getModelName","text":"getModelName(md::fmi2ModelDescription)\n\nReturns the tag 'modelName' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmodelName::String: Returns the tag 'modelName' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.getNumberOfStates","page":"User Level API - FMI.jl","title":"FMIBase.getNumberOfStates","text":"getNumberOfStates(md::fmi2ModelDescription)\n\nReturns the number of states of the FMU.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nReturns the number of states of the FMU.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.isModelExchange","page":"User Level API - FMI.jl","title":"FMIBase.isModelExchange","text":"isModelExchange(md::fmi2ModelDescription)\n\nReturns true, if the FMU supports model exchange\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU supports model exchange\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.isScheduledExecution","page":"User Level API - FMI.jl","title":"FMIBase.isScheduledExecution","text":"Returns true, if the FMU supports scheduled execution\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.isCoSimulation","page":"User Level API - FMI.jl","title":"FMIBase.isCoSimulation","text":"isCoSimulation(md::fmi2ModelDescription)\n\nReturns true, if the FMU supports co simulation\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU supports co simulation\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.getState","page":"User Level API - FMI.jl","title":"FMIBase.getState","text":"getState(solution::FMUSolution, vr::fmi2ValueReferenceFormat; isIndex::Bool=false)\n\nReturns the solution state.\n\nArguments\n\nsolution::FMUSolution: Struct contains information about the solution value, success, state and  events of a specific FMU.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nisIndex::Bool=false: Argument isIndex exists to check if vr ist the specific solution element (\"index\") that equals the given fmi2ValueReferenceFormat\n\nReturn\n\nIf he length of the given references equals 1, each element u in the collection solution.states.u, it is selecting the element at the index represented by indices[1] and returns it.\n\nThus, the collect() function is taking the generator expression and returning an array of the selected elements. \n\nIf more than one reference is given, the same process takes place as before. The difference is that now more than one index is accessed.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.getTime","page":"User Level API - FMI.jl","title":"FMIBase.getTime","text":"getTime(solution::FMUSolution)\n\nReturns the Solution time.\n\nArguments\n\nsolution::FMUSolution: Struct contains information about the solution value, success, state and  events of a specific FMU.\n\nReturn\n\nsolution.states.t::tType: solution.state is a struct ODESolution with attribute t. t is the time points corresponding to the saved values of the ODE solution.\nsolution.values.t::tType: solution.value is a struct ODESolution with attribute t.t the time points corresponding to the saved values of the ODE solution.\nIf no solution time is  found nothing is returned.\n\n#Source\n\nusing OrdinaryDiffEq: ODESolution  (SciML/SciMLBase.jl)\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.getStateDerivative","page":"User Level API - FMI.jl","title":"FMIBase.getStateDerivative","text":"getStateDerivative(solution::FMUSolution, vr::fmi2ValueReferenceFormat; isIndex::Bool=false)\n\nReturns the solution state derivative.\n\nArguments\n\nsolution::FMUSolution: Struct contains information about the solution value, success, state and  events of a specific FMU.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nisIndex::Bool=false: Argument isIndex exists to check if vr ist the specific solution element (\"index\") that equals the given fmi2ValueReferenceFormat\n\nReturn\n\nIf the length of the given references equals 1, each element myt in the collection solution.states.t is selecting the derivative of the solution states represented by indices[1] in respect to time, at time myt and returns its it.\n\nThus, the collect() function is taking the generator expression and returning an array of the selected derivatives. \n\nIf more than one reference is given, the same process takes place as before. The difference is that now more than one index is accessed.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"fmiSet fmiGet fmiGet! fmiCanGetSetState fmiSetState fmiFreeState! fmiGetDependencies fmiProvidesDirectionalDerivative","category":"page"},{"location":"library/#Visualize-simulation-results","page":"User Level API - FMI.jl","title":"Visualize simulation results","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"","category":"page"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"fmiPlot fmiPlot! Plots.plot","category":"page"},{"location":"library/#Save/load-simulation-results","page":"User Level API - FMI.jl","title":"Save/load simulation results","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"","category":"page"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"fmiSaveSolution fmiSaveSolutionJLD2 fmiSaveSolutionMAT fmiSaveSolutionCSV fmiLoadSolution fmiLoadSolutionJLD2","category":"page"},{"location":"library/#FMI2-specific","page":"User Level API - FMI.jl","title":"FMI2 specific","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"","category":"page"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"fmi2Info fmi2Simulate fmi2VariableDependsOnVariable fmi2GetDependencies fmi2PrintDependencies","category":"page"},{"location":"library/#FMI3-specific","page":"User Level API - FMI.jl","title":"FMI3 specific","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"","category":"page"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"fmi3Info fmi3Simulate fmi3VariableDependsOnVariable fmi3GetDependencies fmi3PrintDependencies","category":"page"},{"location":"features/#Features","page":"Features","title":"Features","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Please note, that this guide focuses also on users, that are not familiar with FMI. The following feature explanations are written in an easy-to-read-fashion, so there might be some points that are scientifically only 95% correct. For further information on FMI and FMUs, see fmi-standard.org. The term fmiX... refers to a value or function that is available along different versions of FMI, for example fmiXValueReference is a wildcard for fmi2ValueReference and fmi3ValueReference.","category":"page"},{"location":"features/#Execution-Configuration","page":"Features","title":"Execution Configuration","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Not all FMUs support all features they should according to the FMI-standard, so FMI.jl provides a so called execution configuration.  This configuration is also respected by FMIFlux.jl. The content of the execution configuration may change in future (together with new or deprecated features of linked libraries), but the most important core features will be kept over time. Because not all users need the full potential of this configuration tool, there are three presets given: ","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"myFMU.executionConfig = FMU_EXECUTION_CONFIGURATION_NO_RESET is the default operation mode for FMUs. FMUs are not reset via fmi2Reset, but new instantiated for every simulation run (or training step). This is not the most efficient way, but many FMUs have problems with resetting.\nmyFMU.executionConfig = FMU_EXECUTION_CONFIGURATION_RESET is faster for well-implemented FMUs, but needs a fully working fmi2Reset-function. So if you know you have a fully working fmi2Reset, you may be faster with that option.\nmyFMU.executionConfig = FMU_EXECUTION_CONFIGURATION_NO_FREEING should only be the very last choice. If your FMU neither supports fmi2Reset nor a proper fmi2FreeInstance, you could use this configuration as a last way out. Keep in mind, that new FMU instances are allocated but not freed, as long as your Julia instance is running (memory leak). In general, the amount of leaked memory is small, but you need to know what you are doing, if you do thousands or ten-thousands of simulation runs with such a FMU.\nmyFMU.executionConfig = FMU_EXECUTION_CONFIGURATION_NOTHING should be used if you want maximum control over what is done and what not. This means you need to take care of instantiating, initialization, setting up and releasing FMU instances by yourself.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"For a more detailed overview, please see the ?FMUExecutionConfig.","category":"page"},{"location":"features/#Debugging-/-Logging","page":"Features","title":"Debugging / Logging","text":"","category":"section"},{"location":"features/#Logging-FMI-calls","page":"Features","title":"Logging FMI-calls","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"To log all FMI-calls that happen (including \"hidden\" calls e.g. if you are using simulate) you can enable debugging for FMICore.jl using ENV[\"JULIA_DEBUG\"] = \"FMICore\". This will log any fmi2xxx- and fmi3xxx-call, including the given parameters and return value. This can be a lot of calls, so you may want to redirect your REPL output to file.","category":"page"},{"location":"features/#Printing-internal-FMU-messages","page":"Features","title":"Printing internal FMU messages","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Many FMUs support for printing debugging messages. To force message printing, you can use the keyword loggingOn=true either ...","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"in the call fmiInstantiate, for example fmiInstantiate(myFMU; loggingOn=true) or\nas part of the executionConfig, for example myFMU.executionConfig.loggingOn=true","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"You can further control which message types - like OK, Warning, Discard, Error, Fatal, Pending - should be logged by using the keywords logStatus{TYPE}=true as part of fmiInstantiate or (soon) the execution configuration. By default, all are activated. If your FMU (for FMI2 only, FMI3 changed this) uses a variadic callback function for messages (this is not supported by Julia at this time), you may need to activate external callbacks with the keyword externalCallbacks=true either ...","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"in the call fmiInstantiate!, for example fmiInstantiate!(myFMU; loggingOn=true, externalCallbacks=true) or\nas part of the executionConfig, for example myFMU.executionConfig.loggingOn=true; myFMU.executionConfig.externalCallbacks=true","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"External callbacks are currently only supported on Windows and Linux.","category":"page"},{"location":"features/#Model-variable-identification","page":"Features","title":"Model variable identification","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"FMI.jl offers multiple ways to retrieve your model variables. Any function that accepts a variable identifier can handle the following argument types:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"UInt32 or fmiXValueReference for example 1610612742 or 0x16000001: This is the most performant way of passing a variable identifier, but you need to know the value reference (you can determine them by having a look in the modelDescription.xml).\nVector{UInt32} or Vector{fmiXValueReference} for example [1610612742, 1610612743] or [0x16000001, 0x16000002]: This is the most performant way of passing multiple variable identifiers, but you need to know the value references.\nString for example \"ball.s\": This is the most intuitive way, because you might already know the variable name from your modelling environment or model documentation.\nVector{String} for example [\"ball.s\", \"der(ball.s)\"]: This is the most intuitive way for multiple variable identifiers, because you might already know the variable names from your modelling environment or model documentation.\nSymbol for example :states: There are multiple symbol-wildcards for interesting variable groups like :all, :none, :states, :derivatives, :inputs and :outputs.\nnothing: If you don't want to record anything (same as :none)","category":"page"},{"location":"features/#Event-handling","page":"Features","title":"Event handling","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"In FMI, there are basically two types of events: state and time.  State events are triggered, as soon as one or more event indicators - scalar values that describe the \"distance\" in state space to the next state event - crossing zero.  Time events are triggered at known time points during the simulation.  If your model has state and/or time events is detected automatically by FMI.jl and the event handling happens automatically in the background.","category":"page"},{"location":"features/#Model-exchange,-co-simulation-and-scheduled-execution","page":"Features","title":"Model exchange, co-simulation and scheduled execution","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"There are two different model types for FMUs in FMI2: Model exchange (ME) and co-simulation (CS). FMI3 further adds the mode scheduled execution (SE). If you have a FMU and are only interested in getting it simulated, use simulate so FMI.jl will automatically pick CS if available and otherwise ME. If you want to force a specific simulation mode, you can use simulateME (for ME), simulateCS (for CS) or simulateSE (for SE).","category":"page"},{"location":"features/#Simulate-arbitrary-time-intervals","page":"Features","title":"Simulate arbitrary time intervals","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"You can simply simulate arbitrary time intervals by passing a startTime unequal zero to fmi2SetupExperiment or [ToDo: corresponding FMI3 function].  Because some FMUs don't support startTime != 0.0 and will throw an error or warning, a time shifting feature inside FMI.jl can be used, that performs all necessary steps in the background - corresponding commands like e.g. fmi2SetTime or fmi2NewDiscreteStates act like the desired time interval is simulated. This feature is disabled by default, but can be activated in the execution configuration using myFMU.executionConfig.autoTimeShift=true while providing a startTime != 0.0.","category":"page"},{"location":"features/#Performance","page":"Features","title":"Performance","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"In- and Out-of-Place: Many commands in FMI.jl are available in in-place and out-of-place semantics. Of course, in-place-calls are faster, because they don't need to allocate new memory at every call (for the return values). So if you have an eye on performance (or must have), a good starting point is to substitute out-of-place- with in-place-calls. Typical improvements are:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"valueArray = fmi2GetReal(args...) -> fmi2GetReal!(args..., valueArray)\nvalueArray = fmi2GetDerivatives(args...) -> fmi2GetDerivatives!(args..., valueArray)\nvalueArray = fmi2NewDiscreteStates(args...) -> fmi2NewDiscreteStates!(args..., valueArray)","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Of course, you have to use the same piece of memory (to write your return values in) for multiple calls - otherwise there will be no improvement because the number of allocations stays the same.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Views: You can use array-views instead of array-slices as input for in-place-functions, which further reduces memory allocations.","category":"page"},{"location":"features/#AD-Ecosystem-(differentiation-over-FMUs)","page":"Features","title":"AD-Ecosystem (differentiation over FMUs)","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Sensitivites over FMUs are fully integrated into FMI.jl, FMIImport.jl and FMIFlux.jl. Supported are ForwardDiff.jl together with all AD-frameworks, that use the interface of ChainRules.jl like e.g. Zygote.jl and ReverseDiff.jl. As a result, you can use implicit solvers or you can use FMUs as part of machine learning applications.","category":"page"},{"location":"features/#Watch-your-progress","page":"Features","title":"Watch your progress","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"When simulating FMUs with FMI.jl, a progress meter is shown per default. You can control the appearance via the keyword argument showProgress for simulate, simulateME, simulateCS and simulateSE.  Progress meters are also available for FMIFlux.jl, but deactivated by default (during training, this can be a bit too much). When evaluating a NeuralFMU, you can use the same keyword with showProgress=true to show a progress bar during training, too. The simulation trajectory (also called the solution of your FMU's ODE system) can be plotted using plot(solution), all axis will be labeled automatically.","category":"page"},{"location":"features/#Parallelization","page":"Features","title":"Parallelization","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"A native integrated support for multi-threaded and multi-process FMU-simulation (for example for Monte Carlo experiments) will be deployed soon. ","category":"page"},{"location":"related/#Related-Publications","page":"Related Publication","title":"Related Publications","text":"","category":"section"},{"location":"related/","page":"Related Publication","title":"Related Publication","text":"Tobias Thummerer, Josef Kircher, Lars Mikelsons 2021 NeuralFMU: Towards Structural Integration of FMUs into Neural Networks (14th Modelica Conference, Preprint, Accepted) arXiv:2109.04351","category":"page"},{"location":"related/","page":"Related Publication","title":"Related Publication","text":"Tobias Thummerer, Johannes Tintenherr, Lars Mikelsons 2021 Hybrid modeling of the human cardiovascular system using NeuralFMUs (10th International Conference on Mathematical Modeling in Physical Sciences, Preprint, Accepted) arXiv:2109.04880","category":"page"},{"location":"examples/multiple_instances/#Multiple-Instances-of-an-FMU","page":"Multiple instances","title":"Multiple Instances of an FMU","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"üöß This tutorial is under revision and will be replaced by an up-to-date version soon üöß","category":"page"},{"location":"examples/multiple_instances/#License","page":"Multiple instances","title":"License","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/multiple_instances/#Motivation","page":"Multiple instances","title":"Motivation","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/multiple_instances/#Introduction-to-the-example","page":"Multiple instances","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"In this example we want to show that it is possible to create different instances of an FMU. The different instances can then be used to run independent simulations. After the FMU has been simulated, the simulation results are displayed in a graph. The used model is a one-dimensional spring pendulum without friction. The object-orientated structure of the SpringPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"(Image: svg)  ","category":"page"},{"location":"examples/multiple_instances/#Target-group","page":"Multiple instances","title":"Target group","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/multiple_instances/#Other-formats","page":"Multiple instances","title":"Other formats","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/multiple_instances/#Getting-started","page":"Multiple instances","title":"Getting started","text":"","category":"section"},{"location":"examples/multiple_instances/#Installation-prerequisites","page":"Multiple instances","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install Plots via add Plots ","category":"page"},{"location":"examples/multiple_instances/#Code-section","page":"Multiple instances","title":"Code section","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots","category":"page"},{"location":"examples/multiple_instances/#Simulation-setup","page":"Multiple instances","title":"Simulation setup","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Next, the start time and end time of the simulation are set. Finally, the recorded values are specified to store the results of the simulation.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"tStart = 0.0\ntStop = 8.0\n\nvrs = [\"mass.s\"]","category":"page"},{"location":"examples/multiple_instances/#Import-FMU","page":"Multiple instances","title":"Import FMU","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"SpringPendulum1D\", \"Dymola\", \"2022x\")\n\nmyFMU = fmiLoad(pathToFMU)\nfmiInfo(myFMU)","category":"page"},{"location":"examples/multiple_instances/#First-Instance","page":"Multiple instances","title":"First Instance","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"To create an instance of the FMU it is necessary to call the command fmiInstantiate!(). With the component address you now have a unique instance of the FMU.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"comp1 = fmiInstantiate!(myFMU; loggingOn=true)\ncomp1Address= comp1.compAddr\nprintln(comp1)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Next, a dictionary for the parameters is created. With this dictionary you can set the initial states of the variables of the FMU. For the spring constant spring.c a value of 100 fracNm and for the position of the mass mass.s a value of 10 m is set. The created dictionary with the specified variables for recording are passed to the command for simulation. In addition, other keywords are set. On the one hand the keyword instantiate=false is set, which prevents that in the simulation command a new instance is created. On the other hand the keyword freeInstance=false is set, this prevents that after the simulation command the instance is released. ","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"param1 = Dict(\"spring.c\"=>10.0, \"mass_s0\"=>1.0)\ndata1 = fmiSimulate(comp1, (tStart, tStop); parameters=param1, recordValues=vrs, instantiate=false, freeInstance=false)\nfig = fmiPlot(data1)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"For control, you can compare again the address of the instance to the previous address, and it should be the same address. As soon as this is not the case an error would be thrown by the macro @assert.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"@assert comp1.compAddr === comp1Address","category":"page"},{"location":"examples/multiple_instances/#Second-Instance","page":"Multiple instances","title":"Second Instance","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"To create a second instance of the FMU it is necessary to call the command fmiInstantiate!(). With the component address you now have a unique instance of the FMU.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"comp2 = fmiInstantiate!(myFMU; loggingOn=true)\ncomp2Address= comp2.compAddr\nprintln(comp2)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"The addresses of the instantiated FMUs must differ, and you can see that in the comparison below.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"@assert comp1Address !== comp2Address","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Again, a dictionary for the parameters is created. With this dictionary you can set the initial states of the variables of the FMU. For the spring constant spring.c a value of 10 fracNm and for the position of the mass mass.s a value of 20 m is set. The created dictionary with the specified variables for recording are passed to the command for simulation. As before, the two keywords instantiate=false and freeInstance=false are set.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"param2 = Dict(\"spring.c\"=>1.0, \"mass.s\"=>2.0)\ndata2 = fmiSimulateCS(comp2, (tStart, tStop);  parameters=param2, recordValues=vrs, instantiate=false, freeInstance=false)\nfmiPlot!(fig, data2)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"For control, you can compare again the address of the instance comp2 to the previous address comp2Address and it should be the same address.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"@assert comp2.compAddr === comp2Address","category":"page"},{"location":"examples/multiple_instances/#Unload-FMU","page":"Multiple instances","title":"Unload FMU","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"fmiUnload(myFMU)","category":"page"},{"location":"examples/multiple_instances/#Summary","page":"Multiple instances","title":"Summary","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Based on the example it can be seen that it is possible to create different instances of an FMU. The different instances can then be used to perform different simulations.","category":"page"},{"location":"examples/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"This section discusses the included examples of the FMI.jl library. If you require further information about the function calls, see the function sections of the library.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Examples are subdevided into Basics, Advanced, Pluto workshops and Publication appendices.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Basic examples:","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Simulate: Showing how you can simulate a CS-FMU and a ME-FMU.\nParameterize: A short example explaining how to parameterize a FMU before simulation.\nInputs: A short example explaining how to simulate a FMU with inputs.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Advanced examples:","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Parameter Optimization: An introduction on how FMU parameters can be optimized to fit a specific behaviour.\nMultiple instances: Showing the use of multiple FMU instances.\nManipulation: Showing how to redefine a linked C-library function of FMU.\nMultithreading: Shows how to use multithreading to simulate multiple FMUs.\nMultiprocessing: Shows how to use multiprocessing to simulate multiple FMUs.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Pluto workshops:","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Pluto workshops: Pluto based notebooks, that can easyly be executed on your own Pluto-Setup.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Publication appendices:","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Modelica conference 2021: Showing the different variants of simulating an FMU.","category":"page"},{"location":"fmi-tool-info/#FMU-Import-Compatibility-information-(*FMIImport.jl*)","page":"FMI Tool Information","title":"FMU Import Compatibility information (FMIImport.jl)","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"This section contains information about how import and simulation of FMI.jl and FMIInmport.jl where tested.","category":"page"},{"location":"fmi-tool-info/#FMI-3.0","page":"FMI Tool Information","title":"FMI-3.0","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"FMI3 is for now only beta supported and information will be deployed together with the full support release.","category":"page"},{"location":"fmi-tool-info/#FMI-2.0","page":"FMI Tool Information","title":"FMI-2.0","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"FMI.jl and FMIImport.jl are validated by simulating all valid FMI2-FMUs from the official FMI-Cross-Check in ME- as well as in CS-Mode, excluding the tools AMESim, Test-FMUs, SimulationX and Silver. For more information see our automated GitHub-Action. The results files - as defined by the FMI Cross Check - can be found in the forked repository inside of the corresponding sub folders.  There are different branches for different OS-configurations available.","category":"page"},{"location":"fmi-tool-info/#FMU-Export-Compatibility-information-(*FMIExport.jl*)","page":"FMI Tool Information","title":"FMU Export Compatibility information (FMIExport.jl)","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"Detailed export information and automatically generated FMUs will be deployed soon in the repository.","category":"page"},{"location":"fmi-tool-info/#FMI-3.0-2","page":"FMI Tool Information","title":"FMI-3.0","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"File name x86_64-windows x86_64-linux\nBouncingBall coming soon coming soon\nManipulation coming soon coming soon\nNeuralFMU coming soon coming soon","category":"page"},{"location":"fmi-tool-info/#FMI-2.0-2","page":"FMI Tool Information","title":"FMI-2.0","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"File name x86_64-windows x86_64-linux\nBouncingBall ME coming soon\nManipulation ME coming soon\nNeuralFMU ME coming soon","category":"page"},{"location":"fmi-tool-info/#Validation-tools","page":"FMI Tool Information","title":"Validation tools","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"Dassault Dymola 2022X\nFMU Check","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This list some common - often numerical - errors, that can be fixed by better understanding the ODE-Problem inside your FMU.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"faq/#Solving-non-linear-system-fails","page":"FAQ","title":"Solving non-linear system fails","text":"","category":"section"},{"location":"faq/#Description","page":"FAQ","title":"Description","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Error message or warning, that solving of a non-linear system failed, close to the simulation start time.","category":"page"},{"location":"faq/#Example","page":"FAQ","title":"Example","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Solving non-linear system 101 failed at time=3e-05.","category":"page"},{"location":"faq/#Reason","page":"FAQ","title":"Reason","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This could be, because the first step of the integration is accepted by the solver's error estimation, but shouldn't. This is usually, if the first step is picked to large by the solver's start step size heuristics.","category":"page"},{"location":"faq/#Fix","page":"FAQ","title":"Fix","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Try a small start value for the integration with keyword dt.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"faq/#Access-denied","page":"FAQ","title":"Access denied","text":"","category":"section"},{"location":"faq/#Description-2","page":"FAQ","title":"Description","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Error message, that the binary for callback functions can't be accessed/opened.","category":"page"},{"location":"faq/#Example-2","page":"FAQ","title":"Example","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"ERROR:\ncould not load library \"...\\src\\FMI2\\callbackFunctions\\binaries\\win64\\callbackFunctions.dll\"\nAccess denied","category":"page"},{"location":"faq/#Reason-2","page":"FAQ","title":"Reason","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This is because your OS doesn't allow to interact with the binaries shipped with FMI.jl. ","category":"page"},{"location":"faq/#Fix-2","page":"FAQ","title":"Fix","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This can easily be solved by fixing the binary's permission options or is automatically fixed if Julia runs with admin privileges.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"faq/#Double-Callback-Crossing","page":"FAQ","title":"Double Callback Crossing","text":"","category":"section"},{"location":"faq/#Description-3","page":"FAQ","title":"Description","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Error message, that solving failed because of double callback crossing.","category":"page"},{"location":"faq/#Example-3","page":"FAQ","title":"Example","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"ERROR:\nDouble callback crossing floating pointer reducer errored. Report this issue.","category":"page"},{"location":"faq/#Reason-3","page":"FAQ","title":"Reason","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This is because the event instant (time point) of an FMU event indicator can't be found precisely.","category":"page"},{"location":"faq/#Fix-3","page":"FAQ","title":"Fix","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This can be solved by allowing for more interpolation points during searching of the zero crossing:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"fmu.executionConfig.rootSearchInterpolationPoints = 1000 # default value is 10","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This will have negative performance impact on systems with extreme amount of events (thousands per second).  For systems with only a few events there won't be a noticeable slow down.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/#Working-with-the-FMI-model-description","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"section"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"The FMI model description provides all human readable information on the model. The following functions can be used to obtain all information provided by the model description, which in turn can be extracted from the fmu.","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/#Loading/Parsing","page":"Working with the FMI model description","title":"Loading/Parsing","text":"","category":"section"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi3LoadModelDescription","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/#general-information-about-the-FMU","page":"Working with the FMI model description","title":"general information about the FMU","text":"","category":"section"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi3GetGenerationTool fmi3GetGenerationDateAndTime","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/#technical-information-about-the-FMU","page":"Working with the FMI model description","title":"technical information about the FMU","text":"","category":"section"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi3GetVersion\n\nfmi3GetNumberOfEventIndicators\nfmi3GetNumberOfEventIndicators!","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/#FMICore.fmi3GetVersion","page":"Working with the FMI model description","title":"FMICore.fmi3GetVersion","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.4. Inquire Version Number of Header Files\n\nThis function returns fmi3Version of the fmi3Functions.h header file which was used to compile the functions of the FMU. This function call is allowed always and in all interface types.\n\nThe standard header file as documented in this specification has version \"3.0-beta.2\", so this function returns \"3.0-beta.2\".\n\n\n\n\n\nfmi3GetVersion(fmu::FMU3)\n\nArguments\n\nfmu::FMU3: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.\n\nReturns\n\nReturns a string from the address of a C-style (NUL-terminated) string. The string represents the version of the ‚Äúfmi3Functions.h‚Äù header file which was used to compile the functions of the FMU. The function returns ‚ÄúfmiVersion‚Äù which is defined in this header file. The standard header file as documented in this specification has version ‚Äú3.0‚Äù\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4. Inquire Version Number of Header Files\n\n\n\n\n\nfunction fmi3GetVersion(fmu::FMU3)\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nReturns a string from the address of a C-style (NUL-terminated) string. The string represents the version of the ‚Äúfmi3Functions.h‚Äù header file which was used to compile the functions of the FMU. The function returns ‚ÄúfmiVersion‚Äù which is defined in this header file. The standard header file as documented in this specification has version ‚Äú3.0‚Äù\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4. Inquire Version Number of Header Files\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_modeldescription_functions/#FMIImport.fmi3GetNumberOfEventIndicators","page":"Working with the FMI model description","title":"FMIImport.fmi3GetNumberOfEventIndicators","text":"fmi3GetNumberOfEventIndicators(c::FMU3Instance)\n\nThis function returns the number of event indicators. This function can only be called in Model Exchange. \n\nfmi3GetNumberOfEventIndicators must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nsize::Integer: Return size is the number of event indicators of this instance \n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3GetNumberOfEventIndicators.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_modeldescription_functions/#FMICore.fmi3GetNumberOfEventIndicators!","page":"Working with the FMI model description","title":"FMICore.fmi3GetNumberOfEventIndicators!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.2. State: Instantiated\n\nThis function returns the number of event indicators. This function can only be called in Model Exchange. \n\nfmi3GetNumberOfEventIndicators must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.\n\n\n\n\n\nfmi3GetNumberOfEventIndicators!(c::FMU3Instance, nEventIndicators::Ref{Csize_t})\n\nThis function returns the number of event indicators. This function can only be called in Model Exchange. \n\nfmi3GetNumberOfEventIndicators must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nnEventIndicators::Ref{Csize_t}: Stores the number of continuous states returned by the function\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3GetNumberOfEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_modeldescription_functions/#FMU-capabilities","page":"Working with the FMI model description","title":"FMU capabilities","text":"","category":"section"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi3CanGetSetState fmi3CanSerializeFMUState","category":"page"},{"location":"fmi3_lowlevel_ME_functions/#FMI-for-Model-Exchange","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"","category":"section"},{"location":"fmi3_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"This chapter contains the interface description to access the equations of a dynamic system from a C program.","category":"page"},{"location":"fmi3_lowlevel_ME_functions/#Providing-Independent-Variables-and-Re-initialization-of-Caching","page":"FMI for Model Exchange","title":"Providing Independent Variables and Re-initialization of Caching","text":"","category":"section"},{"location":"fmi3_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"Depending on the situation, different variables need to be computed. In order to be efficient, it is important that the interface requires only the computation of variables that are needed in the present context. The state derivatives shall be reused from the previous call. This feature is called ‚Äúcaching of variables‚Äù in the sequel. Caching requires that the model evaluation can detect when the input arguments, like time or states, have changed.","category":"page"},{"location":"fmi3_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"fmi3SetTime\nfmi3SetContinuousStates\nfmi3GetEventIndicators\nfmi3GetEventIndicators!","category":"page"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3SetTime","page":"FMI for Model Exchange","title":"FMICore.fmi3SetTime","text":"Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode\n\nSet a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).\n\n\n\n\n\nfmi3SetTime(c::FMU3Instance, time::fmi3Float64)\n\nSet a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\ntime::fmi3Float64: Argument time contains a value of type fmi3Float64 which is a alias type for Real data type. time sets the independent variable time t.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3SetTime.\n\n\n\n\n\nfmi3SetTime(c::FMU3Instance, time::Real)\n\nSet a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nt::Real: Argument t contains a value of type Real which is a alias type for Real data type. time sets the independent variable time t.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3SetTime.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3SetContinuousStates","page":"FMI for Model Exchange","title":"FMICore.fmi3SetContinuousStates","text":"Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode\n\nSet a new (continuous) state vector and re-initialize caching of variables that depend on the states. Argument nx is the length of vector x and is provided for checking purposes\n\n\n\n\n\nfmi3SetContinuousStates(c::FMU3Instance,\n    x::AbstractArray{fmi3Float64},\n    nx::Csize_t)\n\nSet a new (continuous) state vector and re-initialize caching of variables that depend on the states. Argument nx is the length of vector x and is provided for checking purposes\n\nIf fmi3UpdateDiscreteStates returned with nominalsOfContinuousStatesChanged == fmi3True, then at least one nominal value of the states has changed and can be inquired with fmi3GetNominalsOfContinuousStates. Not allowed in Co-Simulation and Scheduled Execution.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx::AbstractArray{fmi3Float64}: Argument x contains values of type fmi3Float64 which is a alias type for Real data type. x is the AbstractArray which contains the Real values of the vector that represent the nominal values of the continuous states.\nnx::Csize_t: Argument nx defines the length of vector x and is provided for checking purposes\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3SetContinuousStates.\n\n\n\n\n\nfmi3SetContinuousStates(c::FMU3Instance, x::Union{AbstractArray{Float32}, AbstractArray{Float64}})\n\nSet a new (continuous) state vector and re-initialize caching of variables that depend on the states. Argument nx is the length of vector x and is provided for checking purposes\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx::Union{AbstractArray{Float32},AbstractArray{Float64}}:Argument x is the AbstractArray of the vector values of Float64 or Float32.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3SetContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMIImport.fmi3GetEventIndicators","page":"FMI for Model Exchange","title":"FMIImport.fmi3GetEventIndicators","text":"fmi3GetEventIndicators(c::FMU3Instance)\n\nReturns the event indicators of the FMU\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\neventIndicators::Array{fmi3Float64}:The event indicators are returned as a vector represented by an array of \"fmi3Float64\" values.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3GetEventIndicators.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3GetEventIndicators!","page":"FMI for Model Exchange","title":"FMICore.fmi3GetEventIndicators!","text":"Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode\n\nCompute event indicators at the current time instant and for the current states. EventIndicators signal Events by their sign change.\n\n\n\n\n\nfmi3GetEventIndicators!(c::FMU3Instance, eventIndicators::AbstractArray{fmi3Float64}, ni::Csize_t)\n\nCompute event indicators at the current time instant and for the current states. EventIndicators signal Events by their sign change.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\neventIndicators::AbstractArray{fmi3Float64}: Argument eventIndicators contains values of type fmi3Float64 which is a alias type for Real data type.eventIndicators is the AbstractArray which contains the Real values of the vector that represent the event indicators.\nni::Csize_t: Argument ni defines the length of vector eventIndicators and is provided for checking purposes\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3GetEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#Evaluation-of-Model-Equations","page":"FMI for Model Exchange","title":"Evaluation of Model Equations","text":"","category":"section"},{"location":"fmi3_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"fmi3EnterEventMode\nfmi3EnterContinuousTimeMode\nfmi3CompletedIntegratorStep!\nfmi3GetContinuousStates\nfmi3GetContinuousStates!\nfmi3GetNominalsOfContinuousStates!\nfmi3GetNumberOfContinuousStates\nfmi3GetNumberOfContinuousStates!","category":"page"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3EnterEventMode","page":"FMI for Model Exchange","title":"FMICore.fmi3EnterEventMode","text":"Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode\n\nThe model enters Event Mode from the Continuous-Time Mode in ModelExchange oder Step Mode in CoSimulation and discrete-time equations may become active (and relations are not ‚Äúfrozen‚Äù).\n\n\n\n\n\nfmi3EnterEventMode(c::FMU3Instance, stepEvent::fmi3Boolean, stateEvent::fmi3Boolean, rootsFound::AbstractArray{fmi3Int32}, nEventIndicators::Csize_t, timeEvent::fmi3Boolean; soft::Bool=false)\n\nThe model enters Event Mode from the Continuous-Time Mode in ModelExchange oder Step Mode in CoSimulation and discrete-time equations may become active (and relations are not ‚Äúfrozen‚Äù).\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nstepEvent::fmi3Boolean: \nstateEvent::fmi3Boolean: \nrootsFound::AbstractArray{fmi3Int32}: \nnEventIndicators::Csize_t: \ntimeEvent::fmi3Boolean: \nsoft::Bool=false: \n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state  fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3EnterEventMode.\n\n\n\n\n\nfmi3EnterEventMode(c::FMU3Instance, stepEvent::Bool, stateEvent::Bool, rootsFound::AbstractArray{fmi3Int32}, nEventIndicators::Csize_t, timeEvent::Bool)\n\nThe model enters Event Mode from the Continuous-Time Mode in ModelExchange oder Step Mode in CoSimulation and discrete-time equations may become active (and relations are not ‚Äúfrozen‚Äù).\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nstepEvent::Bool:  \nstateEvent::Bool: \nrootsFound::AbstractArray{fmi3Int32}: \nnEventIndicators::Csize_t: \ntimeEvent::Bool: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3EnterEventMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3EnterContinuousTimeMode","page":"FMI for Model Exchange","title":"FMICore.fmi3EnterContinuousTimeMode","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.5. State: Event Mode\n\nThe model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are ‚Äúfrozen‚Äù. This function has to be called when changing from Event Mode (after the global event iteration in Event Mode over all involved FMUs and other models has converged) into Continuous-Time Mode.\n\n\n\n\n\nfmi3EnterContinuousTimeMode(c::FMU3Instance; soft::Bool=false)\n\nThe model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are ‚Äúfrozen‚Äù. This function has to be called when changing from Event Mode (after the global event iteration in Event Mode over all involved FMUs and other models has converged) into Continuous-Time Mode.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state  fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.5. State: Event Mode\n\nSee also fmi3EnterContinuousTimeMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3CompletedIntegratorStep!","page":"FMI for Model Exchange","title":"FMICore.fmi3CompletedIntegratorStep!","text":"Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode\n\nThis function must be called by the environment after every completed step of the integrator provided the capability flag needsCompletedIntegratorStep = true. If enterEventMode == fmi3True, the event mode must be entered If terminateSimulation == fmi3True, the simulation shall be terminated\n\n\n\n\n\nfmi3CompletedIntegratorStep!(c::FMU3Instance,\n                                  noSetFMUStatePriorToCurrentPoint::fmi3Boolean,\n                                  enterEventMode::Ref{fmi3Boolean},\n                                  terminateSimulation::Ref{fmi3Boolean})\n\nThis function must be called by the environment after every completed step of the integrator provided the capability flag needsCompletedIntegratorStep == true. If enterEventMode == fmi3True, the event mode must be entered If terminateSimulation == fmi3True, the simulation shall be terminated\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nnoSetFMUStatePriorToCurrentPoint::fmi3Boolean: Argument noSetFMUStatePriorToCurrentPoint = fmi3True if fmi3SetFMUState  will no longer be called for time instants prior to current time in this simulation run.\nenterEventMode::Ref{fmi3Boolean}: Argument enterEventMode points to the return value (fmi3Boolean) which signals to the environment if the FMU shall call fmi3EnterEventMode. fmi3Boolean is an alias type for Boolean data type.\nterminateSimulation::Ref{fmi3Boolean}: Argument terminateSimulation points to the return value (fmi3Boolean) which signals signal if the simulation shall be terminated. fmi3Boolean is an alias type for Boolean data type.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3CompletedIntegratorStep!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMIImport.fmi3GetContinuousStates","page":"FMI for Model Exchange","title":"FMIImport.fmi3GetContinuousStates","text":"fmi3GetContinuousStates(c::FMU3Instance)\n\nReturn the new (continuous) state vector x\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nx::Array{fmi3Float64}: Returns an array of fmi3Float64 values representing the new continuous state vector x.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.3.3. State: Initialization Mode\n\nSee also fmi3GetContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3GetContinuousStates!","page":"FMI for Model Exchange","title":"FMICore.fmi3GetContinuousStates!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.3. State: Initialization Mode\n\nReturn the states at the current time instant.\n\nThis function must be called if fmi3UpdateDiscreteStates returned with valuesOfContinuousStatesChanged == fmi3True. Not allowed in Co-Simulation and Scheduled Execution.\n\n\n\n\n\nfmi3GetContinuousStates!(c::FMU3Instance, nominals::AbstractArray{fmi3Float64}, nContinuousStates::Csize_t)\n\nReturn the states at the current time instant.\n\nThis function must be called if fmi3UpdateDiscreteStates returned with valuesOfContinuousStatesChanged == fmi3True. Not allowed in Co-Simulation and Scheduled Execution.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nnominals::AbstractArray{fmi3Float64}: Argument nominals contains values of type fmi3Float64 which is a alias type for Real data type. nominals is the AbstractArray which contains the Real values of the vector that represent the new state vector.\nnContinuousStates::Csize_t: Argument nContinuousStates defines the length of vector nominals and is provided for checking purposes\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.3. State: Initialization Mode\n\nSee also fmi3GetContinuousStates!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3GetNominalsOfContinuousStates!","page":"FMI for Model Exchange","title":"FMICore.fmi3GetNominalsOfContinuousStates!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.3. State: Initialization Mode\n\nReturn the nominal values of the continuous states.\n\nIf fmi3UpdateDiscreteStates returned with nominalsOfContinuousStatesChanged == fmi3True, then at least one nominal value of the states has changed and can be inquired with fmi3GetNominalsOfContinuousStates. Not allowed in Co-Simulation and Scheduled Execution.\n\n\n\n\n\nfmi3GetNominalsOfContinuousStates!(c::FMU3Instance, x_nominal::AbstractArray{fmi3Float64}, nx::Csize_t)\n\nReturn the nominal values of the continuous states.\n\nIf fmi3UpdateDiscreteStates returned with nominalsOfContinuousStatesChanged == fmi3True, then at least one nominal value of the states has changed and can be inquired with fmi3GetNominalsOfContinuousStates. Not allowed in Co-Simulation and Scheduled Execution.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx_nominal::AbstractArray{fmi3Float64}: Argument x_nominal contains values of type fmi3Float64 which is a alias type for Real data type. x_nominal is the AbstractArray which contains the Real values of the vector that represent the nominal values of the continuous states.\nnx::Csize_t: Argument nx defines the length of vector x_nominal and is provided for checking purposes\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.3. State: Initialization Mode\n\nSee also fmi3GetNominalsOfContinuousStates!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMIImport.fmi3GetNumberOfContinuousStates","page":"FMI for Model Exchange","title":"FMIImport.fmi3GetNumberOfContinuousStates","text":"fmi3GetNumberOfContinuousStates(c::FMU3Instance)\n\nThis function returns the number of continuous states. This function can only be called in Model Exchange. \n\nfmi3GetNumberOfContinuousStates must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nsize::Integer: Return size is the number of continuous states of this instance \n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3GetNumberOfContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3GetNumberOfContinuousStates!","page":"FMI for Model Exchange","title":"FMICore.fmi3GetNumberOfContinuousStates!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.2. State: Instantiated\n\nThis function returns the number of continuous states. This function can only be called in Model Exchange. \n\nfmi3GetNumberOfContinuousStates must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.\n\n\n\n\n\nfmi3GetNumberOfContinuousStates!(c::FMU3Instance, nContinuousStates::Ref{Csize_t})\n\nThis function returns the number of continuous states. This function can only be called in Model Exchange. \n\nfmi3GetNumberOfContinuousStates must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nnContinuousStates::Ref{Csize_t}: Stores the number of continuous states returned by the function\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3GetNumberOfContinuousStates!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"fmi3CompletedIntegratorStep","category":"page"},{"location":"examples/inputs/#Simulate-an-FMU-with-inputs","page":"Inputs","title":"Simulate an FMU with inputs","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"Tutorial by Tobias Thummerer","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"üöß This tutorial is under revision and will be replaced by an up-to-date version soon üöß","category":"page"},{"location":"examples/inputs/#License","page":"Inputs","title":"License","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/inputs/#Introduction-to-the-example","page":"Inputs","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"This example shows how to add custom inputs to a FMU, that are used during simulation.","category":"page"},{"location":"examples/inputs/#Other-formats","page":"Inputs","title":"Other formats","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/inputs/#Code-section","page":"Inputs","title":"Code section","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots\nusing DifferentialEquations","category":"page"},{"location":"examples/inputs/#Simulation-setup","page":"Inputs","title":"Simulation setup","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"Next, the start time and end time of the simulation are set. Finally, a step size is specified to store the results of the simulation at these time steps.","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"tStart = 0.0\ntStep = 0.01\ntStop = 8.0\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"0.0:0.01:8.0","category":"page"},{"location":"examples/inputs/#Import-FMU","page":"Inputs","title":"Import FMU","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"Next, the FMU model from FMIZoo.jl is loaded.","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"# we use an FMU from the FMIZoo.jl\nfmu = loadFMU(\"SpringPendulumExtForce1D\", \"Dymola\", \"2022x\"; type=:ME) # load FMU in ME-Mode (\"Model Exchange\")","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"Model name:\tSpringPendulumExtForce1D\nType:\t\t0","category":"page"},{"location":"examples/inputs/#Simulate-as-Model-Exchange","page":"Inputs","title":"Simulate as Model-Exchange","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"In the function simulate() the FMU is simulated with an adaptive step size but with fixed save points tSave. In addition, the start and end time are specified. Note, that the dynamics of the input variables are not considered by the steps ize control of the solver, so it is highly recommended to limit the solver step size with the keyword argument dtmax if the input is more dynamic than the system.","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"# input function format \"t\", dependent on `t` (time)\nfunction extForce_t(t::Real, u::AbstractArray{<:Real})\n    u[1] = sin(t)\nend \n\n# simulate while setting inputs\ndata_extForce_t = simulate(fmu, (tStart, tStop);                 # FMU, start and stop time\n                          solver = Tsit5(),\n                          saveat=tSave,                         # timepoints for the ODE solution to be saved\n                          inputValueReferences=[\"extForce\"],    # the value references that should be set (inputs)\n                          inputFunction=extForce_t,             # the input function to be used\n                          dtmax=1e-2,                           # limit max step size to capture inputs\n                          showProgress=false)                   # disable progress bar\nplot(data_extForce_t)","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"<?xml version=\"1.0\" encoding=\"utf-8\"?> <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"600\" height=\"400\" viewBox=\"0 0 2400 1600\"> <defs>   <clipPath id=\"clip010\">     <rect x=\"0\" y=\"0\" width=\"2400\" height=\"1600\"/>   </clipPath> </defs> <path clip-path=\"url(#clip010)\" d=\"M0 1600 L2400 1600 L2400 0 L0 0  Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"1\"/> <defs>   <clipPath id=\"clip011\">     <rect x=\"480\" y=\"0\" width=\"1681\" height=\"1600\"/>   </clipPath> </defs> <path clip-path=\"url(#clip010)\" d=\"M147.478 1423.18 L2352.76 1423.18 L2352.76 47.2441 L147.478 47.2441  Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"1\"/> <defs>   <clipPath id=\"clip012\">     <rect x=\"147\" y=\"47\" width=\"2206\" height=\"1377\"/>   </clipPath> </defs> <polyline clip-path=\"url(#clip012)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"209.891,1423.18 209.891,47.2441 \"/> <polyline clip-path=\"url(#clip012)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"730.004,1423.18 730.004,47.2441 \"/> <polyline clip-path=\"url(#clip012)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"1250.12,1423.18 1250.12,47.2441 \"/> <polyline clip-path=\"url(#clip012)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"1770.23,1423.18 1770.23,47.2441 \"/> <polyline clip-path=\"url(#clip012)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"2290.34,1423.18 2290.34,47.2441 \"/> <polyline clip-path=\"url(#clip012)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"147.478,1382.7 2352.76,1382.7 \"/> <polyline clip-path=\"url(#clip012)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"147.478,1059.34 2352.76,1059.34 \"/> <polyline clip-path=\"url(#clip012)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"147.478,735.972 2352.76,735.972 \"/> <polyline clip-path=\"url(#clip012)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"147.478,412.608 2352.76,412.608 \"/> <polyline clip-path=\"url(#clip012)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"147.478,89.2432 2352.76,89.2432 \"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,1423.18 2352.76,1423.18 \"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"209.891,1423.18 209.891,1404.28 \"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"730.004,1423.18 730.004,1404.28 \"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1250.12,1423.18 1250.12,1404.28 \"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1770.23,1423.18 1770.23,1404.28 \"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"2290.34,1423.18 2290.34,1404.28 \"/> <path clip-path=\"url(#clip010)\" d=\"M209.891 1454.1 Q206.28 1454.1 204.452 1457.66 Q202.646 1461.2 202.646 1468.33 Q202.646 1475.44 204.452 1479.01 Q206.28 1482.55 209.891 1482.55 Q213.526 1482.55 215.331 1479.01 Q217.16 1475.44 217.16 1468.33 Q217.16 1461.2 215.331 1457.66 Q213.526 1454.1 209.891 1454.1 M209.891 1450.39 Q215.702 1450.39 218.757 1455 Q221.836 1459.58 221.836 1468.33 Q221.836 1477.06 218.757 1481.67 Q215.702 1486.25 209.891 1486.25 Q204.081 1486.25 201.003 1481.67 Q197.947 1477.06 197.947 1468.33 Q197.947 1459.58 201.003 1455 Q204.081 1450.39 209.891 1450.39 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M724.657 1481.64 L740.976 1481.64 L740.976 1485.58 L719.032 1485.58 L719.032 1481.64 Q721.694 1478.89 726.277 1474.26 Q730.884 1469.61 732.064 1468.27 Q734.31 1465.74 735.189 1464.01 Q736.092 1462.25 736.092 1460.56 Q736.092 1457.8 734.148 1456.07 Q732.226 1454.33 729.125 1454.33 Q726.925 1454.33 724.472 1455.09 Q722.041 1455.86 719.263 1457.41 L719.263 1452.69 Q722.088 1451.55 724.541 1450.97 Q726.995 1450.39 729.032 1450.39 Q734.402 1450.39 737.597 1453.08 Q740.791 1455.77 740.791 1460.26 Q740.791 1462.39 739.981 1464.31 Q739.194 1466.2 737.087 1468.8 Q736.509 1469.47 733.407 1472.69 Q730.305 1475.88 724.657 1481.64 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M1253.13 1455.09 L1241.32 1473.54 L1253.13 1473.54 L1253.13 1455.09 M1251.9 1451.02 L1257.78 1451.02 L1257.78 1473.54 L1262.71 1473.54 L1262.71 1477.43 L1257.78 1477.43 L1257.78 1485.58 L1253.13 1485.58 L1253.13 1477.43 L1237.52 1477.43 L1237.52 1472.92 L1251.9 1451.02 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M1770.63 1466.44 Q1767.49 1466.44 1765.63 1468.59 Q1763.81 1470.74 1763.81 1474.49 Q1763.81 1478.22 1765.63 1480.39 Q1767.49 1482.55 1770.63 1482.55 Q1773.78 1482.55 1775.61 1480.39 Q1777.46 1478.22 1777.46 1474.49 Q1777.46 1470.74 1775.61 1468.59 Q1773.78 1466.44 1770.63 1466.44 M1779.92 1451.78 L1779.92 1456.04 Q1778.16 1455.21 1776.35 1454.77 Q1774.57 1454.33 1772.81 1454.33 Q1768.18 1454.33 1765.73 1457.45 Q1763.3 1460.58 1762.95 1466.9 Q1764.32 1464.89 1766.38 1463.82 Q1768.44 1462.73 1770.91 1462.73 Q1776.12 1462.73 1779.13 1465.9 Q1782.16 1469.05 1782.16 1474.49 Q1782.16 1479.82 1779.01 1483.03 Q1775.87 1486.25 1770.63 1486.25 Q1764.64 1486.25 1761.47 1481.67 Q1758.3 1477.06 1758.3 1468.33 Q1758.3 1460.14 1762.19 1455.28 Q1766.07 1450.39 1772.63 1450.39 Q1774.38 1450.39 1776.17 1450.74 Q1777.97 1451.09 1779.92 1451.78 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M2290.34 1469.17 Q2287.01 1469.17 2285.09 1470.95 Q2283.19 1472.73 2283.19 1475.86 Q2283.19 1478.98 2285.09 1480.77 Q2287.01 1482.55 2290.34 1482.55 Q2293.68 1482.55 2295.6 1480.77 Q2297.52 1478.96 2297.52 1475.86 Q2297.52 1472.73 2295.6 1470.95 Q2293.7 1469.17 2290.34 1469.17 M2285.67 1467.18 Q2282.66 1466.44 2280.97 1464.38 Q2279.3 1462.32 2279.3 1459.35 Q2279.3 1455.21 2282.24 1452.8 Q2285.2 1450.39 2290.34 1450.39 Q2295.5 1450.39 2298.44 1452.8 Q2301.38 1455.21 2301.38 1459.35 Q2301.38 1462.32 2299.69 1464.38 Q2298.03 1466.44 2295.04 1467.18 Q2298.42 1467.96 2300.3 1470.26 Q2302.19 1472.55 2302.19 1475.86 Q2302.19 1480.88 2299.12 1483.57 Q2296.06 1486.25 2290.34 1486.25 Q2284.62 1486.25 2281.55 1483.57 Q2278.49 1480.88 2278.49 1475.86 Q2278.49 1472.55 2280.39 1470.26 Q2282.29 1467.96 2285.67 1467.18 M2283.95 1459.79 Q2283.95 1462.48 2285.62 1463.98 Q2287.31 1465.49 2290.34 1465.49 Q2293.35 1465.49 2295.04 1463.98 Q2296.75 1462.48 2296.75 1459.79 Q2296.75 1457.11 2295.04 1455.6 Q2293.35 1454.1 2290.34 1454.1 Q2287.31 1454.1 2285.62 1455.6 Q2283.95 1457.11 2283.95 1459.79 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M1198.43 1522.27 L1198.43 1532.4 L1210.49 1532.4 L1210.49 1536.95 L1198.43 1536.95 L1198.43 1556.3 Q1198.43 1560.66 1199.61 1561.9 Q1200.81 1563.14 1204.47 1563.14 L1210.49 1563.14 L1210.49 1568.04 L1204.47 1568.04 Q1197.7 1568.04 1195.12 1565.53 Q1192.54 1562.98 1192.54 1556.3 L1192.54 1536.95 L1188.24 1536.95 L1188.24 1532.4 L1192.54 1532.4 L1192.54 1522.27 L1198.43 1522.27 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M1238.37 1518.52 L1251.87 1518.52 L1251.87 1523.07 L1244.23 1523.07 L1244.23 1572.09 L1251.87 1572.09 L1251.87 1576.64 L1238.37 1576.64 L1238.37 1518.52 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M1287.07 1533.45 L1287.07 1538.98 Q1284.59 1537.71 1281.91 1537.07 Q1279.24 1536.44 1276.38 1536.44 Q1272.01 1536.44 1269.82 1537.77 Q1267.65 1539.11 1267.65 1541.79 Q1267.65 1543.82 1269.21 1545 Q1270.77 1546.15 1275.48 1547.2 L1277.49 1547.64 Q1283.73 1548.98 1286.34 1551.43 Q1288.98 1553.85 1288.98 1558.21 Q1288.98 1563.17 1285.03 1566.07 Q1281.12 1568.97 1274.24 1568.97 Q1271.38 1568.97 1268.26 1568.39 Q1265.17 1567.85 1261.73 1566.74 L1261.73 1560.69 Q1264.98 1562.38 1268.13 1563.24 Q1271.28 1564.07 1274.37 1564.07 Q1278.51 1564.07 1280.74 1562.66 Q1282.96 1561.23 1282.96 1558.65 Q1282.96 1556.27 1281.34 1554.99 Q1279.75 1553.72 1274.31 1552.54 L1272.27 1552.07 Q1266.83 1550.92 1264.41 1548.56 Q1261.99 1546.18 1261.99 1542.04 Q1261.99 1537.01 1265.55 1534.27 Q1269.12 1531.54 1275.68 1531.54 Q1278.92 1531.54 1281.79 1532.01 Q1284.65 1532.49 1287.07 1533.45 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M1311.99 1518.52 L1311.99 1576.64 L1298.5 1576.64 L1298.5 1572.09 L1306.1 1572.09 L1306.1 1523.07 L1298.5 1523.07 L1298.5 1518.52 L1311.99 1518.52 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,1423.18 147.478,47.2441 \"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,1382.7 166.376,1382.7 \"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,1059.34 166.376,1059.34 \"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,735.972 166.376,735.972 \"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,412.608 166.376,412.608 \"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,89.2432 166.376,89.2432 \"/> <path clip-path=\"url(#clip010)\" d=\"M51.3625 1383.15 L81.0383 1383.15 L81.0383 1387.09 L51.3625 1387.09 L51.3625 1383.15 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M95.1586 1396.05 L111.478 1396.05 L111.478 1399.98 L89.5336 1399.98 L89.5336 1396.05 Q92.1956 1393.29 96.7789 1388.66 Q101.385 1384.01 102.566 1382.67 Q104.811 1380.14 105.691 1378.41 Q106.594 1376.65 106.594 1374.96 Q106.594 1372.2 104.649 1370.47 Q102.728 1368.73 99.6261 1368.73 Q97.4271 1368.73 94.9734 1369.5 Q92.5428 1370.26 89.7651 1371.81 L89.7651 1367.09 Q92.5891 1365.95 95.0428 1365.37 Q97.4965 1364.8 99.5335 1364.8 Q104.904 1364.8 108.098 1367.48 Q111.293 1370.17 111.293 1374.66 Q111.293 1376.79 110.483 1378.71 Q109.696 1380.61 107.589 1383.2 Q107.01 1383.87 103.909 1387.09 Q100.807 1390.28 95.1586 1396.05 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M50.9921 1059.79 L80.6679 1059.79 L80.6679 1063.72 L50.9921 1063.72 L50.9921 1059.79 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M91.5706 1072.68 L99.2095 1072.68 L99.2095 1046.32 L90.8993 1047.98 L90.8993 1043.72 L99.1632 1042.06 L103.839 1042.06 L103.839 1072.68 L111.478 1072.68 L111.478 1076.62 L91.5706 1076.62 L91.5706 1072.68 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M99.5335 721.771 Q95.9224 721.771 94.0937 725.336 Q92.2882 728.877 92.2882 736.007 Q92.2882 743.113 94.0937 746.678 Q95.9224 750.22 99.5335 750.22 Q103.168 750.22 104.973 746.678 Q106.802 743.113 106.802 736.007 Q106.802 728.877 104.973 725.336 Q103.168 721.771 99.5335 721.771 M99.5335 718.067 Q105.344 718.067 108.399 722.674 Q111.478 727.257 111.478 736.007 Q111.478 744.734 108.399 749.34 Q105.344 753.923 99.5335 753.923 Q93.7234 753.923 90.6447 749.34 Q87.5892 744.734 87.5892 736.007 Q87.5892 727.257 90.6447 722.674 Q93.7234 718.067 99.5335 718.067 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M91.5706 425.952 L99.2095 425.952 L99.2095 399.587 L90.8993 401.254 L90.8993 396.994 L99.1632 395.328 L103.839 395.328 L103.839 425.952 L111.478 425.952 L111.478 429.888 L91.5706 429.888 L91.5706 425.952 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M95.1586 102.588 L111.478 102.588 L111.478 106.523 L89.5336 106.523 L89.5336 102.588 Q92.1956 99.8334 96.7789 95.2038 Q101.385 90.551 102.566 89.2084 Q104.811 86.6853 105.691 84.9492 Q106.594 83.19 106.594 81.5002 Q106.594 78.7455 104.649 77.0094 Q102.728 75.2733 99.6261 75.2733 Q97.4271 75.2733 94.9734 76.0372 Q92.5428 76.8011 89.7651 78.352 L89.7651 73.6298 Q92.5891 72.4956 95.0428 71.9169 Q97.4965 71.3382 99.5335 71.3382 Q104.904 71.3382 108.098 74.0233 Q111.293 76.7085 111.293 81.1992 Q111.293 83.3288 110.483 85.2501 Q109.696 87.1483 107.589 89.7408 Q107.01 90.4121 103.909 93.6297 Q100.807 96.8241 95.1586 102.588 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><polyline clip-path=\"url(#clip012)\" style=\"stroke:#009af9; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"209.891,574.29 212.492,574.193 215.093,573.901 217.693,573.416 220.294,572.736 222.894,571.863 225.495,570.796 228.095,569.537 230.696,568.087 233.297,566.446 235.897,564.616 238.498,562.598 241.098,560.395 243.699,558.008 246.299,555.438 248.9,552.689 251.5,549.763 254.101,546.662 256.702,543.39 259.302,539.948 261.903,536.341 264.503,532.571 267.104,528.642 269.704,524.558 272.305,520.322 274.906,515.938 277.506,511.411 280.107,506.744 282.707,501.942 285.308,497.01 287.908,491.952 290.509,486.772 293.109,481.476 295.71,476.069 298.311,470.555 300.911,464.94 303.512,459.23 306.112,453.429 308.713,447.544 311.313,441.579 313.914,435.54 316.515,429.434 319.115,423.266 321.716,417.041 324.316,410.766 326.917,404.447 329.517,398.09 332.118,391.701 334.718,385.285 337.319,378.85 339.92,372.4 342.52,365.943 345.121,359.485 347.721,353.031 350.322,346.589 352.922,340.163 355.523,333.761 358.124,327.387 360.724,321.05 363.325,314.753 365.925,308.505 368.526,302.31 371.126,296.174 373.727,290.103 376.328,284.104 378.928,278.182 381.529,272.342 384.129,266.59 386.73,260.931 389.33,255.372 391.931,249.917 394.531,244.572 397.132,239.341 399.733,234.229 402.333,229.243 404.934,224.385 407.534,219.661 410.135,215.076 412.735,210.633 415.336,206.337 417.937,202.192 420.537,198.202 423.138,194.371 425.738,190.702 428.339,187.198 430.939,183.864 433.54,180.701 436.14,177.714 438.741,174.904 441.342,172.275 443.942,169.829 446.543,167.568 449.143,165.494 451.744,163.609 454.344,161.915 456.945,160.413 459.546,159.104 462.146,157.991 464.747,157.072 467.347,156.35 469.948,155.825 472.548,155.498 475.149,155.367 477.749,155.434 480.35,155.698 482.951,156.159 485.551,156.816 488.152,157.668 490.752,158.714 493.353,159.953 495.953,161.384 498.554,163.005 501.155,164.814 503.755,166.809 506.356,168.989 508.956,171.351 511.557,173.892 514.157,176.609 516.758,179.501 519.359,182.563 521.959,185.794 524.56,189.188 527.16,192.743 529.761,196.456 532.361,200.321 534.962,204.336 537.562,208.497 540.163,212.798 542.764,217.236 545.364,221.806 547.965,226.503 550.565,231.323 553.166,236.261 555.766,241.311 558.367,246.469 560.968,251.729 563.568,257.086 566.169,262.535 568.769,268.069 571.37,273.685 573.97,279.375 576.571,285.134 579.171,290.956 581.772,296.835 584.373,302.766 586.973,308.743 589.574,314.758 592.174,320.808 594.775,326.884 597.375,332.982 599.976,339.094 602.577,345.216 605.177,351.34 607.778,357.461 610.378,363.573 612.979,369.669 615.579,375.743 618.18,381.789 620.781,387.802 623.381,393.775 625.982,399.702 628.582,405.577 631.183,411.394 633.783,417.148 636.384,422.833 638.984,428.443 641.585,433.973 644.186,439.417 646.786,444.769 649.387,450.025 651.987,455.179 654.588,460.226 657.188,465.161 659.789,469.979 662.39,474.676 664.99,479.246 667.591,483.686 670.191,487.99 672.792,492.155 675.392,496.177 677.993,500.051 680.593,503.773 683.194,507.341 685.795,510.751 688.395,513.998 690.996,517.081 693.596,519.996 696.197,522.74 698.797,525.311 701.398,527.706 703.999,529.923 706.599,531.96 709.2,533.815 711.8,535.485 714.401,536.97 717.001,538.269 719.602,539.379 722.202,540.3 724.803,541.032 727.404,541.573 730.004,541.923 732.605,542.082 735.205,542.051 737.806,541.828 740.406,541.415 743.007,540.811 745.608,540.019 748.208,539.038 750.809,537.87 753.409,536.517 756.01,534.979 758.61,533.258 761.211,531.357 763.812,529.277 766.412,527.02 769.013,524.59 771.613,521.988 774.214,519.218 776.814,516.282 779.415,513.184 782.015,509.926 784.616,506.513 787.217,502.947 789.817,499.233 792.418,495.374 795.018,491.375 797.619,487.24 800.219,482.973 802.82,478.578 805.421,474.061 808.021,469.425 810.622,464.676 813.222,459.819 815.823,454.859 818.423,449.8 821.024,444.649 823.624,439.411 826.225,434.09 828.826,428.693 831.426,423.226 834.027,417.693 836.627,412.102 839.228,406.456 841.828,400.764 844.429,395.029 847.03,389.259 849.63,383.46 852.231,377.636 854.831,371.796 857.432,365.944 860.032,360.086 862.633,354.23 865.233,348.38 867.834,342.544 870.435,336.727 873.035,330.934 875.636,325.174 878.236,319.45 880.837,313.77 883.437,308.139 886.038,302.564 888.639,297.049 891.239,291.601 893.84,286.226 896.44,280.929 899.041,275.715 901.641,270.591 904.242,265.562 906.843,260.633 909.443,255.809 912.044,251.095 914.644,246.497 917.245,242.019 919.845,237.666 922.446,233.442 925.046,229.353 927.647,225.402 930.248,221.594 932.848,217.933 935.449,214.423 938.049,211.068 940.65,207.871 943.25,204.836 945.851,201.966 948.452,199.264 951.052,196.734 953.653,194.378 956.253,192.199 958.854,190.199 961.454,188.381 964.055,186.747 966.655,185.298 969.256,184.038 971.857,182.966 974.457,182.084 977.058,181.395 979.658,180.898 982.259,180.595 984.859,180.485 987.46,180.571 990.061,180.851 992.661,181.326 995.262,181.996 997.862,182.86 1000.46,183.917 1003.06,185.168 1005.66,186.611 1008.26,188.245 1010.87,190.069 1013.47,192.081 1016.07,194.279 1018.67,196.662 1021.27,199.228 1023.87,201.974 1026.47,204.898 1029.07,207.997 1031.67,211.269 1034.27,214.71 1036.87,218.318 1039.47,222.089 1042.07,226.019 1044.67,230.106 1047.27,234.345 1049.87,238.733 1052.47,243.265 1055.07,247.937 1057.68,252.745 1060.28,257.684 1062.88,262.75 1065.48,267.938 1068.08,273.243 1070.68,278.66 1073.28,284.185 1075.88,289.811 1078.48,295.533 1081.08,301.347 1083.68,307.246 1086.28,313.226 1088.88,319.279 1091.48,325.401 1094.08,331.587 1096.68,337.829 1099.28,344.122 1101.88,350.46 1104.49,356.837 1107.09,363.247 1109.69,369.684 1112.29,376.141 1114.89,382.613 1117.49,389.094 1120.09,395.577 1122.69,402.055 1125.29,408.524 1127.89,414.976 1130.49,421.406 1133.09,427.808 1135.69,434.174 1138.29,440.5 1140.89,446.779 1143.49,453.005 1146.09,459.173 1148.69,465.276 1151.3,471.308 1153.9,477.265 1156.5,483.14 1159.1,488.927 1161.7,494.621 1164.3,500.217 1166.9,505.709 1169.5,511.093 1172.1,516.362 1174.7,521.513 1177.3,526.54 1179.9,531.438 1182.5,536.203 1185.1,540.83 1187.7,545.315 1190.3,549.654 1192.9,553.843 1195.51,557.877 1198.11,561.753 1200.71,565.468 1203.31,569.017 1205.91,572.398 1208.51,575.608 1211.11,578.643 1213.71,581.5 1216.31,584.178 1218.91,586.673 1221.51,588.983 1224.11,591.107 1226.71,593.043 1229.31,594.788 1231.91,596.341 1234.51,597.701 1237.11,598.867 1239.71,599.838 1242.32,600.613 1244.92,601.191 1247.52,601.572 1250.12,601.757 1252.72,601.744 1255.32,601.535 1257.92,601.129 1260.52,600.527 1263.12,599.731 1265.72,598.74 1268.32,597.557 1270.92,596.183 1273.52,594.618 1276.12,592.866 1278.72,590.927 1281.32,588.805 1283.92,586.501 1286.52,584.017 1289.13,581.357 1291.73,578.524 1294.33,575.519 1296.93,572.347 1299.53,569.011 1302.13,565.514 1304.73,561.86 1307.33,558.053 1309.93,554.097 1312.53,549.995 1315.13,545.753 1317.73,541.374 1320.33,536.863 1322.93,532.225 1325.53,527.464 1328.13,522.585 1330.73,517.594 1333.33,512.495 1335.94,507.293 1338.54,501.995 1341.14,496.605 1343.74,491.129 1346.34,485.573 1348.94,479.942 1351.54,474.241 1354.14,468.478 1356.74,462.657 1359.34,456.784 1361.94,450.866 1364.54,444.908 1367.14,438.917 1369.74,432.898 1372.34,426.859 1374.94,420.803 1377.54,414.739 1380.15,408.672 1382.75,402.608 1385.35,396.554 1387.95,390.515 1390.55,384.497 1393.15,378.507 1395.75,372.551 1398.35,366.634 1400.95,360.764 1403.55,354.944 1406.15,349.182 1408.75,343.484 1411.35,337.854 1413.95,332.299 1416.55,326.824 1419.15,321.434 1421.75,316.136 1424.35,310.934 1426.96,305.834 1429.56,300.841 1432.16,295.959 1434.76,291.194 1437.36,286.551 1439.96,282.033 1442.56,277.646 1445.16,273.394 1447.76,269.281 1450.36,265.312 1452.96,261.489 1455.56,257.818 1458.16,254.301 1460.76,250.943 1463.36,247.746 1465.96,244.714 1468.56,241.849 1471.16,239.155 1473.77,236.634 1476.37,234.288 1478.97,232.121 1481.57,230.133 1484.17,228.328 1486.77,226.706 1489.37,225.269 1491.97,224.019 1494.57,222.957 1497.17,222.084 1499.77,221.4 1502.37,220.906 1504.97,220.603 1507.57,220.491 1510.17,220.57 1512.77,220.839 1515.37,221.299 1517.97,221.949 1520.58,222.787 1523.18,223.814 1525.78,225.027 1528.38,226.427 1530.98,228.01 1533.58,229.776 1536.18,231.722 1538.78,233.847 1541.38,236.148 1543.98,238.623 1546.58,241.269 1549.18,244.083 1551.78,247.063 1554.38,250.205 1556.98,253.506 1559.58,256.963 1562.18,260.572 1564.79,264.329 1567.39,268.231 1569.99,272.273 1572.59,276.451 1575.19,280.76 1577.79,285.197 1580.39,289.757 1582.99,294.434 1585.59,299.225 1588.19,304.124 1590.79,309.125 1593.39,314.225 1595.99,319.417 1598.59,324.697 1601.19,330.058 1603.79,335.495 1606.39,341.003 1608.99,346.576 1611.6,352.208 1614.2,357.893 1616.8,363.626 1619.4,369.399 1622,375.209 1624.6,381.048 1627.2,386.91 1629.8,392.789 1632.4,398.68 1635,404.576 1637.6,410.47 1640.2,416.358 1642.8,422.232 1645.4,428.087 1648,433.916 1650.6,439.714 1653.2,445.475 1655.8,451.191 1658.41,456.859 1661.01,462.47 1663.61,468.021 1666.21,473.505 1668.81,478.915 1671.41,484.247 1674.01,489.495 1676.61,494.654 1679.21,499.718 1681.81,504.681 1684.41,509.539 1687.01,514.286 1689.61,518.917 1692.21,523.428 1694.81,527.813 1697.41,532.069 1700.01,536.19 1702.61,540.172 1705.22,544.011 1707.82,547.703 1710.42,551.243 1713.02,554.628 1715.62,557.855 1718.22,560.919 1720.82,563.818 1723.42,566.548 1726.02,569.106 1728.62,571.489 1731.22,573.695 1733.82,575.721 1736.42,577.565 1739.02,579.225 1741.62,580.699 1744.22,581.984 1746.82,583.08 1749.43,583.985 1752.03,584.697 1754.63,585.217 1757.23,585.542 1759.83,585.673 1762.43,585.609 1765.03,585.349 1767.63,584.894 1770.23,584.243 1772.83,583.398 1775.43,582.358 1778.03,581.125 1780.63,579.699 1783.23,578.081 1785.83,576.273 1788.43,574.276 1791.03,572.092 1793.63,569.722 1796.24,567.17 1798.84,564.436 1801.44,561.524 1804.04,558.436 1806.64,555.175 1809.24,551.743 1811.84,548.144 1814.44,544.382 1817.04,540.459 1819.64,536.379 1822.24,532.146 1824.84,527.763 1827.44,523.236 1830.04,518.568 1832.64,513.763 1835.24,508.826 1837.84,503.762 1840.44,498.575 1843.05,493.27 1845.65,487.852 1848.25,482.326 1850.85,476.698 1853.45,470.972 1856.05,465.155 1858.65,459.251 1861.25,453.267 1863.85,447.207 1866.45,441.078 1869.05,434.885 1871.65,428.634 1874.25,422.332 1876.85,415.984 1879.45,409.596 1882.05,403.174 1884.65,396.725 1887.26,390.254 1889.86,383.768 1892.46,377.273 1895.06,370.775 1897.66,364.279 1900.26,357.794 1902.86,351.323 1905.46,344.875 1908.06,338.454 1910.66,332.067 1913.26,325.72 1915.86,319.419 1918.46,313.17 1921.06,306.979 1923.66,300.852 1926.26,294.795 1928.86,288.813 1931.46,282.912 1934.07,277.097 1936.67,271.375 1939.27,265.751 1941.87,260.229 1944.47,254.816 1947.07,249.515 1949.67,244.333 1952.27,239.274 1954.87,234.343 1957.47,229.545 1960.07,224.884 1962.67,220.364 1965.27,215.989 1967.87,211.765 1970.47,207.694 1973.07,203.78 1975.67,200.027 1978.27,196.44 1980.88,193.019 1983.48,189.77 1986.08,186.695 1988.68,183.797 1991.28,181.077 1993.88,178.54 1996.48,176.187 1999.08,174.02 2001.68,172.041 2004.28,170.252 2006.88,168.654 2009.48,167.249 2012.08,166.037 2014.68,165.02 2017.28,164.199 2019.88,163.574 2022.48,163.145 2025.08,162.913 2027.69,162.877 2030.29,163.038 2032.89,163.395 2035.49,163.947 2038.09,164.694 2040.69,165.634 2043.29,166.767 2045.89,168.091 2048.49,169.604 2051.09,171.305 2053.69,173.192 2056.29,175.263 2058.89,177.515 2061.49,179.946 2064.09,182.553 2066.69,185.333 2069.29,188.285 2071.9,191.403 2074.5,194.686 2077.1,198.129 2079.7,201.729 2082.3,205.482 2084.9,209.384 2087.5,213.431 2090.1,217.619 2092.7,221.943 2095.3,226.399 2097.9,230.983 2100.5,235.689 2103.1,240.512 2105.7,245.448 2108.3,250.492 2110.9,255.637 2113.5,260.88 2116.1,266.215 2118.71,271.635 2121.31,277.136 2123.91,282.712 2126.51,288.356 2129.11,294.064 2131.71,299.83 2134.31,305.647 2136.91,311.509 2139.51,317.412 2142.11,323.347 2144.71,329.31 2147.31,335.295 2149.91,341.294 2152.51,347.303 2155.11,353.315 2157.71,359.324 2160.31,365.323 2162.91,371.307 2165.52,377.269 2168.12,383.204 2170.72,389.106 2173.32,394.968 2175.92,400.784 2178.52,406.549 2181.12,412.256 2183.72,417.901 2186.32,423.476 2188.92,428.977 2191.52,434.398 2194.12,439.733 2196.72,444.978 2199.32,450.126 2201.92,455.172 2204.52,460.112 2207.12,464.941 2209.72,469.653 2212.33,474.243 2214.93,478.708 2217.53,483.042 2220.13,487.241 2222.73,491.302 2225.33,495.219 2227.93,498.989 2230.53,502.608 2233.13,506.073 2235.73,509.38 2238.33,512.525 2240.93,515.506 2243.53,518.319 2246.13,520.962 2248.73,523.432 2251.33,525.726 2253.93,527.843 2256.54,529.779 2259.14,531.534 2261.74,533.106 2264.34,534.492 2266.94,535.692 2269.54,536.704 2272.14,537.527 2274.74,538.161 2277.34,538.604 2279.94,538.858 2282.54,538.92 2285.14,538.792 2287.74,538.473 2290.34,537.964 \"/> <polyline clip-path=\"url(#clip012)\" style=\"stroke:#e26f46; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"209.891,735.972 212.492,716.557 215.093,697.13 217.693,677.708 220.294,658.313 222.894,638.963 225.495,619.678 228.095,600.477 230.696,581.379 233.297,562.403 235.897,543.569 238.498,524.895 241.098,506.4 243.699,488.102 246.299,470.02 248.9,452.172 251.5,434.576 254.101,417.249 256.702,400.209 259.302,383.473 261.903,367.058 264.503,350.98 267.104,335.255 269.704,319.9 272.305,304.929 274.906,290.357 277.506,276.2 280.107,262.471 282.707,249.185 285.308,236.354 287.908,223.992 290.509,212.111 293.109,200.723 295.71,189.839 298.311,179.471 300.911,169.629 303.512,160.323 306.112,151.562 308.713,143.356 311.313,135.712 313.914,128.638 316.515,122.142 319.115,116.229 321.716,110.907 324.316,106.181 326.917,102.055 329.517,98.5342 332.118,95.6215 334.718,93.3202 337.319,91.6329 339.92,90.5614 342.52,90.1068 345.121,90.2698 347.721,91.0505 350.322,92.448 352.922,94.4614 355.523,97.0886 358.124,100.327 360.724,104.174 363.325,108.626 365.925,113.678 368.526,119.326 371.126,125.564 373.727,132.385 376.328,139.785 378.928,147.754 381.529,156.286 384.129,165.372 386.73,175.003 389.33,185.17 391.931,195.863 394.531,207.071 397.132,218.783 399.733,230.989 402.333,243.675 404.934,256.829 407.534,270.439 410.135,284.491 412.735,298.972 415.336,313.866 417.937,329.159 420.537,344.837 423.138,360.884 425.738,377.283 428.339,394.02 430.939,411.077 433.54,428.437 436.14,446.084 438.741,463.999 441.342,482.166 443.942,500.567 446.543,519.183 449.143,537.996 451.744,556.987 454.344,576.137 456.945,595.429 459.546,614.842 462.146,634.358 464.747,653.957 467.347,673.62 469.948,693.328 472.548,713.061 475.149,732.799 477.749,752.524 480.35,772.216 482.951,791.855 485.551,811.422 488.152,830.898 490.752,850.263 493.353,869.499 495.953,888.586 498.554,907.507 501.155,926.241 503.755,944.771 506.356,963.078 508.956,981.145 511.557,998.953 514.157,1016.49 516.758,1033.73 519.359,1050.65 521.959,1067.26 524.56,1083.52 527.16,1099.42 529.761,1114.94 532.361,1130.08 534.962,1144.81 537.562,1159.13 540.163,1173.01 542.764,1186.44 545.364,1199.41 547.965,1211.91 550.565,1223.93 553.166,1235.45 555.766,1246.46 558.367,1256.96 560.968,1266.92 563.568,1276.35 566.169,1285.23 568.769,1293.56 571.37,1301.32 573.97,1308.51 576.571,1315.13 579.171,1321.16 581.772,1326.59 584.373,1331.44 586.973,1335.68 589.574,1339.32 592.174,1342.36 594.775,1344.78 597.375,1346.59 599.976,1347.79 602.577,1348.38 605.177,1348.35 607.778,1347.7 610.378,1346.45 612.979,1344.58 615.579,1342.1 618.18,1339.02 620.781,1335.33 623.381,1331.05 625.982,1326.17 628.582,1320.7 631.183,1314.65 633.783,1308.02 636.384,1300.82 638.984,1293.06 641.585,1284.74 644.186,1275.88 646.786,1266.48 649.387,1256.55 651.987,1246.11 654.588,1235.16 657.188,1223.72 659.789,1211.79 662.39,1199.39 664.99,1186.54 667.591,1173.24 670.191,1159.51 672.792,1145.36 675.392,1130.81 677.993,1115.87 680.593,1100.56 683.194,1084.89 685.795,1068.89 688.395,1052.55 690.996,1035.91 693.596,1018.98 696.197,1001.77 698.797,984.311 701.398,966.611 703.999,948.69 706.599,930.566 709.2,912.259 711.8,893.787 714.401,875.168 717.001,856.422 719.602,837.567 722.202,818.623 724.803,799.609 727.404,780.544 730.004,761.448 732.605,742.339 735.205,723.238 737.806,704.164 740.406,685.136 743.007,666.174 745.608,647.296 748.208,628.522 750.809,609.871 753.409,591.361 756.01,573.013 758.61,554.843 761.211,536.872 763.812,519.116 766.412,501.594 769.013,484.325 771.613,467.324 774.214,450.61 776.814,434.2 779.415,418.11 782.015,402.356 784.616,386.955 787.217,371.922 789.817,357.273 792.418,343.023 795.018,329.185 797.619,315.775 800.219,302.805 802.82,290.289 805.421,278.24 808.021,266.669 810.622,255.59 813.222,245.013 815.823,234.948 818.423,225.407 821.024,216.399 823.624,207.933 826.225,200.018 828.826,192.663 831.426,185.874 834.027,179.658 836.627,174.023 839.228,168.973 841.828,164.515 844.429,160.653 847.03,157.391 849.63,154.732 852.231,152.679 854.831,151.235 857.432,150.401 860.032,150.179 862.633,150.568 865.233,151.568 867.834,153.18 870.435,155.4 873.035,158.227 875.636,161.66 878.236,165.693 880.837,170.324 883.437,175.548 886.038,181.359 888.639,187.753 891.239,194.723 893.84,202.262 896.44,210.364 899.041,219.019 901.641,228.219 904.242,237.956 906.843,248.219 909.443,259 912.044,270.286 914.644,282.067 917.245,294.331 919.845,307.067 922.446,320.261 925.046,333.9 927.647,347.972 930.248,362.461 932.848,377.354 935.449,392.636 938.049,408.291 940.65,424.305 943.25,440.66 945.851,457.342 948.452,474.333 951.052,491.617 953.653,509.176 956.253,526.993 958.854,545.049 961.454,563.328 964.055,581.811 966.655,600.48 969.256,619.315 971.857,638.299 974.457,657.412 977.058,676.635 979.658,695.949 982.259,715.335 984.859,734.774 987.46,754.245 990.061,773.731 992.661,793.21 995.262,812.664 997.862,832.074 1000.46,851.42 1003.06,870.683 1005.66,889.843 1008.26,908.881 1010.87,927.779 1013.47,946.517 1016.07,965.077 1018.67,983.441 1021.27,1001.59 1023.87,1019.5 1026.47,1037.17 1029.07,1054.56 1031.67,1071.67 1034.27,1088.48 1036.87,1104.96 1039.47,1121.11 1042.07,1136.91 1044.67,1152.33 1047.27,1167.38 1049.87,1182.02 1052.47,1196.25 1055.07,1210.05 1057.68,1223.41 1060.28,1236.32 1062.88,1248.75 1065.48,1260.71 1068.08,1272.17 1070.68,1283.13 1073.28,1293.57 1075.88,1303.49 1078.48,1312.87 1081.08,1321.71 1083.68,1329.99 1086.28,1337.71 1088.88,1344.87 1091.48,1351.44 1094.08,1357.43 1096.68,1362.83 1099.28,1367.63 1101.88,1371.83 1104.49,1375.43 1107.09,1378.42 1109.69,1380.8 1112.29,1382.56 1114.89,1383.71 1117.49,1384.24 1120.09,1384.15 1122.69,1383.45 1125.29,1382.12 1127.89,1380.19 1130.49,1377.63 1133.09,1374.47 1135.69,1370.69 1138.29,1366.32 1140.89,1361.34 1143.49,1355.76 1146.09,1349.6 1148.69,1342.85 1151.3,1335.52 1153.9,1327.62 1156.5,1319.16 1159.1,1310.14 1161.7,1300.58 1164.3,1290.48 1166.9,1279.85 1169.5,1268.71 1172.1,1257.06 1174.7,1244.92 1177.3,1232.3 1179.9,1219.21 1182.5,1205.66 1185.1,1191.67 1187.7,1177.25 1190.3,1162.41 1192.9,1147.18 1195.51,1131.56 1198.11,1115.57 1200.71,1099.22 1203.31,1082.54 1205.91,1065.54 1208.51,1048.23 1211.11,1030.64 1213.71,1012.77 1216.31,994.653 1218.91,976.301 1221.51,957.732 1224.11,938.965 1226.71,920.019 1229.31,900.912 1231.91,881.663 1234.51,862.291 1237.11,842.815 1239.71,823.255 1242.32,803.63 1244.92,783.959 1247.52,764.261 1250.12,744.557 1252.72,724.865 1255.32,705.205 1257.92,685.597 1260.52,666.059 1263.12,646.612 1265.72,627.274 1268.32,608.063 1270.92,589.001 1273.52,570.104 1276.12,551.392 1278.72,532.883 1281.32,514.596 1283.92,496.548 1286.52,478.757 1289.13,461.241 1291.73,444.017 1294.33,427.101 1296.93,410.512 1299.53,394.264 1302.13,378.374 1304.73,362.857 1307.33,347.729 1309.93,333.004 1312.53,318.698 1315.13,304.823 1317.73,291.394 1320.33,278.424 1322.93,265.925 1325.53,253.909 1328.13,242.389 1330.73,231.375 1333.33,220.878 1335.94,210.909 1338.54,201.477 1341.14,192.592 1343.74,184.261 1346.34,176.492 1348.94,169.294 1351.54,162.674 1354.14,156.637 1356.74,151.189 1359.34,146.335 1361.94,142.08 1364.54,138.428 1367.14,135.383 1369.74,132.946 1372.34,131.12 1374.94,129.907 1377.54,129.307 1380.15,129.321 1382.75,129.949 1385.35,131.189 1387.95,133.04 1390.55,135.499 1393.15,138.565 1395.75,142.233 1398.35,146.5 1400.95,151.361 1403.55,156.81 1406.15,162.843 1408.75,169.452 1411.35,176.631 1413.95,184.373 1416.55,192.669 1419.15,201.51 1421.75,210.887 1424.35,220.792 1426.96,231.213 1429.56,242.139 1432.16,253.561 1434.76,265.465 1437.36,277.839 1439.96,290.671 1442.56,303.949 1445.16,317.657 1447.76,331.782 1450.36,346.31 1452.96,361.225 1455.56,376.513 1458.16,392.159 1460.76,408.145 1463.36,424.455 1465.96,441.074 1468.56,457.984 1471.16,475.167 1473.77,492.607 1476.37,510.286 1478.97,528.185 1481.57,546.286 1484.17,564.572 1486.77,583.023 1489.37,601.62 1491.97,620.345 1494.57,639.179 1497.17,658.102 1499.77,677.096 1502.37,696.14 1504.97,715.216 1507.57,734.304 1510.17,753.385 1512.77,772.44 1515.37,791.448 1517.97,810.391 1520.58,829.25 1523.18,848.005 1525.78,866.637 1528.38,885.128 1530.98,903.458 1533.58,921.609 1536.18,939.563 1538.78,957.301 1541.38,974.805 1543.98,992.057 1546.58,1009.04 1549.18,1025.74 1551.78,1042.13 1554.38,1058.2 1556.98,1073.94 1559.58,1089.32 1562.18,1104.34 1564.79,1118.97 1567.39,1133.21 1569.99,1147.03 1572.59,1160.42 1575.19,1173.37 1577.79,1185.87 1580.39,1197.91 1582.99,1209.46 1585.59,1220.52 1588.19,1231.08 1590.79,1241.13 1593.39,1250.66 1595.99,1259.65 1598.59,1268.1 1601.19,1275.99 1603.79,1283.33 1606.39,1290.11 1608.99,1296.3 1611.6,1301.92 1614.2,1306.95 1616.8,1311.39 1619.4,1315.24 1622,1318.48 1624.6,1321.12 1627.2,1323.15 1629.8,1324.58 1632.4,1325.39 1635,1325.59 1637.6,1325.18 1640.2,1324.16 1642.8,1322.53 1645.4,1320.29 1648,1317.44 1650.6,1313.98 1653.2,1309.93 1655.8,1305.27 1658.41,1300.02 1661.01,1294.19 1663.61,1287.77 1666.21,1280.77 1668.81,1273.21 1671.41,1265.08 1674.01,1256.4 1676.61,1247.17 1679.21,1237.4 1681.81,1227.11 1684.41,1216.3 1687.01,1204.98 1689.61,1193.17 1692.21,1180.87 1694.81,1168.1 1697.41,1154.87 1700.01,1141.2 1702.61,1127.09 1705.22,1112.57 1707.82,1097.64 1710.42,1082.32 1713.02,1066.62 1715.62,1050.57 1718.22,1034.17 1720.82,1017.45 1723.42,1000.42 1726.02,983.089 1728.62,965.486 1731.22,947.625 1733.82,929.522 1736.42,911.197 1739.02,892.666 1741.62,873.95 1744.22,855.065 1746.82,836.031 1749.43,816.867 1752.03,797.592 1754.63,778.226 1757.23,758.786 1759.83,739.293 1762.43,719.766 1765.03,700.224 1767.63,680.688 1770.23,661.176 1772.83,641.707 1775.43,622.301 1778.03,602.978 1780.63,583.757 1783.23,564.657 1785.83,545.696 1788.43,526.894 1791.03,508.27 1793.63,489.841 1796.24,471.627 1798.84,453.645 1801.44,435.914 1804.04,418.451 1806.64,401.274 1809.24,384.399 1811.84,367.844 1814.44,351.625 1817.04,335.758 1819.64,320.259 1822.24,305.143 1824.84,290.426 1827.44,276.122 1830.04,262.246 1832.64,248.811 1835.24,235.831 1837.84,223.319 1840.44,211.287 1843.05,199.748 1845.65,188.712 1848.25,178.191 1850.85,168.196 1853.45,158.736 1856.05,149.82 1858.65,141.459 1861.25,133.66 1863.85,126.431 1866.45,119.779 1869.05,113.711 1871.65,108.233 1874.25,103.35 1876.85,99.0683 1879.45,95.3911 1882.05,92.3224 1884.65,89.8653 1887.26,88.0223 1889.86,86.7954 1892.46,86.1857 1895.06,86.194 1897.66,86.8203 1900.26,88.064 1902.86,89.924 1905.46,92.3985 1908.06,95.4852 1910.66,99.1808 1913.26,103.482 1915.86,108.384 1918.46,113.883 1921.06,119.973 1923.66,126.648 1926.26,133.901 1928.86,141.726 1931.46,150.114 1934.07,159.058 1936.67,168.548 1939.27,178.575 1941.87,189.129 1944.47,200.2 1947.07,211.776 1949.67,223.848 1952.27,236.401 1954.87,249.424 1957.47,262.905 1960.07,276.829 1962.67,291.183 1965.27,305.953 1967.87,321.124 1970.47,336.681 1973.07,352.609 1975.67,368.892 1978.27,385.513 1980.88,402.457 1983.48,419.706 1986.08,437.244 1988.68,455.053 1991.28,473.115 1993.88,491.413 1996.48,509.928 1999.08,528.643 2001.68,547.537 2004.28,566.594 2006.88,585.794 2009.48,605.118 2012.08,624.547 2014.68,644.061 2017.28,663.641 2019.88,683.269 2022.48,702.924 2025.08,722.587 2027.69,742.238 2030.29,761.859 2032.89,781.429 2035.49,800.93 2038.09,820.342 2040.69,839.646 2043.29,858.823 2045.89,877.853 2048.49,896.719 2051.09,915.401 2053.69,933.881 2056.29,952.141 2058.89,970.162 2061.49,987.928 2064.09,1005.42 2066.69,1022.62 2069.29,1039.51 2071.9,1056.08 2074.5,1072.31 2077.1,1088.18 2079.7,1103.68 2082.3,1118.79 2084.9,1133.5 2087.5,1147.79 2090.1,1161.65 2092.7,1175.07 2095.3,1188.03 2097.9,1200.52 2100.5,1212.52 2103.1,1224.03 2105.7,1235.04 2108.3,1245.53 2110.9,1255.49 2113.5,1264.92 2116.1,1273.8 2118.71,1282.13 2121.31,1289.89 2123.91,1297.09 2126.51,1303.71 2129.11,1309.75 2131.71,1315.2 2134.31,1320.05 2136.91,1324.31 2139.51,1327.96 2142.11,1331.01 2144.71,1333.45 2147.31,1335.28 2149.91,1336.5 2152.51,1337.1 2155.11,1337.1 2157.71,1336.47 2160.31,1335.24 2162.91,1333.4 2165.52,1330.95 2168.12,1327.89 2170.72,1324.23 2173.32,1319.97 2175.92,1315.12 2178.52,1309.68 2181.12,1303.66 2183.72,1297.06 2186.32,1289.89 2188.92,1282.16 2191.52,1273.88 2194.12,1265.05 2196.72,1255.68 2199.32,1245.79 2201.92,1235.38 2204.52,1224.47 2207.12,1213.06 2209.72,1201.17 2212.33,1188.81 2214.93,1175.99 2217.53,1162.73 2220.13,1149.03 2222.73,1134.92 2225.33,1120.4 2227.93,1105.5 2230.53,1090.23 2233.13,1074.59 2235.73,1058.62 2238.33,1042.32 2240.93,1025.72 2243.53,1008.82 2246.13,991.652 2248.73,974.225 2251.33,956.559 2253.93,938.672 2256.54,920.584 2259.14,902.31 2261.74,883.872 2264.34,865.287 2266.94,846.574 2269.54,827.752 2272.14,808.84 2274.74,789.859 2277.34,770.826 2279.94,751.761 2282.54,732.684 2285.14,713.614 2287.74,694.57 2290.34,675.572 \"/> <path clip-path=\"url(#clip010)\" d=\"M220.987 1377.32 L894.244 1377.32 L894.244 1221.8 L220.987 1221.8  Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"1\"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"220.987,1377.32 894.244,1377.32 894.244,1221.8 220.987,1221.8 220.987,1377.32 \"/> <polyline clip-path=\"url(#clip010)\" style=\"stroke:#009af9; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"245.49,1273.64 392.509,1273.64 \"/> <path clip-path=\"url(#clip010)\" d=\"M437.359 1269.97 Q438.956 1267.1 441.178 1265.73 Q443.401 1264.36 446.41 1264.36 Q450.461 1264.36 452.66 1267.21 Q454.859 1270.04 454.859 1275.27 L454.859 1290.92 L450.577 1290.92 L450.577 1275.41 Q450.577 1271.68 449.257 1269.87 Q447.938 1268.07 445.229 1268.07 Q441.919 1268.07 439.998 1270.27 Q438.077 1272.47 438.077 1276.26 L438.077 1290.92 L433.794 1290.92 L433.794 1275.41 Q433.794 1271.66 432.475 1269.87 Q431.155 1268.07 428.401 1268.07 Q425.137 1268.07 423.216 1270.29 Q421.294 1272.49 421.294 1276.26 L421.294 1290.92 L417.012 1290.92 L417.012 1264.99 L421.294 1264.99 L421.294 1269.02 Q422.753 1266.63 424.79 1265.5 Q426.827 1264.36 429.628 1264.36 Q432.452 1264.36 434.419 1265.8 Q436.41 1267.23 437.359 1269.97 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M475.137 1277.88 Q469.975 1277.88 467.984 1279.06 Q465.993 1280.24 465.993 1283.09 Q465.993 1285.36 467.475 1286.7 Q468.979 1288.02 471.549 1288.02 Q475.09 1288.02 477.22 1285.52 Q479.373 1283 479.373 1278.83 L479.373 1277.88 L475.137 1277.88 M483.632 1276.12 L483.632 1290.92 L479.373 1290.92 L479.373 1286.98 Q477.914 1289.34 475.738 1290.48 Q473.563 1291.59 470.414 1291.59 Q466.433 1291.59 464.072 1289.36 Q461.734 1287.12 461.734 1283.37 Q461.734 1278.99 464.651 1276.77 Q467.59 1274.55 473.4 1274.55 L479.373 1274.55 L479.373 1274.13 Q479.373 1271.19 477.428 1269.6 Q475.507 1267.98 472.012 1267.98 Q469.789 1267.98 467.683 1268.51 Q465.576 1269.04 463.632 1270.11 L463.632 1266.17 Q465.97 1265.27 468.169 1264.83 Q470.368 1264.36 472.451 1264.36 Q478.076 1264.36 480.854 1267.28 Q483.632 1270.2 483.632 1276.12 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M508.933 1265.75 L508.933 1269.78 Q507.127 1268.86 505.183 1268.39 Q503.238 1267.93 501.155 1267.93 Q497.984 1267.93 496.386 1268.9 Q494.812 1269.87 494.812 1271.82 Q494.812 1273.3 495.947 1274.16 Q497.081 1274.99 500.507 1275.75 L501.965 1276.08 Q506.502 1277.05 508.4 1278.83 Q510.322 1280.59 510.322 1283.76 Q510.322 1287.37 507.451 1289.48 Q504.604 1291.59 499.604 1291.59 Q497.521 1291.59 495.252 1291.17 Q493.007 1290.78 490.507 1289.97 L490.507 1285.57 Q492.868 1286.79 495.16 1287.42 Q497.451 1288.02 499.697 1288.02 Q502.706 1288.02 504.326 1287 Q505.947 1285.96 505.947 1284.09 Q505.947 1282.35 504.766 1281.42 Q503.609 1280.5 499.65 1279.64 L498.169 1279.3 Q494.211 1278.46 492.451 1276.75 Q490.692 1275.01 490.692 1272 Q490.692 1268.35 493.285 1266.36 Q495.877 1264.36 500.646 1264.36 Q503.007 1264.36 505.09 1264.71 Q507.173 1265.06 508.933 1265.75 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M533.632 1265.75 L533.632 1269.78 Q531.826 1268.86 529.882 1268.39 Q527.937 1267.93 525.854 1267.93 Q522.683 1267.93 521.085 1268.9 Q519.511 1269.87 519.511 1271.82 Q519.511 1273.3 520.646 1274.16 Q521.78 1274.99 525.206 1275.75 L526.664 1276.08 Q531.201 1277.05 533.099 1278.83 Q535.021 1280.59 535.021 1283.76 Q535.021 1287.37 532.15 1289.48 Q529.303 1291.59 524.303 1291.59 Q522.22 1291.59 519.951 1291.17 Q517.706 1290.78 515.206 1289.97 L515.206 1285.57 Q517.567 1286.79 519.859 1287.42 Q522.15 1288.02 524.396 1288.02 Q527.405 1288.02 529.025 1287 Q530.646 1285.96 530.646 1284.09 Q530.646 1282.35 529.465 1281.42 Q528.308 1280.5 524.349 1279.64 L522.868 1279.3 Q518.909 1278.46 517.15 1276.75 Q515.391 1275.01 515.391 1272 Q515.391 1268.35 517.984 1266.36 Q520.576 1264.36 525.345 1264.36 Q527.706 1264.36 529.789 1264.71 Q531.872 1265.06 533.632 1265.75 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M542.405 1285.04 L547.289 1285.04 L547.289 1290.92 L542.405 1290.92 L542.405 1285.04 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M573.4 1265.75 L573.4 1269.78 Q571.594 1268.86 569.65 1268.39 Q567.706 1267.93 565.622 1267.93 Q562.451 1267.93 560.854 1268.9 Q559.28 1269.87 559.28 1271.82 Q559.28 1273.3 560.414 1274.16 Q561.548 1274.99 564.974 1275.75 L566.432 1276.08 Q570.969 1277.05 572.868 1278.83 Q574.789 1280.59 574.789 1283.76 Q574.789 1287.37 571.918 1289.48 Q569.071 1291.59 564.071 1291.59 Q561.988 1291.59 559.719 1291.17 Q557.474 1290.78 554.974 1289.97 L554.974 1285.57 Q557.335 1286.79 559.627 1287.42 Q561.919 1288.02 564.164 1288.02 Q567.173 1288.02 568.793 1287 Q570.414 1285.96 570.414 1284.09 Q570.414 1282.35 569.233 1281.42 Q568.076 1280.5 564.118 1279.64 L562.636 1279.3 Q558.678 1278.46 556.919 1276.75 Q555.159 1275.01 555.159 1272 Q555.159 1268.35 557.752 1266.36 Q560.344 1264.36 565.113 1264.36 Q567.474 1264.36 569.557 1264.71 Q571.641 1265.06 573.4 1265.75 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M606.872 1254.94 Q603.77 1260.27 602.266 1265.48 Q600.761 1270.68 600.761 1276.03 Q600.761 1281.38 602.266 1286.63 Q603.793 1291.86 606.872 1297.17 L603.168 1297.17 Q599.696 1291.73 597.96 1286.47 Q596.247 1281.22 596.247 1276.03 Q596.247 1270.87 597.96 1265.64 Q599.673 1260.41 603.168 1254.94 L606.872 1254.94 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M629.904 1272.28 Q633.261 1273 635.136 1275.27 Q637.034 1277.54 637.034 1280.87 Q637.034 1285.98 633.515 1288.79 Q629.997 1291.59 623.515 1291.59 Q621.339 1291.59 619.025 1291.15 Q616.733 1290.73 614.279 1289.87 L614.279 1285.36 Q616.224 1286.49 618.539 1287.07 Q620.853 1287.65 623.377 1287.65 Q627.775 1287.65 630.066 1285.92 Q632.381 1284.18 632.381 1280.87 Q632.381 1277.81 630.228 1276.1 Q628.099 1274.36 624.279 1274.36 L620.252 1274.36 L620.252 1270.52 L624.464 1270.52 Q627.914 1270.52 629.742 1269.16 Q631.571 1267.77 631.571 1265.17 Q631.571 1262.51 629.673 1261.1 Q627.798 1259.67 624.279 1259.67 Q622.358 1259.67 620.159 1260.08 Q617.96 1260.5 615.321 1261.38 L615.321 1257.21 Q617.983 1256.47 620.298 1256.1 Q622.636 1255.73 624.696 1255.73 Q630.02 1255.73 633.122 1258.16 Q636.224 1260.57 636.224 1264.69 Q636.224 1267.56 634.58 1269.55 Q632.937 1271.52 629.904 1272.28 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M660.066 1272.28 Q663.423 1273 665.298 1275.27 Q667.196 1277.54 667.196 1280.87 Q667.196 1285.98 663.677 1288.79 Q660.159 1291.59 653.677 1291.59 Q651.501 1291.59 649.187 1291.15 Q646.895 1290.73 644.441 1289.87 L644.441 1285.36 Q646.386 1286.49 648.7 1287.07 Q651.015 1287.65 653.538 1287.65 Q657.937 1287.65 660.228 1285.92 Q662.543 1284.18 662.543 1280.87 Q662.543 1277.81 660.39 1276.1 Q658.261 1274.36 654.441 1274.36 L650.413 1274.36 L650.413 1270.52 L654.626 1270.52 Q658.075 1270.52 659.904 1269.16 Q661.733 1267.77 661.733 1265.17 Q661.733 1262.51 659.835 1261.1 Q657.96 1259.67 654.441 1259.67 Q652.52 1259.67 650.321 1260.08 Q648.122 1260.5 645.483 1261.38 L645.483 1257.21 Q648.145 1256.47 650.46 1256.1 Q652.798 1255.73 654.858 1255.73 Q660.182 1255.73 663.284 1258.16 Q666.386 1260.57 666.386 1264.69 Q666.386 1267.56 664.742 1269.55 Q663.099 1271.52 660.066 1272.28 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M676.108 1256.36 L694.464 1256.36 L694.464 1260.29 L680.39 1260.29 L680.39 1268.76 Q681.409 1268.42 682.427 1268.25 Q683.446 1268.07 684.464 1268.07 Q690.251 1268.07 693.631 1271.24 Q697.01 1274.41 697.01 1279.83 Q697.01 1285.41 693.538 1288.51 Q690.066 1291.59 683.747 1291.59 Q681.571 1291.59 679.302 1291.22 Q677.057 1290.85 674.649 1290.11 L674.649 1285.41 Q676.733 1286.54 678.955 1287.1 Q681.177 1287.65 683.654 1287.65 Q687.659 1287.65 689.997 1285.54 Q692.334 1283.44 692.334 1279.83 Q692.334 1276.22 689.997 1274.11 Q687.659 1272 683.654 1272 Q681.779 1272 679.904 1272.42 Q678.052 1272.84 676.108 1273.72 L676.108 1256.36 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M706.27 1256.36 L724.626 1256.36 L724.626 1260.29 L710.552 1260.29 L710.552 1268.76 Q711.57 1268.42 712.589 1268.25 Q713.608 1268.07 714.626 1268.07 Q720.413 1268.07 723.793 1271.24 Q727.172 1274.41 727.172 1279.83 Q727.172 1285.41 723.7 1288.51 Q720.228 1291.59 713.908 1291.59 Q711.733 1291.59 709.464 1291.22 Q707.219 1290.85 704.811 1290.11 L704.811 1285.41 Q706.895 1286.54 709.117 1287.1 Q711.339 1287.65 713.816 1287.65 Q717.82 1287.65 720.158 1285.54 Q722.496 1283.44 722.496 1279.83 Q722.496 1276.22 720.158 1274.11 Q717.82 1272 713.816 1272 Q711.941 1272 710.066 1272.42 Q708.214 1272.84 706.27 1273.72 L706.27 1256.36 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M749.232 1260.43 L737.427 1278.88 L749.232 1278.88 L749.232 1260.43 M748.005 1256.36 L753.885 1256.36 L753.885 1278.88 L758.816 1278.88 L758.816 1282.77 L753.885 1282.77 L753.885 1290.92 L749.232 1290.92 L749.232 1282.77 L733.631 1282.77 L733.631 1278.25 L748.005 1256.36 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M779.394 1260.43 L767.589 1278.88 L779.394 1278.88 L779.394 1260.43 M778.167 1256.36 L784.047 1256.36 L784.047 1278.88 L788.977 1278.88 L788.977 1282.77 L784.047 1282.77 L784.047 1290.92 L779.394 1290.92 L779.394 1282.77 L763.792 1282.77 L763.792 1278.25 L778.167 1256.36 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M810.876 1272.28 Q814.232 1273 816.107 1275.27 Q818.005 1277.54 818.005 1280.87 Q818.005 1285.98 814.487 1288.79 Q810.968 1291.59 804.487 1291.59 Q802.311 1291.59 799.996 1291.15 Q797.704 1290.73 795.251 1289.87 L795.251 1285.36 Q797.195 1286.49 799.51 1287.07 Q801.825 1287.65 804.348 1287.65 Q808.746 1287.65 811.038 1285.92 Q813.352 1284.18 813.352 1280.87 Q813.352 1277.81 811.2 1276.1 Q809.07 1274.36 805.251 1274.36 L801.223 1274.36 L801.223 1270.52 L805.436 1270.52 Q808.885 1270.52 810.713 1269.16 Q812.542 1267.77 812.542 1265.17 Q812.542 1262.51 810.644 1261.1 Q808.769 1259.67 805.251 1259.67 Q803.329 1259.67 801.13 1260.08 Q798.931 1260.5 796.292 1261.38 L796.292 1257.21 Q798.954 1256.47 801.269 1256.1 Q803.607 1255.73 805.667 1255.73 Q810.991 1255.73 814.093 1258.16 Q817.195 1260.57 817.195 1264.69 Q817.195 1267.56 815.551 1269.55 Q813.908 1271.52 810.876 1272.28 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M830.899 1286.98 L847.218 1286.98 L847.218 1290.92 L825.274 1290.92 L825.274 1286.98 Q827.936 1284.23 832.519 1279.6 Q837.125 1274.94 838.306 1273.6 Q840.551 1271.08 841.431 1269.34 Q842.334 1267.58 842.334 1265.89 Q842.334 1263.14 840.389 1261.4 Q838.468 1259.67 835.366 1259.67 Q833.167 1259.67 830.713 1260.43 Q828.283 1261.19 825.505 1262.74 L825.505 1258.02 Q828.329 1256.89 830.783 1256.31 Q833.237 1255.73 835.274 1255.73 Q840.644 1255.73 843.838 1258.42 Q847.033 1261.1 847.033 1265.59 Q847.033 1267.72 846.223 1269.64 Q845.436 1271.54 843.329 1274.13 Q842.75 1274.8 839.649 1278.02 Q836.547 1281.22 830.899 1286.98 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M855.76 1254.94 L859.463 1254.94 Q862.935 1260.41 864.648 1265.64 Q866.384 1270.87 866.384 1276.03 Q866.384 1281.22 864.648 1286.47 Q862.935 1291.73 859.463 1297.17 L855.76 1297.17 Q858.838 1291.86 860.343 1286.63 Q861.871 1281.38 861.871 1276.03 Q861.871 1270.68 860.343 1265.48 Q858.838 1260.27 855.76 1254.94 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><polyline clip-path=\"url(#clip010)\" style=\"stroke:#e26f46; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"245.49,1325.48 392.509,1325.48 \"/> <path clip-path=\"url(#clip010)\" d=\"M437.359 1321.81 Q438.956 1318.94 441.178 1317.57 Q443.401 1316.2 446.41 1316.2 Q450.461 1316.2 452.66 1319.05 Q454.859 1321.88 454.859 1327.11 L454.859 1342.76 L450.577 1342.76 L450.577 1327.25 Q450.577 1323.52 449.257 1321.71 Q447.938 1319.91 445.229 1319.91 Q441.919 1319.91 439.998 1322.11 Q438.077 1324.31 438.077 1328.1 L438.077 1342.76 L433.794 1342.76 L433.794 1327.25 Q433.794 1323.5 432.475 1321.71 Q431.155 1319.91 428.401 1319.91 Q425.137 1319.91 423.216 1322.13 Q421.294 1324.33 421.294 1328.1 L421.294 1342.76 L417.012 1342.76 L417.012 1316.83 L421.294 1316.83 L421.294 1320.86 Q422.753 1318.47 424.79 1317.34 Q426.827 1316.2 429.628 1316.2 Q432.452 1316.2 434.419 1317.64 Q436.41 1319.07 437.359 1321.81 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M475.137 1329.72 Q469.975 1329.72 467.984 1330.9 Q465.993 1332.08 465.993 1334.93 Q465.993 1337.2 467.475 1338.54 Q468.979 1339.86 471.549 1339.86 Q475.09 1339.86 477.22 1337.36 Q479.373 1334.84 479.373 1330.67 L479.373 1329.72 L475.137 1329.72 M483.632 1327.96 L483.632 1342.76 L479.373 1342.76 L479.373 1338.82 Q477.914 1341.18 475.738 1342.32 Q473.563 1343.43 470.414 1343.43 Q466.433 1343.43 464.072 1341.2 Q461.734 1338.96 461.734 1335.21 Q461.734 1330.83 464.651 1328.61 Q467.59 1326.39 473.4 1326.39 L479.373 1326.39 L479.373 1325.97 Q479.373 1323.03 477.428 1321.44 Q475.507 1319.82 472.012 1319.82 Q469.789 1319.82 467.683 1320.35 Q465.576 1320.88 463.632 1321.95 L463.632 1318.01 Q465.97 1317.11 468.169 1316.67 Q470.368 1316.2 472.451 1316.2 Q478.076 1316.2 480.854 1319.12 Q483.632 1322.04 483.632 1327.96 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M508.933 1317.59 L508.933 1321.62 Q507.127 1320.7 505.183 1320.23 Q503.238 1319.77 501.155 1319.77 Q497.984 1319.77 496.386 1320.74 Q494.812 1321.71 494.812 1323.66 Q494.812 1325.14 495.947 1326 Q497.081 1326.83 500.507 1327.59 L501.965 1327.92 Q506.502 1328.89 508.4 1330.67 Q510.322 1332.43 510.322 1335.6 Q510.322 1339.21 507.451 1341.32 Q504.604 1343.43 499.604 1343.43 Q497.521 1343.43 495.252 1343.01 Q493.007 1342.62 490.507 1341.81 L490.507 1337.41 Q492.868 1338.63 495.16 1339.26 Q497.451 1339.86 499.697 1339.86 Q502.706 1339.86 504.326 1338.84 Q505.947 1337.8 505.947 1335.93 Q505.947 1334.19 504.766 1333.26 Q503.609 1332.34 499.65 1331.48 L498.169 1331.14 Q494.211 1330.3 492.451 1328.59 Q490.692 1326.85 490.692 1323.84 Q490.692 1320.19 493.285 1318.2 Q495.877 1316.2 500.646 1316.2 Q503.007 1316.2 505.09 1316.55 Q507.173 1316.9 508.933 1317.59 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M533.632 1317.59 L533.632 1321.62 Q531.826 1320.7 529.882 1320.23 Q527.937 1319.77 525.854 1319.77 Q522.683 1319.77 521.085 1320.74 Q519.511 1321.71 519.511 1323.66 Q519.511 1325.14 520.646 1326 Q521.78 1326.83 525.206 1327.59 L526.664 1327.92 Q531.201 1328.89 533.099 1330.67 Q535.021 1332.43 535.021 1335.6 Q535.021 1339.21 532.15 1341.32 Q529.303 1343.43 524.303 1343.43 Q522.22 1343.43 519.951 1343.01 Q517.706 1342.62 515.206 1341.81 L515.206 1337.41 Q517.567 1338.63 519.859 1339.26 Q522.15 1339.86 524.396 1339.86 Q527.405 1339.86 529.025 1338.84 Q530.646 1337.8 530.646 1335.93 Q530.646 1334.19 529.465 1333.26 Q528.308 1332.34 524.349 1331.48 L522.868 1331.14 Q518.909 1330.3 517.15 1328.59 Q515.391 1326.85 515.391 1323.84 Q515.391 1320.19 517.984 1318.2 Q520.576 1316.2 525.345 1316.2 Q527.706 1316.2 529.789 1316.55 Q531.872 1316.9 533.632 1317.59 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M542.405 1336.88 L547.289 1336.88 L547.289 1342.76 L542.405 1342.76 L542.405 1336.88 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M553.817 1316.83 L558.331 1316.83 L566.432 1338.59 L574.534 1316.83 L579.048 1316.83 L569.326 1342.76 L563.539 1342.76 L553.817 1316.83 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M610.228 1306.78 Q607.127 1312.11 605.622 1317.32 Q604.117 1322.52 604.117 1327.87 Q604.117 1333.22 605.622 1338.47 Q607.15 1343.7 610.228 1349.01 L606.525 1349.01 Q603.053 1343.57 601.316 1338.31 Q599.604 1333.06 599.604 1327.87 Q599.604 1322.71 601.316 1317.48 Q603.029 1312.25 606.525 1306.78 L610.228 1306.78 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M633.261 1324.12 Q636.617 1324.84 638.492 1327.11 Q640.39 1329.38 640.39 1332.71 Q640.39 1337.82 636.872 1340.63 Q633.353 1343.43 626.872 1343.43 Q624.696 1343.43 622.381 1342.99 Q620.09 1342.57 617.636 1341.71 L617.636 1337.2 Q619.58 1338.33 621.895 1338.91 Q624.21 1339.49 626.733 1339.49 Q631.131 1339.49 633.423 1337.76 Q635.738 1336.02 635.738 1332.71 Q635.738 1329.65 633.585 1327.94 Q631.455 1326.2 627.636 1326.2 L623.608 1326.2 L623.608 1322.36 L627.821 1322.36 Q631.27 1322.36 633.099 1321 Q634.927 1319.61 634.927 1317.01 Q634.927 1314.35 633.029 1312.94 Q631.154 1311.51 627.636 1311.51 Q625.714 1311.51 623.515 1311.92 Q621.316 1312.34 618.677 1313.22 L618.677 1309.05 Q621.339 1308.31 623.654 1307.94 Q625.992 1307.57 628.052 1307.57 Q633.376 1307.57 636.478 1310 Q639.58 1312.41 639.58 1316.53 Q639.58 1319.4 637.937 1321.39 Q636.293 1323.36 633.261 1324.12 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M663.423 1324.12 Q666.779 1324.84 668.654 1327.11 Q670.552 1329.38 670.552 1332.71 Q670.552 1337.82 667.034 1340.63 Q663.515 1343.43 657.034 1343.43 Q654.858 1343.43 652.543 1342.99 Q650.251 1342.57 647.798 1341.71 L647.798 1337.2 Q649.742 1338.33 652.057 1338.91 Q654.372 1339.49 656.895 1339.49 Q661.293 1339.49 663.585 1337.76 Q665.899 1336.02 665.899 1332.71 Q665.899 1329.65 663.747 1327.94 Q661.617 1326.2 657.798 1326.2 L653.77 1326.2 L653.77 1322.36 L657.983 1322.36 Q661.432 1322.36 663.261 1321 Q665.089 1319.61 665.089 1317.01 Q665.089 1314.35 663.191 1312.94 Q661.316 1311.51 657.798 1311.51 Q655.876 1311.51 653.677 1311.92 Q651.478 1312.34 648.839 1313.22 L648.839 1309.05 Q651.501 1308.31 653.816 1307.94 Q656.154 1307.57 658.214 1307.57 Q663.538 1307.57 666.64 1310 Q669.742 1312.41 669.742 1316.53 Q669.742 1319.4 668.099 1321.39 Q666.455 1323.36 663.423 1324.12 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M679.464 1308.2 L697.821 1308.2 L697.821 1312.13 L683.747 1312.13 L683.747 1320.6 Q684.765 1320.26 685.784 1320.09 Q686.802 1319.91 687.821 1319.91 Q693.608 1319.91 696.987 1323.08 Q700.367 1326.25 700.367 1331.67 Q700.367 1337.25 696.895 1340.35 Q693.422 1343.43 687.103 1343.43 Q684.927 1343.43 682.659 1343.06 Q680.413 1342.69 678.006 1341.95 L678.006 1337.25 Q680.089 1338.38 682.311 1338.94 Q684.534 1339.49 687.01 1339.49 Q691.015 1339.49 693.353 1337.38 Q695.691 1335.28 695.691 1331.67 Q695.691 1328.06 693.353 1325.95 Q691.015 1323.84 687.01 1323.84 Q685.135 1323.84 683.26 1324.26 Q681.409 1324.68 679.464 1325.56 L679.464 1308.2 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M709.626 1308.2 L727.982 1308.2 L727.982 1312.13 L713.908 1312.13 L713.908 1320.6 Q714.927 1320.26 715.945 1320.09 Q716.964 1319.91 717.982 1319.91 Q723.77 1319.91 727.149 1323.08 Q730.529 1326.25 730.529 1331.67 Q730.529 1337.25 727.057 1340.35 Q723.584 1343.43 717.265 1343.43 Q715.089 1343.43 712.82 1343.06 Q710.575 1342.69 708.168 1341.95 L708.168 1337.25 Q710.251 1338.38 712.473 1338.94 Q714.695 1339.49 717.172 1339.49 Q721.177 1339.49 723.515 1337.38 Q725.853 1335.28 725.853 1331.67 Q725.853 1328.06 723.515 1325.95 Q721.177 1323.84 717.172 1323.84 Q715.297 1323.84 713.422 1324.26 Q711.57 1324.68 709.626 1325.56 L709.626 1308.2 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M752.589 1312.27 L740.783 1330.72 L752.589 1330.72 L752.589 1312.27 M751.362 1308.2 L757.242 1308.2 L757.242 1330.72 L762.172 1330.72 L762.172 1334.61 L757.242 1334.61 L757.242 1342.76 L752.589 1342.76 L752.589 1334.61 L736.987 1334.61 L736.987 1330.09 L751.362 1308.2 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M782.751 1312.27 L770.945 1330.72 L782.751 1330.72 L782.751 1312.27 M781.524 1308.2 L787.403 1308.2 L787.403 1330.72 L792.334 1330.72 L792.334 1334.61 L787.403 1334.61 L787.403 1342.76 L782.751 1342.76 L782.751 1334.61 L767.149 1334.61 L767.149 1330.09 L781.524 1308.2 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M814.232 1324.12 Q817.588 1324.84 819.463 1327.11 Q821.362 1329.38 821.362 1332.71 Q821.362 1337.82 817.843 1340.63 Q814.325 1343.43 807.843 1343.43 Q805.667 1343.43 803.352 1342.99 Q801.061 1342.57 798.607 1341.71 L798.607 1337.2 Q800.552 1338.33 802.866 1338.91 Q805.181 1339.49 807.704 1339.49 Q812.102 1339.49 814.394 1337.76 Q816.709 1336.02 816.709 1332.71 Q816.709 1329.65 814.556 1327.94 Q812.426 1326.2 808.607 1326.2 L804.579 1326.2 L804.579 1322.36 L808.792 1322.36 Q812.241 1322.36 814.07 1321 Q815.899 1319.61 815.899 1317.01 Q815.899 1314.35 814.001 1312.94 Q812.126 1311.51 808.607 1311.51 Q806.686 1311.51 804.487 1311.92 Q802.288 1312.34 799.649 1313.22 L799.649 1309.05 Q802.311 1308.31 804.626 1307.94 Q806.964 1307.57 809.024 1307.57 Q814.348 1307.57 817.45 1310 Q820.551 1312.41 820.551 1316.53 Q820.551 1319.4 818.908 1321.39 Q817.264 1323.36 814.232 1324.12 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M844.394 1324.12 Q847.75 1324.84 849.625 1327.11 Q851.523 1329.38 851.523 1332.71 Q851.523 1337.82 848.005 1340.63 Q844.486 1343.43 838.005 1343.43 Q835.829 1343.43 833.514 1342.99 Q831.223 1342.57 828.769 1341.71 L828.769 1337.2 Q830.713 1338.33 833.028 1338.91 Q835.343 1339.49 837.866 1339.49 Q842.264 1339.49 844.556 1337.76 Q846.871 1336.02 846.871 1332.71 Q846.871 1329.65 844.718 1327.94 Q842.588 1326.2 838.769 1326.2 L834.741 1326.2 L834.741 1322.36 L838.954 1322.36 Q842.403 1322.36 844.232 1321 Q846.061 1319.61 846.061 1317.01 Q846.061 1314.35 844.162 1312.94 Q842.287 1311.51 838.769 1311.51 Q836.848 1311.51 834.649 1311.92 Q832.449 1312.34 829.811 1313.22 L829.811 1309.05 Q832.473 1308.31 834.787 1307.94 Q837.125 1307.57 839.186 1307.57 Q844.51 1307.57 847.611 1310 Q850.713 1312.41 850.713 1316.53 Q850.713 1319.4 849.07 1321.39 Q847.426 1323.36 844.394 1324.12 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip010)\" d=\"M859.116 1306.78 L862.82 1306.78 Q866.292 1312.25 868.005 1317.48 Q869.741 1322.71 869.741 1327.87 Q869.741 1333.06 868.005 1338.31 Q866.292 1343.57 862.82 1349.01 L859.116 1349.01 Q862.195 1343.7 863.699 1338.47 Q865.227 1333.22 865.227 1327.87 Q865.227 1322.52 863.699 1317.32 Q862.195 1312.11 859.116 1306.78 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /></svg>","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"# input function format \"cxt\", dependent on `c` (component), `x` (state) and `t` (time)\nfunction extForce_cxt(c::Union{FMU2Component, Nothing}, x::Union{AbstractArray{<:Real}, Nothing}, t::Real, u::AbstractArray{<:Real})\n    x1 = 0.0\n    if x != nothing # this check is important, because inputs may be needed before the system state is known\n        x1 = x[1] \n    end\n    u[1] = sin(t) * x1\n    nothing\nend \n\n# simulate while setting inputs\ndata_extForce_cxt = simulate(fmu, (tStart, tStop); saveat=tSave, inputValueReferences=[\"extForce\"], inputFunction=extForce_cxt, dtmax=1e-2, showProgress=false)\nplot(data_extForce_cxt)","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"<?xml version=\"1.0\" encoding=\"utf-8\"?> <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"600\" height=\"400\" viewBox=\"0 0 2400 1600\"> <defs>   <clipPath id=\"clip100\">     <rect x=\"0\" y=\"0\" width=\"2400\" height=\"1600\"/>   </clipPath> </defs> <path clip-path=\"url(#clip100)\" d=\"M0 1600 L2400 1600 L2400 0 L0 0  Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"1\"/> <defs>   <clipPath id=\"clip101\">     <rect x=\"480\" y=\"0\" width=\"1681\" height=\"1600\"/>   </clipPath> </defs> <path clip-path=\"url(#clip100)\" d=\"M147.478 1423.18 L2352.76 1423.18 L2352.76 47.2441 L147.478 47.2441  Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"1\"/> <defs>   <clipPath id=\"clip102\">     <rect x=\"147\" y=\"47\" width=\"2206\" height=\"1377\"/>   </clipPath> </defs> <polyline clip-path=\"url(#clip102)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"209.891,1423.18 209.891,47.2441 \"/> <polyline clip-path=\"url(#clip102)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"730.004,1423.18 730.004,47.2441 \"/> <polyline clip-path=\"url(#clip102)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"1250.12,1423.18 1250.12,47.2441 \"/> <polyline clip-path=\"url(#clip102)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"1770.23,1423.18 1770.23,47.2441 \"/> <polyline clip-path=\"url(#clip102)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"2290.34,1423.18 2290.34,47.2441 \"/> <polyline clip-path=\"url(#clip102)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"147.478,1386.13 2352.76,1386.13 \"/> <polyline clip-path=\"url(#clip102)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"147.478,1060.54 2352.76,1060.54 \"/> <polyline clip-path=\"url(#clip102)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"147.478,734.948 2352.76,734.948 \"/> <polyline clip-path=\"url(#clip102)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"147.478,409.359 2352.76,409.359 \"/> <polyline clip-path=\"url(#clip102)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"147.478,83.7699 2352.76,83.7699 \"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,1423.18 2352.76,1423.18 \"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"209.891,1423.18 209.891,1404.28 \"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"730.004,1423.18 730.004,1404.28 \"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1250.12,1423.18 1250.12,1404.28 \"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1770.23,1423.18 1770.23,1404.28 \"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"2290.34,1423.18 2290.34,1404.28 \"/> <path clip-path=\"url(#clip100)\" d=\"M209.891 1454.1 Q206.28 1454.1 204.452 1457.66 Q202.646 1461.2 202.646 1468.33 Q202.646 1475.44 204.452 1479.01 Q206.28 1482.55 209.891 1482.55 Q213.526 1482.55 215.331 1479.01 Q217.16 1475.44 217.16 1468.33 Q217.16 1461.2 215.331 1457.66 Q213.526 1454.1 209.891 1454.1 M209.891 1450.39 Q215.702 1450.39 218.757 1455 Q221.836 1459.58 221.836 1468.33 Q221.836 1477.06 218.757 1481.67 Q215.702 1486.25 209.891 1486.25 Q204.081 1486.25 201.003 1481.67 Q197.947 1477.06 197.947 1468.33 Q197.947 1459.58 201.003 1455 Q204.081 1450.39 209.891 1450.39 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M724.657 1481.64 L740.976 1481.64 L740.976 1485.58 L719.032 1485.58 L719.032 1481.64 Q721.694 1478.89 726.277 1474.26 Q730.884 1469.61 732.064 1468.27 Q734.31 1465.74 735.189 1464.01 Q736.092 1462.25 736.092 1460.56 Q736.092 1457.8 734.148 1456.07 Q732.226 1454.33 729.125 1454.33 Q726.925 1454.33 724.472 1455.09 Q722.041 1455.86 719.263 1457.41 L719.263 1452.69 Q722.088 1451.55 724.541 1450.97 Q726.995 1450.39 729.032 1450.39 Q734.402 1450.39 737.597 1453.08 Q740.791 1455.77 740.791 1460.26 Q740.791 1462.39 739.981 1464.31 Q739.194 1466.2 737.087 1468.8 Q736.509 1469.47 733.407 1472.69 Q730.305 1475.88 724.657 1481.64 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M1253.13 1455.09 L1241.32 1473.54 L1253.13 1473.54 L1253.13 1455.09 M1251.9 1451.02 L1257.78 1451.02 L1257.78 1473.54 L1262.71 1473.54 L1262.71 1477.43 L1257.78 1477.43 L1257.78 1485.58 L1253.13 1485.58 L1253.13 1477.43 L1237.52 1477.43 L1237.52 1472.92 L1251.9 1451.02 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M1770.63 1466.44 Q1767.49 1466.44 1765.63 1468.59 Q1763.81 1470.74 1763.81 1474.49 Q1763.81 1478.22 1765.63 1480.39 Q1767.49 1482.55 1770.63 1482.55 Q1773.78 1482.55 1775.61 1480.39 Q1777.46 1478.22 1777.46 1474.49 Q1777.46 1470.74 1775.61 1468.59 Q1773.78 1466.44 1770.63 1466.44 M1779.92 1451.78 L1779.92 1456.04 Q1778.16 1455.21 1776.35 1454.77 Q1774.57 1454.33 1772.81 1454.33 Q1768.18 1454.33 1765.73 1457.45 Q1763.3 1460.58 1762.95 1466.9 Q1764.32 1464.89 1766.38 1463.82 Q1768.44 1462.73 1770.91 1462.73 Q1776.12 1462.73 1779.13 1465.9 Q1782.16 1469.05 1782.16 1474.49 Q1782.16 1479.82 1779.01 1483.03 Q1775.87 1486.25 1770.63 1486.25 Q1764.64 1486.25 1761.47 1481.67 Q1758.3 1477.06 1758.3 1468.33 Q1758.3 1460.14 1762.19 1455.28 Q1766.07 1450.39 1772.63 1450.39 Q1774.38 1450.39 1776.17 1450.74 Q1777.97 1451.09 1779.92 1451.78 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M2290.34 1469.17 Q2287.01 1469.17 2285.09 1470.95 Q2283.19 1472.73 2283.19 1475.86 Q2283.19 1478.98 2285.09 1480.77 Q2287.01 1482.55 2290.34 1482.55 Q2293.68 1482.55 2295.6 1480.77 Q2297.52 1478.96 2297.52 1475.86 Q2297.52 1472.73 2295.6 1470.95 Q2293.7 1469.17 2290.34 1469.17 M2285.67 1467.18 Q2282.66 1466.44 2280.97 1464.38 Q2279.3 1462.32 2279.3 1459.35 Q2279.3 1455.21 2282.24 1452.8 Q2285.2 1450.39 2290.34 1450.39 Q2295.5 1450.39 2298.44 1452.8 Q2301.38 1455.21 2301.38 1459.35 Q2301.38 1462.32 2299.69 1464.38 Q2298.03 1466.44 2295.04 1467.18 Q2298.42 1467.96 2300.3 1470.26 Q2302.19 1472.55 2302.19 1475.86 Q2302.19 1480.88 2299.12 1483.57 Q2296.06 1486.25 2290.34 1486.25 Q2284.62 1486.25 2281.55 1483.57 Q2278.49 1480.88 2278.49 1475.86 Q2278.49 1472.55 2280.39 1470.26 Q2282.29 1467.96 2285.67 1467.18 M2283.95 1459.79 Q2283.95 1462.48 2285.62 1463.98 Q2287.31 1465.49 2290.34 1465.49 Q2293.35 1465.49 2295.04 1463.98 Q2296.75 1462.48 2296.75 1459.79 Q2296.75 1457.11 2295.04 1455.6 Q2293.35 1454.1 2290.34 1454.1 Q2287.31 1454.1 2285.62 1455.6 Q2283.95 1457.11 2283.95 1459.79 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M1198.43 1522.27 L1198.43 1532.4 L1210.49 1532.4 L1210.49 1536.95 L1198.43 1536.95 L1198.43 1556.3 Q1198.43 1560.66 1199.61 1561.9 Q1200.81 1563.14 1204.47 1563.14 L1210.49 1563.14 L1210.49 1568.04 L1204.47 1568.04 Q1197.7 1568.04 1195.12 1565.53 Q1192.54 1562.98 1192.54 1556.3 L1192.54 1536.95 L1188.24 1536.95 L1188.24 1532.4 L1192.54 1532.4 L1192.54 1522.27 L1198.43 1522.27 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M1238.37 1518.52 L1251.87 1518.52 L1251.87 1523.07 L1244.23 1523.07 L1244.23 1572.09 L1251.87 1572.09 L1251.87 1576.64 L1238.37 1576.64 L1238.37 1518.52 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M1287.07 1533.45 L1287.07 1538.98 Q1284.59 1537.71 1281.91 1537.07 Q1279.24 1536.44 1276.38 1536.44 Q1272.01 1536.44 1269.82 1537.77 Q1267.65 1539.11 1267.65 1541.79 Q1267.65 1543.82 1269.21 1545 Q1270.77 1546.15 1275.48 1547.2 L1277.49 1547.64 Q1283.73 1548.98 1286.34 1551.43 Q1288.98 1553.85 1288.98 1558.21 Q1288.98 1563.17 1285.03 1566.07 Q1281.12 1568.97 1274.24 1568.97 Q1271.38 1568.97 1268.26 1568.39 Q1265.17 1567.85 1261.73 1566.74 L1261.73 1560.69 Q1264.98 1562.38 1268.13 1563.24 Q1271.28 1564.07 1274.37 1564.07 Q1278.51 1564.07 1280.74 1562.66 Q1282.96 1561.23 1282.96 1558.65 Q1282.96 1556.27 1281.34 1554.99 Q1279.75 1553.72 1274.31 1552.54 L1272.27 1552.07 Q1266.83 1550.92 1264.41 1548.56 Q1261.99 1546.18 1261.99 1542.04 Q1261.99 1537.01 1265.55 1534.27 Q1269.12 1531.54 1275.68 1531.54 Q1278.92 1531.54 1281.79 1532.01 Q1284.65 1532.49 1287.07 1533.45 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M1311.99 1518.52 L1311.99 1576.64 L1298.5 1576.64 L1298.5 1572.09 L1306.1 1572.09 L1306.1 1523.07 L1298.5 1523.07 L1298.5 1518.52 L1311.99 1518.52 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,1423.18 147.478,47.2441 \"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,1386.13 166.376,1386.13 \"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,1060.54 166.376,1060.54 \"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,734.948 166.376,734.948 \"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,409.359 166.376,409.359 \"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"147.478,83.7699 166.376,83.7699 \"/> <path clip-path=\"url(#clip100)\" d=\"M51.3625 1386.58 L81.0383 1386.58 L81.0383 1390.51 L51.3625 1390.51 L51.3625 1386.58 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M95.1586 1399.47 L111.478 1399.47 L111.478 1403.41 L89.5336 1403.41 L89.5336 1399.47 Q92.1956 1396.72 96.7789 1392.09 Q101.385 1387.43 102.566 1386.09 Q104.811 1383.57 105.691 1381.83 Q106.594 1380.07 106.594 1378.38 Q106.594 1375.63 104.649 1373.89 Q102.728 1372.16 99.6261 1372.16 Q97.4271 1372.16 94.9734 1372.92 Q92.5428 1373.68 89.7651 1375.23 L89.7651 1370.51 Q92.5891 1369.38 95.0428 1368.8 Q97.4965 1368.22 99.5335 1368.22 Q104.904 1368.22 108.098 1370.91 Q111.293 1373.59 111.293 1378.08 Q111.293 1380.21 110.483 1382.13 Q109.696 1384.03 107.589 1386.62 Q107.01 1387.29 103.909 1390.51 Q100.807 1393.71 95.1586 1399.47 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M50.9921 1060.99 L80.6679 1060.99 L80.6679 1064.92 L50.9921 1064.92 L50.9921 1060.99 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M91.5706 1073.88 L99.2095 1073.88 L99.2095 1047.52 L90.8993 1049.18 L90.8993 1044.92 L99.1632 1043.26 L103.839 1043.26 L103.839 1073.88 L111.478 1073.88 L111.478 1077.82 L91.5706 1077.82 L91.5706 1073.88 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M99.5335 720.747 Q95.9224 720.747 94.0937 724.311 Q92.2882 727.853 92.2882 734.983 Q92.2882 742.089 94.0937 745.654 Q95.9224 749.195 99.5335 749.195 Q103.168 749.195 104.973 745.654 Q106.802 742.089 106.802 734.983 Q106.802 727.853 104.973 724.311 Q103.168 720.747 99.5335 720.747 M99.5335 717.043 Q105.344 717.043 108.399 721.649 Q111.478 726.233 111.478 734.983 Q111.478 743.709 108.399 748.316 Q105.344 752.899 99.5335 752.899 Q93.7234 752.899 90.6447 748.316 Q87.5892 743.709 87.5892 734.983 Q87.5892 726.233 90.6447 721.649 Q93.7234 717.043 99.5335 717.043 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M91.5706 422.704 L99.2095 422.704 L99.2095 396.338 L90.8993 398.005 L90.8993 393.746 L99.1632 392.079 L103.839 392.079 L103.839 422.704 L111.478 422.704 L111.478 426.639 L91.5706 426.639 L91.5706 422.704 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M95.1586 97.1148 L111.478 97.1148 L111.478 101.05 L89.5336 101.05 L89.5336 97.1148 Q92.1956 94.3602 96.7789 89.7306 Q101.385 85.0778 102.566 83.7352 Q104.811 81.2121 105.691 79.476 Q106.594 77.7167 106.594 76.0269 Q106.594 73.2723 104.649 71.5362 Q102.728 69.8001 99.6261 69.8001 Q97.4271 69.8001 94.9734 70.564 Q92.5428 71.3279 89.7651 72.8788 L89.7651 68.1566 Q92.5891 67.0223 95.0428 66.4436 Q97.4965 65.8649 99.5335 65.8649 Q104.904 65.8649 108.098 68.5501 Q111.293 71.2353 111.293 75.726 Q111.293 77.8556 110.483 79.7769 Q109.696 81.675 107.589 84.2676 Q107.01 84.9389 103.909 88.1565 Q100.807 91.3509 95.1586 97.1148 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><polyline clip-path=\"url(#clip102)\" style=\"stroke:#009af9; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"209.891,572.153 212.492,572.056 215.093,571.763 217.693,571.274 220.294,570.591 222.894,569.713 225.495,568.642 228.095,567.377 230.696,565.921 233.297,564.275 235.897,562.439 238.498,560.417 241.098,558.208 243.699,555.816 246.299,553.243 248.9,550.491 251.5,547.562 254.101,544.46 256.702,541.187 259.302,537.746 261.903,534.14 264.503,530.373 267.104,526.448 269.704,522.369 272.305,518.14 274.906,513.764 277.506,509.246 280.107,504.589 282.707,499.799 285.308,494.879 287.908,489.834 290.509,484.669 293.109,479.388 295.71,473.997 298.311,468.5 300.911,462.902 303.512,457.209 306.112,451.426 308.713,445.558 311.313,439.611 313.914,433.589 316.515,427.499 319.115,421.346 321.716,415.136 324.316,408.874 326.917,402.566 329.517,396.218 332.118,389.835 334.718,383.424 337.319,376.99 339.92,370.539 342.52,364.076 345.121,357.609 347.721,351.141 350.322,344.68 352.922,338.231 355.523,331.8 358.124,325.392 360.724,319.014 363.325,312.671 365.925,306.368 368.526,300.112 371.126,293.907 373.727,287.76 376.328,281.675 378.928,275.658 381.529,269.715 384.129,263.85 386.73,258.069 389.33,252.377 391.931,246.778 394.531,241.278 397.132,235.881 399.733,230.592 402.333,225.416 404.934,220.357 407.534,215.419 410.135,210.607 412.735,205.924 415.336,201.376 417.937,196.964 420.537,192.694 423.138,188.569 425.738,184.592 428.339,180.766 430.939,177.095 433.54,173.583 436.14,170.23 438.741,167.041 441.342,164.018 443.942,161.164 446.543,158.48 449.143,155.969 451.744,153.633 454.344,151.473 456.945,149.492 459.546,147.69 462.146,146.069 464.747,144.63 467.347,143.375 469.948,142.303 472.548,141.416 475.149,140.714 477.749,140.198 480.35,139.867 482.951,139.721 485.551,139.762 488.152,139.987 490.752,140.397 493.353,140.99 495.953,141.767 498.554,142.727 501.155,143.867 503.755,145.186 506.356,146.685 508.956,148.359 511.557,150.209 514.157,152.232 516.758,154.425 519.359,156.787 521.959,159.316 524.56,162.008 527.16,164.862 529.761,167.874 532.361,171.041 534.962,174.361 537.562,177.83 540.163,181.445 542.764,185.202 545.364,189.099 547.965,193.13 550.565,197.293 553.166,201.584 555.766,205.998 558.367,210.531 560.968,215.18 563.568,219.94 566.169,224.806 568.769,229.774 571.37,234.84 573.97,239.998 576.571,245.244 579.171,250.574 581.772,255.982 584.373,261.463 586.973,267.013 589.574,272.626 592.174,278.297 594.775,284.021 597.375,289.794 599.976,295.608 602.577,301.461 605.177,307.345 607.778,313.256 610.378,319.188 612.979,325.137 615.579,331.096 618.18,337.06 620.781,343.025 623.381,348.984 625.982,354.932 628.582,360.864 631.183,366.775 633.783,372.658 636.384,378.51 638.984,384.325 641.585,390.097 644.186,395.822 646.786,401.493 649.387,407.107 651.987,412.658 654.588,418.142 657.188,423.552 659.789,428.885 662.39,434.136 664.99,439.3 667.591,444.372 670.191,449.348 672.792,454.223 675.392,458.994 677.993,463.655 680.593,468.204 683.194,472.635 685.795,476.944 688.395,481.129 690.996,485.185 693.596,489.108 696.197,492.896 698.797,496.544 701.398,500.05 703.999,503.41 706.599,506.622 709.2,509.683 711.8,512.589 714.401,515.339 717.001,517.93 719.602,520.359 722.202,522.626 724.803,524.727 727.404,526.66 730.004,528.425 732.605,530.019 735.205,531.442 737.806,532.692 740.406,533.767 743.007,534.668 745.608,535.393 748.208,535.942 750.809,536.314 753.409,536.51 756.01,536.528 758.61,536.37 761.211,536.035 763.812,535.524 766.412,534.837 769.013,533.976 771.613,532.94 774.214,531.732 776.814,530.352 779.415,528.801 782.015,527.082 784.616,525.195 787.217,523.144 789.817,520.929 792.418,518.553 795.018,516.019 797.619,513.328 800.219,510.484 802.82,507.489 805.421,504.345 808.021,501.057 810.622,497.628 813.222,494.059 815.823,490.357 818.423,486.522 821.024,482.56 823.624,478.475 826.225,474.27 828.826,469.949 831.426,465.516 834.027,460.977 836.627,456.335 839.228,451.595 841.828,446.761 844.429,441.838 847.03,436.832 849.63,431.747 852.231,426.587 854.831,421.358 857.432,416.066 860.032,410.715 862.633,405.311 865.233,399.859 867.834,394.364 870.435,388.832 873.035,383.269 875.636,377.679 878.236,372.069 880.837,366.444 883.437,360.81 886.038,355.172 888.639,349.536 891.239,343.908 893.84,338.293 896.44,332.698 899.041,327.127 901.641,321.586 904.242,316.082 906.843,310.619 909.443,305.204 912.044,299.841 914.644,294.537 917.245,289.297 919.845,284.126 922.446,279.029 925.046,274.013 927.647,269.081 930.248,264.24 932.848,259.495 935.449,254.85 938.049,250.31 940.65,245.881 943.25,241.567 945.851,237.372 948.452,233.301 951.052,229.359 953.653,225.55 956.253,221.878 958.854,218.347 961.454,214.962 964.055,211.725 966.655,208.64 969.256,205.712 971.857,202.943 974.457,200.337 977.058,197.897 979.658,195.625 982.259,193.524 984.859,191.598 987.46,189.848 990.061,188.277 992.661,186.887 995.262,185.679 997.862,184.656 1000.46,183.818 1003.06,183.169 1005.66,182.707 1008.26,182.436 1010.87,182.354 1013.47,182.464 1016.07,182.765 1018.67,183.258 1021.27,183.943 1023.87,184.819 1026.47,185.887 1029.07,187.145 1031.67,188.594 1034.27,190.232 1036.87,192.058 1039.47,194.07 1042.07,196.268 1044.67,198.65 1047.27,201.213 1049.87,203.957 1052.47,206.877 1055.07,209.973 1057.68,213.242 1060.28,216.68 1062.88,220.284 1065.48,224.053 1068.08,227.981 1070.68,232.067 1073.28,236.306 1075.88,240.694 1078.48,245.227 1081.08,249.901 1083.68,254.713 1086.28,259.657 1088.88,264.729 1091.48,269.923 1094.08,275.237 1096.68,280.663 1099.28,286.198 1101.88,291.836 1104.49,297.571 1107.09,303.398 1109.69,309.312 1112.29,315.307 1114.89,321.376 1117.49,327.515 1120.09,333.717 1122.69,339.976 1125.29,346.286 1127.89,352.641 1130.49,359.035 1133.09,365.461 1135.69,371.913 1138.29,378.385 1140.89,384.87 1143.49,391.361 1146.09,397.853 1148.69,404.339 1151.3,410.812 1153.9,417.266 1156.5,423.695 1159.1,430.092 1161.7,436.45 1164.3,442.763 1166.9,449.025 1169.5,455.23 1172.1,461.37 1174.7,467.441 1177.3,473.435 1179.9,479.347 1182.5,485.171 1185.1,490.9 1187.7,496.529 1190.3,502.053 1192.9,507.464 1195.51,512.759 1198.11,517.931 1200.71,522.976 1203.31,527.887 1205.91,532.66 1208.51,537.29 1211.11,541.773 1213.71,546.103 1216.31,550.276 1218.91,554.288 1221.51,558.134 1224.11,561.812 1226.71,565.316 1229.31,568.644 1231.91,571.791 1234.51,574.755 1237.11,577.533 1239.71,580.121 1242.32,582.517 1244.92,584.719 1247.52,586.724 1250.12,588.53 1252.72,590.136 1255.32,591.539 1257.92,592.739 1260.52,593.734 1263.12,594.523 1265.72,595.105 1268.32,595.48 1270.92,595.648 1273.52,595.608 1276.12,595.36 1278.72,594.906 1281.32,594.245 1283.92,593.378 1286.52,592.306 1289.13,591.031 1291.73,589.554 1294.33,587.877 1296.93,586.001 1299.53,583.928 1302.13,581.662 1304.73,579.204 1307.33,576.558 1309.93,573.725 1312.53,570.71 1315.13,567.516 1317.73,564.146 1320.33,560.604 1322.93,556.894 1325.53,553.021 1328.13,548.987 1330.73,544.798 1333.33,540.459 1335.94,535.975 1338.54,531.349 1341.14,526.588 1343.74,521.697 1346.34,516.681 1348.94,511.545 1351.54,506.296 1354.14,500.939 1356.74,495.48 1359.34,489.926 1361.94,484.281 1364.54,478.554 1367.14,472.749 1369.74,466.874 1372.34,460.934 1374.94,454.937 1377.54,448.889 1380.15,442.797 1382.75,436.668 1385.35,430.508 1387.95,424.324 1390.55,418.123 1393.15,411.912 1395.75,405.698 1398.35,399.487 1400.95,393.287 1403.55,387.104 1406.15,380.946 1408.75,374.818 1411.35,368.729 1413.95,362.684 1416.55,356.69 1419.15,350.754 1421.75,344.882 1424.35,339.081 1426.96,333.357 1429.56,327.717 1432.16,322.167 1434.76,316.713 1437.36,311.36 1439.96,306.116 1442.56,300.985 1445.16,295.973 1447.76,291.086 1450.36,286.328 1452.96,281.706 1455.56,277.225 1458.16,272.888 1460.76,268.702 1463.36,264.67 1465.96,260.797 1468.56,257.087 1471.16,253.544 1473.77,250.172 1476.37,246.974 1478.97,243.955 1481.57,241.116 1484.17,238.462 1486.77,235.996 1489.37,233.718 1491.97,231.633 1494.57,229.743 1497.17,228.048 1499.77,226.552 1502.37,225.255 1504.97,224.158 1507.57,223.264 1510.17,222.572 1512.77,222.084 1515.37,221.8 1517.97,221.719 1520.58,221.842 1523.18,222.169 1525.78,222.699 1528.38,223.431 1530.98,224.364 1533.58,225.497 1536.18,226.829 1538.78,228.358 1541.38,230.082 1543.98,231.999 1546.58,234.107 1549.18,236.403 1551.78,238.885 1554.38,241.549 1556.98,244.393 1559.58,247.413 1562.18,250.606 1564.79,253.967 1567.39,257.494 1569.99,261.181 1572.59,265.026 1575.19,269.023 1577.79,273.167 1580.39,277.455 1582.99,281.881 1585.59,286.44 1588.19,291.127 1590.79,295.936 1593.39,300.863 1595.99,305.901 1598.59,311.045 1601.19,316.289 1603.79,321.627 1606.39,327.053 1608.99,332.562 1611.6,338.146 1614.2,343.8 1616.8,349.517 1619.4,355.291 1622,361.115 1624.6,366.983 1627.2,372.888 1629.8,378.824 1632.4,384.784 1635,390.762 1637.6,396.75 1640.2,402.742 1642.8,408.732 1645.4,414.713 1648,420.678 1650.6,426.621 1653.2,432.535 1655.8,438.413 1658.41,444.249 1661.01,450.037 1663.61,455.77 1666.21,461.442 1668.81,467.047 1671.41,472.578 1674.01,478.029 1676.61,483.395 1679.21,488.669 1681.81,493.846 1684.41,498.92 1687.01,503.885 1689.61,508.737 1692.21,513.469 1694.81,518.077 1697.41,522.555 1700.01,526.899 1702.61,531.104 1705.22,535.165 1707.82,539.078 1710.42,542.838 1713.02,546.442 1715.62,549.885 1718.22,553.164 1720.82,556.275 1723.42,559.214 1726.02,561.979 1728.62,564.567 1731.22,566.974 1733.82,569.198 1736.42,571.236 1739.02,573.087 1741.62,574.747 1744.22,576.216 1746.82,577.491 1749.43,578.572 1752.03,579.456 1754.63,580.143 1757.23,580.632 1759.83,580.922 1762.43,581.013 1765.03,580.904 1767.63,580.596 1770.23,580.089 1772.83,579.382 1775.43,578.478 1778.03,577.375 1780.63,576.076 1783.23,574.582 1785.83,572.894 1788.43,571.013 1791.03,568.941 1793.63,566.681 1796.24,564.234 1798.84,561.602 1801.44,558.789 1804.04,555.797 1806.64,552.628 1809.24,549.287 1811.84,545.775 1814.44,542.096 1817.04,538.255 1819.64,534.254 1822.24,530.098 1824.84,525.79 1827.44,521.334 1830.04,516.735 1832.64,511.998 1835.24,507.126 1837.84,502.125 1840.44,496.999 1843.05,491.753 1845.65,486.393 1848.25,480.922 1850.85,475.347 1853.45,469.673 1856.05,463.905 1858.65,458.048 1861.25,452.109 1863.85,446.092 1866.45,440.004 1869.05,433.851 1871.65,427.637 1874.25,421.369 1876.85,415.053 1879.45,408.695 1882.05,402.3 1884.65,395.875 1887.26,389.426 1889.86,382.958 1892.46,376.478 1895.06,369.991 1897.66,363.504 1900.26,357.023 1902.86,350.554 1905.46,344.102 1908.06,337.674 1910.66,331.275 1913.26,324.911 1915.86,318.588 1918.46,312.313 1921.06,306.089 1923.66,299.924 1926.26,293.823 1928.86,287.791 1931.46,281.833 1934.07,275.956 1936.67,270.164 1939.27,264.462 1941.87,258.855 1944.47,253.349 1947.07,247.949 1949.67,242.658 1952.27,237.482 1954.87,232.425 1957.47,227.492 1960.07,222.686 1962.67,218.013 1965.27,213.475 1967.87,209.078 1970.47,204.824 1973.07,200.717 1975.67,196.76 1978.27,192.958 1980.88,189.312 1983.48,185.827 1986.08,182.505 1988.68,179.348 1991.28,176.359 1993.88,173.54 1996.48,170.895 1999.08,168.424 2001.68,166.129 2004.28,164.013 2006.88,162.076 2009.48,160.32 2012.08,158.747 2014.68,157.357 2017.28,156.152 2019.88,155.131 2022.48,154.295 2025.08,153.645 2027.69,153.181 2030.29,152.903 2032.89,152.81 2035.49,152.903 2038.09,153.18 2040.69,153.642 2043.29,154.287 2045.89,155.114 2048.49,156.122 2051.09,157.31 2053.69,158.675 2056.29,160.218 2058.89,161.935 2061.49,163.825 2064.09,165.885 2066.69,168.113 2069.29,170.508 2071.9,173.065 2074.5,175.784 2077.1,178.66 2079.7,181.69 2082.3,184.872 2084.9,188.202 2087.5,191.678 2090.1,195.294 2092.7,199.048 2095.3,202.936 2097.9,206.955 2100.5,211.099 2103.1,215.365 2105.7,219.749 2108.3,224.247 2110.9,228.853 2113.5,233.565 2116.1,238.376 2118.71,243.283 2121.31,248.281 2123.91,253.364 2126.51,258.528 2129.11,263.769 2131.71,269.081 2134.31,274.458 2136.91,279.897 2139.51,285.391 2142.11,290.936 2144.71,296.527 2147.31,302.158 2149.91,307.823 2152.51,313.518 2155.11,319.237 2157.71,324.975 2160.31,330.727 2162.91,336.486 2165.52,342.249 2168.12,348.009 2170.72,353.761 2173.32,359.5 2175.92,365.22 2178.52,370.917 2181.12,376.584 2183.72,382.217 2186.32,387.811 2188.92,393.36 2191.52,398.86 2194.12,404.304 2196.72,409.689 2199.32,415.01 2201.92,420.26 2204.52,425.437 2207.12,430.534 2209.72,435.548 2212.33,440.473 2214.93,445.306 2217.53,450.041 2220.13,454.675 2222.73,459.203 2225.33,463.622 2227.93,467.927 2230.53,472.114 2233.13,476.179 2235.73,480.119 2238.33,483.931 2240.93,487.61 2243.53,491.154 2246.13,494.559 2248.73,497.823 2251.33,500.941 2253.93,503.913 2256.54,506.734 2259.14,509.402 2261.74,511.915 2264.34,514.271 2266.94,516.467 2269.54,518.501 2272.14,520.373 2274.74,522.079 2277.34,523.619 2279.94,524.991 2282.54,526.194 2285.14,527.227 2287.74,528.089 2290.34,528.78 \"/> <polyline clip-path=\"url(#clip102)\" style=\"stroke:#e26f46; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"209.891,734.948 212.492,715.408 215.093,695.871 217.693,676.356 220.294,656.884 222.894,637.473 225.495,618.143 228.095,598.912 230.696,579.799 233.297,560.823 235.897,542.003 238.498,523.357 241.098,504.903 243.699,486.658 246.299,468.641 248.9,450.868 251.5,433.357 254.101,416.124 256.702,399.186 259.302,382.558 261.903,366.257 264.503,350.297 267.104,334.694 269.704,319.462 272.305,304.616 274.906,290.168 277.506,276.133 280.107,262.523 282.707,249.35 285.308,236.627 287.908,224.365 290.509,212.575 293.109,201.268 295.71,190.453 298.311,180.141 300.911,170.339 303.512,161.057 306.112,152.303 308.713,144.084 311.313,136.407 313.914,129.278 316.515,122.704 319.115,116.689 321.716,111.238 324.316,106.357 326.917,102.047 329.517,98.3129 332.118,95.1567 334.718,92.5805 337.319,90.5857 339.92,89.1734 342.52,88.3439 345.121,88.097 347.721,88.432 350.322,89.3477 352.922,90.8423 355.523,92.9135 358.124,95.5583 360.724,98.7736 363.325,102.555 365.925,106.899 368.526,111.8 371.126,117.253 373.727,123.251 376.328,129.79 378.928,136.86 381.529,144.456 384.129,152.57 386.73,161.193 389.33,170.316 391.931,179.931 394.531,190.027 397.132,200.596 399.733,211.626 402.333,223.107 404.934,235.028 407.534,247.376 410.135,260.141 412.735,273.311 415.336,286.871 417.937,300.811 420.537,315.115 423.138,329.772 425.738,344.767 428.339,360.087 430.939,375.716 433.54,391.641 436.14,407.846 438.741,424.317 441.342,441.039 443.942,457.995 446.543,475.171 449.143,492.551 451.744,510.119 454.344,527.86 456.945,545.756 459.546,563.791 462.146,581.951 464.747,600.217 467.347,618.574 469.948,637.005 472.548,655.494 475.149,674.024 477.749,692.579 480.35,711.142 482.951,729.696 485.551,748.226 488.152,766.714 490.752,785.145 493.353,803.502 495.953,821.769 498.554,839.93 501.155,857.969 503.755,875.871 506.356,893.619 508.956,911.198 511.557,928.594 514.157,945.79 516.758,962.772 519.359,979.525 521.959,996.035 524.56,1012.29 527.16,1028.27 529.761,1043.96 532.361,1059.36 534.962,1074.44 537.562,1089.2 540.163,1103.62 542.764,1117.7 545.364,1131.41 547.965,1144.74 550.565,1157.7 553.166,1170.25 555.766,1182.4 558.367,1194.14 560.968,1205.44 563.568,1216.31 566.169,1226.74 568.769,1236.71 571.37,1246.22 573.97,1255.26 576.571,1263.82 579.171,1271.9 581.772,1279.49 584.373,1286.58 586.973,1293.17 589.574,1299.25 592.174,1304.81 594.775,1309.86 597.375,1314.38 599.976,1318.38 602.577,1321.86 605.177,1324.8 607.778,1327.21 610.378,1329.08 612.979,1330.42 615.579,1331.22 618.18,1331.48 620.781,1331.21 623.381,1330.4 625.982,1329.05 628.582,1327.17 631.183,1324.76 633.783,1321.83 636.384,1318.36 638.984,1314.37 641.585,1309.87 644.186,1304.85 646.786,1299.32 649.387,1293.28 651.987,1286.75 654.588,1279.72 657.188,1272.2 659.789,1264.21 662.39,1255.75 664.99,1246.82 667.591,1237.43 670.191,1227.6 672.792,1217.33 675.392,1206.62 677.993,1195.5 680.593,1183.97 683.194,1172.04 685.795,1159.72 688.395,1147.03 690.996,1133.97 693.596,1120.56 696.197,1106.8 698.797,1092.71 701.398,1078.31 703.999,1063.61 706.599,1048.61 709.2,1033.34 711.8,1017.81 714.401,1002.03 717.001,986.009 719.602,969.772 722.202,953.331 724.803,936.699 727.404,919.893 730.004,902.928 732.605,885.818 735.205,868.579 737.806,851.228 740.406,833.78 743.007,816.251 745.608,798.658 748.208,781.015 750.809,763.34 753.409,745.649 756.01,727.958 758.61,710.283 761.211,692.641 763.812,675.049 766.412,657.521 769.013,640.075 771.613,622.727 774.214,605.494 776.814,588.39 779.415,571.433 782.015,554.638 784.616,538.021 787.217,521.597 789.817,505.383 792.418,489.393 795.018,473.643 797.619,458.147 800.219,442.921 802.82,427.979 805.421,413.336 808.021,399.005 810.622,385.001 813.222,371.337 815.823,358.026 818.423,345.081 821.024,332.516 823.624,320.342 826.225,308.571 828.826,297.216 831.426,286.288 834.027,275.797 836.627,265.755 839.228,256.171 841.828,247.056 844.429,238.418 847.03,230.267 849.63,222.612 852.231,215.46 854.831,208.819 857.432,202.697 860.032,197.101 862.633,192.036 865.233,187.508 867.834,183.523 870.435,180.085 873.035,177.2 875.636,174.87 878.236,173.1 880.837,171.891 883.437,171.247 886.038,171.169 888.639,171.657 891.239,172.714 893.84,174.339 896.44,176.532 899.041,179.291 901.641,182.616 904.242,186.504 906.843,190.952 909.443,195.959 912.044,201.52 914.644,207.63 917.245,214.286 919.845,221.482 922.446,229.211 925.046,237.469 927.647,246.248 930.248,255.541 932.848,265.339 935.449,275.635 938.049,286.419 940.65,297.683 943.25,309.415 945.851,321.607 948.452,334.246 951.052,347.322 953.653,360.824 956.253,374.737 958.854,389.051 961.454,403.751 964.055,418.825 966.655,434.258 969.256,450.036 971.857,466.144 974.457,482.568 977.058,499.291 979.658,516.298 982.259,533.572 984.859,551.098 987.46,568.859 990.061,586.837 992.661,605.015 995.262,623.375 997.862,641.9 1000.46,660.572 1003.06,679.373 1005.66,698.283 1008.26,717.285 1010.87,736.359 1013.47,755.487 1016.07,774.65 1018.67,793.829 1021.27,813.004 1023.87,832.156 1026.47,851.266 1029.07,870.314 1031.67,889.282 1034.27,908.15 1036.87,926.899 1039.47,945.509 1042.07,963.962 1044.67,982.238 1047.27,1000.32 1049.87,1018.19 1052.47,1035.82 1055.07,1053.2 1057.68,1070.31 1060.28,1087.14 1062.88,1103.66 1065.48,1119.86 1068.08,1135.71 1070.68,1151.21 1073.28,1166.34 1075.88,1181.08 1078.48,1195.41 1081.08,1209.32 1083.68,1222.79 1086.28,1235.81 1088.88,1248.37 1091.48,1260.44 1094.08,1272.02 1096.68,1283.1 1099.28,1293.66 1101.88,1303.68 1104.49,1313.17 1107.09,1322.1 1109.69,1330.46 1112.29,1338.26 1114.89,1345.47 1117.49,1352.08 1120.09,1358.1 1122.69,1363.51 1125.29,1368.31 1127.89,1372.49 1130.49,1376.04 1133.09,1378.95 1135.69,1381.24 1138.29,1382.88 1140.89,1383.88 1143.49,1384.24 1146.09,1383.95 1148.69,1383.01 1151.3,1381.43 1153.9,1379.19 1156.5,1376.31 1159.1,1372.79 1161.7,1368.62 1164.3,1363.82 1166.9,1358.38 1169.5,1352.31 1172.1,1345.61 1174.7,1338.3 1177.3,1330.37 1179.9,1321.83 1182.5,1312.7 1185.1,1302.97 1187.7,1292.67 1190.3,1281.8 1192.9,1270.36 1195.51,1258.38 1198.11,1245.86 1200.71,1232.81 1203.31,1219.25 1205.91,1205.2 1208.51,1190.66 1211.11,1175.65 1213.71,1160.18 1216.31,1144.28 1218.91,1127.95 1221.51,1111.22 1224.11,1094.1 1226.71,1076.6 1229.31,1058.76 1231.91,1040.57 1234.51,1022.08 1237.11,1003.29 1239.71,984.215 1242.32,964.888 1244.92,945.325 1247.52,925.545 1250.12,905.571 1252.72,885.423 1255.32,865.122 1257.92,844.69 1260.52,824.148 1263.12,803.52 1265.72,782.826 1268.32,762.089 1270.92,741.33 1273.52,720.574 1276.12,699.841 1278.72,679.154 1281.32,658.535 1283.92,638.007 1286.52,617.591 1289.13,597.311 1291.73,577.187 1294.33,557.243 1296.93,537.498 1299.53,517.976 1302.13,498.697 1304.73,479.683 1307.33,460.953 1309.93,442.53 1312.53,424.431 1315.13,406.679 1317.73,389.292 1320.33,372.288 1322.93,355.688 1325.53,339.509 1328.13,323.769 1330.73,308.485 1333.33,293.674 1335.94,279.352 1338.54,265.536 1341.14,252.24 1343.74,239.48 1346.34,227.268 1348.94,215.62 1351.54,204.547 1354.14,194.062 1356.74,184.177 1359.34,174.902 1361.94,166.247 1364.54,158.223 1367.14,150.838 1369.74,144.101 1372.34,138.018 1374.94,132.596 1377.54,127.842 1380.15,123.76 1382.75,120.355 1385.35,117.631 1387.95,115.591 1390.55,114.237 1393.15,113.569 1395.75,113.59 1398.35,114.298 1400.95,115.693 1403.55,117.774 1406.15,120.536 1408.75,123.979 1411.35,128.096 1413.95,132.884 1416.55,138.337 1419.15,144.449 1421.75,151.213 1424.35,158.621 1426.96,166.664 1429.56,175.334 1432.16,184.62 1434.76,194.512 1437.36,204.998 1439.96,216.067 1442.56,227.706 1445.16,239.902 1447.76,252.64 1450.36,265.907 1452.96,279.687 1455.56,293.964 1458.16,308.723 1460.76,323.947 1463.36,339.617 1465.96,355.718 1468.56,372.229 1471.16,389.134 1473.77,406.411 1476.37,424.043 1478.97,442.008 1481.57,460.287 1484.17,478.859 1486.77,497.703 1489.37,516.798 1491.97,536.122 1494.57,555.653 1497.17,575.369 1499.77,595.249 1502.37,615.269 1504.97,635.408 1507.57,655.642 1510.17,675.95 1512.77,696.307 1515.37,716.691 1517.97,737.08 1520.58,757.451 1523.18,777.781 1525.78,798.046 1528.38,818.226 1530.98,838.296 1533.58,858.235 1536.18,878.02 1538.78,897.63 1541.38,917.043 1543.98,936.237 1546.58,955.19 1549.18,973.883 1551.78,992.294 1554.38,1010.4 1556.98,1028.19 1559.58,1045.64 1562.18,1062.72 1564.79,1079.43 1567.39,1095.73 1569.99,1111.63 1572.59,1127.09 1575.19,1142.1 1577.79,1156.64 1580.39,1170.7 1582.99,1184.27 1585.59,1197.32 1588.19,1209.85 1590.79,1221.84 1593.39,1233.28 1595.99,1244.15 1598.59,1254.45 1601.19,1264.16 1603.79,1273.28 1606.39,1281.79 1608.99,1289.68 1611.6,1296.95 1614.2,1303.59 1616.8,1309.59 1619.4,1314.95 1622,1319.66 1624.6,1323.72 1627.2,1327.12 1629.8,1329.86 1632.4,1331.94 1635,1333.35 1637.6,1334.1 1640.2,1334.18 1642.8,1333.6 1645.4,1332.35 1648,1330.45 1650.6,1327.88 1653.2,1324.66 1655.8,1320.78 1658.41,1316.26 1661.01,1311.1 1663.61,1305.3 1666.21,1298.87 1668.81,1291.83 1671.41,1284.17 1674.01,1275.9 1676.61,1267.05 1679.21,1257.61 1681.81,1247.59 1684.41,1237.01 1687.01,1225.89 1689.61,1214.22 1692.21,1202.03 1694.81,1189.33 1697.41,1176.14 1700.01,1162.46 1702.61,1148.31 1705.22,1133.71 1707.82,1118.67 1710.42,1103.21 1713.02,1087.36 1715.62,1071.11 1718.22,1054.5 1720.82,1037.53 1723.42,1020.24 1726.02,1002.63 1728.62,984.721 1731.22,966.54 1733.82,948.103 1736.42,929.429 1739.02,910.537 1741.62,891.448 1744.22,872.182 1746.82,852.759 1749.43,833.198 1752.03,813.522 1754.63,793.75 1757.23,773.902 1759.83,754 1762.43,734.063 1765.03,714.112 1767.63,694.169 1770.23,674.252 1772.83,654.383 1775.43,634.582 1778.03,614.868 1780.63,595.263 1783.23,575.785 1785.83,556.454 1788.43,537.29 1791.03,518.312 1793.63,499.538 1796.24,480.988 1798.84,462.679 1801.44,444.631 1804.04,426.86 1806.64,409.384 1809.24,392.22 1811.84,375.385 1814.44,358.895 1817.04,342.767 1819.64,327.015 1822.24,311.654 1824.84,296.7 1827.44,282.167 1830.04,268.068 1832.64,254.416 1835.24,241.225 1837.84,228.506 1840.44,216.272 1843.05,204.533 1845.65,193.3 1848.25,182.584 1850.85,172.393 1853.45,162.738 1856.05,153.626 1858.65,145.066 1861.25,137.064 1863.85,129.629 1866.45,122.765 1869.05,116.478 1871.65,110.774 1874.25,105.657 1876.85,101.13 1879.45,97.198 1882.05,93.8623 1884.65,91.1253 1887.26,88.9886 1889.86,87.453 1892.46,86.5188 1895.06,86.1857 1897.66,86.4528 1900.26,87.3187 1902.86,88.7814 1905.46,90.8382 1908.06,93.4859 1910.66,96.7209 1913.26,100.539 1915.86,104.935 1918.46,109.903 1921.06,115.439 1923.66,121.535 1926.26,128.184 1928.86,135.379 1931.46,143.112 1934.07,151.374 1936.67,160.158 1939.27,169.452 1941.87,179.247 1944.47,189.533 1947.07,200.3 1949.67,211.536 1952.27,223.229 1954.87,235.367 1957.47,247.939 1960.07,260.931 1962.67,274.33 1965.27,288.123 1967.87,302.297 1970.47,316.836 1973.07,331.727 1975.67,346.955 1978.27,362.505 1980.88,378.362 1983.48,394.511 1986.08,410.935 1988.68,427.62 1991.28,444.548 1993.88,461.704 1996.48,479.071 1999.08,496.633 2001.68,514.373 2004.28,532.274 2006.88,550.32 2009.48,568.493 2012.08,586.776 2014.68,605.153 2017.28,623.605 2019.88,642.117 2022.48,660.671 2025.08,679.249 2027.69,697.834 2030.29,716.411 2032.89,734.96 2035.49,753.466 2038.09,771.912 2040.69,790.281 2043.29,808.556 2045.89,826.72 2048.49,844.758 2051.09,862.653 2053.69,880.389 2056.29,897.95 2058.89,915.321 2061.49,932.486 2064.09,949.43 2066.69,966.138 2069.29,982.594 2071.9,998.786 2074.5,1014.7 2077.1,1030.32 2079.7,1045.63 2082.3,1060.62 2084.9,1075.28 2087.5,1089.59 2090.1,1103.54 2092.7,1117.13 2095.3,1130.33 2097.9,1143.14 2100.5,1155.55 2103.1,1167.54 2105.7,1179.1 2108.3,1190.24 2110.9,1200.92 2113.5,1211.16 2116.1,1220.94 2118.71,1230.24 2121.31,1239.07 2123.91,1247.42 2126.51,1255.28 2129.11,1262.64 2131.71,1269.5 2134.31,1275.85 2136.91,1281.69 2139.51,1287.01 2142.11,1291.81 2144.71,1296.09 2147.31,1299.84 2149.91,1303.06 2152.51,1305.74 2155.11,1307.9 2157.71,1309.52 2160.31,1310.6 2162.91,1311.15 2165.52,1311.16 2168.12,1310.64 2170.72,1309.58 2173.32,1308 2175.92,1305.88 2178.52,1303.24 2181.12,1300.07 2183.72,1296.38 2186.32,1292.18 2188.92,1287.46 2191.52,1282.24 2194.12,1276.51 2196.72,1270.29 2199.32,1263.58 2201.92,1256.38 2204.52,1248.71 2207.12,1240.57 2209.72,1231.97 2212.33,1222.92 2214.93,1213.42 2217.53,1203.49 2220.13,1193.13 2222.73,1182.35 2225.33,1171.17 2227.93,1159.6 2230.53,1147.63 2233.13,1135.3 2235.73,1122.6 2238.33,1109.55 2240.93,1096.17 2243.53,1082.45 2246.13,1068.43 2248.73,1054.1 2251.33,1039.48 2253.93,1024.6 2256.54,1009.45 2259.14,994.05 2261.74,978.421 2264.34,962.574 2266.94,946.523 2269.54,930.282 2272.14,913.868 2274.74,897.294 2277.34,880.575 2279.94,863.728 2282.54,846.767 2285.14,829.707 2287.74,812.565 2290.34,795.356 \"/> <path clip-path=\"url(#clip100)\" d=\"M220.987 1377.32 L894.244 1377.32 L894.244 1221.8 L220.987 1221.8  Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"1\"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"220.987,1377.32 894.244,1377.32 894.244,1221.8 220.987,1221.8 220.987,1377.32 \"/> <polyline clip-path=\"url(#clip100)\" style=\"stroke:#009af9; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"245.49,1273.64 392.509,1273.64 \"/> <path clip-path=\"url(#clip100)\" d=\"M437.359 1269.97 Q438.956 1267.1 441.178 1265.73 Q443.401 1264.36 446.41 1264.36 Q450.461 1264.36 452.66 1267.21 Q454.859 1270.04 454.859 1275.27 L454.859 1290.92 L450.577 1290.92 L450.577 1275.41 Q450.577 1271.68 449.257 1269.87 Q447.938 1268.07 445.229 1268.07 Q441.919 1268.07 439.998 1270.27 Q438.077 1272.47 438.077 1276.26 L438.077 1290.92 L433.794 1290.92 L433.794 1275.41 Q433.794 1271.66 432.475 1269.87 Q431.155 1268.07 428.401 1268.07 Q425.137 1268.07 423.216 1270.29 Q421.294 1272.49 421.294 1276.26 L421.294 1290.92 L417.012 1290.92 L417.012 1264.99 L421.294 1264.99 L421.294 1269.02 Q422.753 1266.63 424.79 1265.5 Q426.827 1264.36 429.628 1264.36 Q432.452 1264.36 434.419 1265.8 Q436.41 1267.23 437.359 1269.97 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M475.137 1277.88 Q469.975 1277.88 467.984 1279.06 Q465.993 1280.24 465.993 1283.09 Q465.993 1285.36 467.475 1286.7 Q468.979 1288.02 471.549 1288.02 Q475.09 1288.02 477.22 1285.52 Q479.373 1283 479.373 1278.83 L479.373 1277.88 L475.137 1277.88 M483.632 1276.12 L483.632 1290.92 L479.373 1290.92 L479.373 1286.98 Q477.914 1289.34 475.738 1290.48 Q473.563 1291.59 470.414 1291.59 Q466.433 1291.59 464.072 1289.36 Q461.734 1287.12 461.734 1283.37 Q461.734 1278.99 464.651 1276.77 Q467.59 1274.55 473.4 1274.55 L479.373 1274.55 L479.373 1274.13 Q479.373 1271.19 477.428 1269.6 Q475.507 1267.98 472.012 1267.98 Q469.789 1267.98 467.683 1268.51 Q465.576 1269.04 463.632 1270.11 L463.632 1266.17 Q465.97 1265.27 468.169 1264.83 Q470.368 1264.36 472.451 1264.36 Q478.076 1264.36 480.854 1267.28 Q483.632 1270.2 483.632 1276.12 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M508.933 1265.75 L508.933 1269.78 Q507.127 1268.86 505.183 1268.39 Q503.238 1267.93 501.155 1267.93 Q497.984 1267.93 496.386 1268.9 Q494.812 1269.87 494.812 1271.82 Q494.812 1273.3 495.947 1274.16 Q497.081 1274.99 500.507 1275.75 L501.965 1276.08 Q506.502 1277.05 508.4 1278.83 Q510.322 1280.59 510.322 1283.76 Q510.322 1287.37 507.451 1289.48 Q504.604 1291.59 499.604 1291.59 Q497.521 1291.59 495.252 1291.17 Q493.007 1290.78 490.507 1289.97 L490.507 1285.57 Q492.868 1286.79 495.16 1287.42 Q497.451 1288.02 499.697 1288.02 Q502.706 1288.02 504.326 1287 Q505.947 1285.96 505.947 1284.09 Q505.947 1282.35 504.766 1281.42 Q503.609 1280.5 499.65 1279.64 L498.169 1279.3 Q494.211 1278.46 492.451 1276.75 Q490.692 1275.01 490.692 1272 Q490.692 1268.35 493.285 1266.36 Q495.877 1264.36 500.646 1264.36 Q503.007 1264.36 505.09 1264.71 Q507.173 1265.06 508.933 1265.75 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M533.632 1265.75 L533.632 1269.78 Q531.826 1268.86 529.882 1268.39 Q527.937 1267.93 525.854 1267.93 Q522.683 1267.93 521.085 1268.9 Q519.511 1269.87 519.511 1271.82 Q519.511 1273.3 520.646 1274.16 Q521.78 1274.99 525.206 1275.75 L526.664 1276.08 Q531.201 1277.05 533.099 1278.83 Q535.021 1280.59 535.021 1283.76 Q535.021 1287.37 532.15 1289.48 Q529.303 1291.59 524.303 1291.59 Q522.22 1291.59 519.951 1291.17 Q517.706 1290.78 515.206 1289.97 L515.206 1285.57 Q517.567 1286.79 519.859 1287.42 Q522.15 1288.02 524.396 1288.02 Q527.405 1288.02 529.025 1287 Q530.646 1285.96 530.646 1284.09 Q530.646 1282.35 529.465 1281.42 Q528.308 1280.5 524.349 1279.64 L522.868 1279.3 Q518.909 1278.46 517.15 1276.75 Q515.391 1275.01 515.391 1272 Q515.391 1268.35 517.984 1266.36 Q520.576 1264.36 525.345 1264.36 Q527.706 1264.36 529.789 1264.71 Q531.872 1265.06 533.632 1265.75 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M542.405 1285.04 L547.289 1285.04 L547.289 1290.92 L542.405 1290.92 L542.405 1285.04 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M573.4 1265.75 L573.4 1269.78 Q571.594 1268.86 569.65 1268.39 Q567.706 1267.93 565.622 1267.93 Q562.451 1267.93 560.854 1268.9 Q559.28 1269.87 559.28 1271.82 Q559.28 1273.3 560.414 1274.16 Q561.548 1274.99 564.974 1275.75 L566.432 1276.08 Q570.969 1277.05 572.868 1278.83 Q574.789 1280.59 574.789 1283.76 Q574.789 1287.37 571.918 1289.48 Q569.071 1291.59 564.071 1291.59 Q561.988 1291.59 559.719 1291.17 Q557.474 1290.78 554.974 1289.97 L554.974 1285.57 Q557.335 1286.79 559.627 1287.42 Q561.919 1288.02 564.164 1288.02 Q567.173 1288.02 568.793 1287 Q570.414 1285.96 570.414 1284.09 Q570.414 1282.35 569.233 1281.42 Q568.076 1280.5 564.118 1279.64 L562.636 1279.3 Q558.678 1278.46 556.919 1276.75 Q555.159 1275.01 555.159 1272 Q555.159 1268.35 557.752 1266.36 Q560.344 1264.36 565.113 1264.36 Q567.474 1264.36 569.557 1264.71 Q571.641 1265.06 573.4 1265.75 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M606.872 1254.94 Q603.77 1260.27 602.266 1265.48 Q600.761 1270.68 600.761 1276.03 Q600.761 1281.38 602.266 1286.63 Q603.793 1291.86 606.872 1297.17 L603.168 1297.17 Q599.696 1291.73 597.96 1286.47 Q596.247 1281.22 596.247 1276.03 Q596.247 1270.87 597.96 1265.64 Q599.673 1260.41 603.168 1254.94 L606.872 1254.94 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M629.904 1272.28 Q633.261 1273 635.136 1275.27 Q637.034 1277.54 637.034 1280.87 Q637.034 1285.98 633.515 1288.79 Q629.997 1291.59 623.515 1291.59 Q621.339 1291.59 619.025 1291.15 Q616.733 1290.73 614.279 1289.87 L614.279 1285.36 Q616.224 1286.49 618.539 1287.07 Q620.853 1287.65 623.377 1287.65 Q627.775 1287.65 630.066 1285.92 Q632.381 1284.18 632.381 1280.87 Q632.381 1277.81 630.228 1276.1 Q628.099 1274.36 624.279 1274.36 L620.252 1274.36 L620.252 1270.52 L624.464 1270.52 Q627.914 1270.52 629.742 1269.16 Q631.571 1267.77 631.571 1265.17 Q631.571 1262.51 629.673 1261.1 Q627.798 1259.67 624.279 1259.67 Q622.358 1259.67 620.159 1260.08 Q617.96 1260.5 615.321 1261.38 L615.321 1257.21 Q617.983 1256.47 620.298 1256.1 Q622.636 1255.73 624.696 1255.73 Q630.02 1255.73 633.122 1258.16 Q636.224 1260.57 636.224 1264.69 Q636.224 1267.56 634.58 1269.55 Q632.937 1271.52 629.904 1272.28 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M660.066 1272.28 Q663.423 1273 665.298 1275.27 Q667.196 1277.54 667.196 1280.87 Q667.196 1285.98 663.677 1288.79 Q660.159 1291.59 653.677 1291.59 Q651.501 1291.59 649.187 1291.15 Q646.895 1290.73 644.441 1289.87 L644.441 1285.36 Q646.386 1286.49 648.7 1287.07 Q651.015 1287.65 653.538 1287.65 Q657.937 1287.65 660.228 1285.92 Q662.543 1284.18 662.543 1280.87 Q662.543 1277.81 660.39 1276.1 Q658.261 1274.36 654.441 1274.36 L650.413 1274.36 L650.413 1270.52 L654.626 1270.52 Q658.075 1270.52 659.904 1269.16 Q661.733 1267.77 661.733 1265.17 Q661.733 1262.51 659.835 1261.1 Q657.96 1259.67 654.441 1259.67 Q652.52 1259.67 650.321 1260.08 Q648.122 1260.5 645.483 1261.38 L645.483 1257.21 Q648.145 1256.47 650.46 1256.1 Q652.798 1255.73 654.858 1255.73 Q660.182 1255.73 663.284 1258.16 Q666.386 1260.57 666.386 1264.69 Q666.386 1267.56 664.742 1269.55 Q663.099 1271.52 660.066 1272.28 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M676.108 1256.36 L694.464 1256.36 L694.464 1260.29 L680.39 1260.29 L680.39 1268.76 Q681.409 1268.42 682.427 1268.25 Q683.446 1268.07 684.464 1268.07 Q690.251 1268.07 693.631 1271.24 Q697.01 1274.41 697.01 1279.83 Q697.01 1285.41 693.538 1288.51 Q690.066 1291.59 683.747 1291.59 Q681.571 1291.59 679.302 1291.22 Q677.057 1290.85 674.649 1290.11 L674.649 1285.41 Q676.733 1286.54 678.955 1287.1 Q681.177 1287.65 683.654 1287.65 Q687.659 1287.65 689.997 1285.54 Q692.334 1283.44 692.334 1279.83 Q692.334 1276.22 689.997 1274.11 Q687.659 1272 683.654 1272 Q681.779 1272 679.904 1272.42 Q678.052 1272.84 676.108 1273.72 L676.108 1256.36 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M706.27 1256.36 L724.626 1256.36 L724.626 1260.29 L710.552 1260.29 L710.552 1268.76 Q711.57 1268.42 712.589 1268.25 Q713.608 1268.07 714.626 1268.07 Q720.413 1268.07 723.793 1271.24 Q727.172 1274.41 727.172 1279.83 Q727.172 1285.41 723.7 1288.51 Q720.228 1291.59 713.908 1291.59 Q711.733 1291.59 709.464 1291.22 Q707.219 1290.85 704.811 1290.11 L704.811 1285.41 Q706.895 1286.54 709.117 1287.1 Q711.339 1287.65 713.816 1287.65 Q717.82 1287.65 720.158 1285.54 Q722.496 1283.44 722.496 1279.83 Q722.496 1276.22 720.158 1274.11 Q717.82 1272 713.816 1272 Q711.941 1272 710.066 1272.42 Q708.214 1272.84 706.27 1273.72 L706.27 1256.36 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M749.232 1260.43 L737.427 1278.88 L749.232 1278.88 L749.232 1260.43 M748.005 1256.36 L753.885 1256.36 L753.885 1278.88 L758.816 1278.88 L758.816 1282.77 L753.885 1282.77 L753.885 1290.92 L749.232 1290.92 L749.232 1282.77 L733.631 1282.77 L733.631 1278.25 L748.005 1256.36 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M779.394 1260.43 L767.589 1278.88 L779.394 1278.88 L779.394 1260.43 M778.167 1256.36 L784.047 1256.36 L784.047 1278.88 L788.977 1278.88 L788.977 1282.77 L784.047 1282.77 L784.047 1290.92 L779.394 1290.92 L779.394 1282.77 L763.792 1282.77 L763.792 1278.25 L778.167 1256.36 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M810.876 1272.28 Q814.232 1273 816.107 1275.27 Q818.005 1277.54 818.005 1280.87 Q818.005 1285.98 814.487 1288.79 Q810.968 1291.59 804.487 1291.59 Q802.311 1291.59 799.996 1291.15 Q797.704 1290.73 795.251 1289.87 L795.251 1285.36 Q797.195 1286.49 799.51 1287.07 Q801.825 1287.65 804.348 1287.65 Q808.746 1287.65 811.038 1285.92 Q813.352 1284.18 813.352 1280.87 Q813.352 1277.81 811.2 1276.1 Q809.07 1274.36 805.251 1274.36 L801.223 1274.36 L801.223 1270.52 L805.436 1270.52 Q808.885 1270.52 810.713 1269.16 Q812.542 1267.77 812.542 1265.17 Q812.542 1262.51 810.644 1261.1 Q808.769 1259.67 805.251 1259.67 Q803.329 1259.67 801.13 1260.08 Q798.931 1260.5 796.292 1261.38 L796.292 1257.21 Q798.954 1256.47 801.269 1256.1 Q803.607 1255.73 805.667 1255.73 Q810.991 1255.73 814.093 1258.16 Q817.195 1260.57 817.195 1264.69 Q817.195 1267.56 815.551 1269.55 Q813.908 1271.52 810.876 1272.28 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M830.899 1286.98 L847.218 1286.98 L847.218 1290.92 L825.274 1290.92 L825.274 1286.98 Q827.936 1284.23 832.519 1279.6 Q837.125 1274.94 838.306 1273.6 Q840.551 1271.08 841.431 1269.34 Q842.334 1267.58 842.334 1265.89 Q842.334 1263.14 840.389 1261.4 Q838.468 1259.67 835.366 1259.67 Q833.167 1259.67 830.713 1260.43 Q828.283 1261.19 825.505 1262.74 L825.505 1258.02 Q828.329 1256.89 830.783 1256.31 Q833.237 1255.73 835.274 1255.73 Q840.644 1255.73 843.838 1258.42 Q847.033 1261.1 847.033 1265.59 Q847.033 1267.72 846.223 1269.64 Q845.436 1271.54 843.329 1274.13 Q842.75 1274.8 839.649 1278.02 Q836.547 1281.22 830.899 1286.98 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M855.76 1254.94 L859.463 1254.94 Q862.935 1260.41 864.648 1265.64 Q866.384 1270.87 866.384 1276.03 Q866.384 1281.22 864.648 1286.47 Q862.935 1291.73 859.463 1297.17 L855.76 1297.17 Q858.838 1291.86 860.343 1286.63 Q861.871 1281.38 861.871 1276.03 Q861.871 1270.68 860.343 1265.48 Q858.838 1260.27 855.76 1254.94 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><polyline clip-path=\"url(#clip100)\" style=\"stroke:#e26f46; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"245.49,1325.48 392.509,1325.48 \"/> <path clip-path=\"url(#clip100)\" d=\"M437.359 1321.81 Q438.956 1318.94 441.178 1317.57 Q443.401 1316.2 446.41 1316.2 Q450.461 1316.2 452.66 1319.05 Q454.859 1321.88 454.859 1327.11 L454.859 1342.76 L450.577 1342.76 L450.577 1327.25 Q450.577 1323.52 449.257 1321.71 Q447.938 1319.91 445.229 1319.91 Q441.919 1319.91 439.998 1322.11 Q438.077 1324.31 438.077 1328.1 L438.077 1342.76 L433.794 1342.76 L433.794 1327.25 Q433.794 1323.5 432.475 1321.71 Q431.155 1319.91 428.401 1319.91 Q425.137 1319.91 423.216 1322.13 Q421.294 1324.33 421.294 1328.1 L421.294 1342.76 L417.012 1342.76 L417.012 1316.83 L421.294 1316.83 L421.294 1320.86 Q422.753 1318.47 424.79 1317.34 Q426.827 1316.2 429.628 1316.2 Q432.452 1316.2 434.419 1317.64 Q436.41 1319.07 437.359 1321.81 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M475.137 1329.72 Q469.975 1329.72 467.984 1330.9 Q465.993 1332.08 465.993 1334.93 Q465.993 1337.2 467.475 1338.54 Q468.979 1339.86 471.549 1339.86 Q475.09 1339.86 477.22 1337.36 Q479.373 1334.84 479.373 1330.67 L479.373 1329.72 L475.137 1329.72 M483.632 1327.96 L483.632 1342.76 L479.373 1342.76 L479.373 1338.82 Q477.914 1341.18 475.738 1342.32 Q473.563 1343.43 470.414 1343.43 Q466.433 1343.43 464.072 1341.2 Q461.734 1338.96 461.734 1335.21 Q461.734 1330.83 464.651 1328.61 Q467.59 1326.39 473.4 1326.39 L479.373 1326.39 L479.373 1325.97 Q479.373 1323.03 477.428 1321.44 Q475.507 1319.82 472.012 1319.82 Q469.789 1319.82 467.683 1320.35 Q465.576 1320.88 463.632 1321.95 L463.632 1318.01 Q465.97 1317.11 468.169 1316.67 Q470.368 1316.2 472.451 1316.2 Q478.076 1316.2 480.854 1319.12 Q483.632 1322.04 483.632 1327.96 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M508.933 1317.59 L508.933 1321.62 Q507.127 1320.7 505.183 1320.23 Q503.238 1319.77 501.155 1319.77 Q497.984 1319.77 496.386 1320.74 Q494.812 1321.71 494.812 1323.66 Q494.812 1325.14 495.947 1326 Q497.081 1326.83 500.507 1327.59 L501.965 1327.92 Q506.502 1328.89 508.4 1330.67 Q510.322 1332.43 510.322 1335.6 Q510.322 1339.21 507.451 1341.32 Q504.604 1343.43 499.604 1343.43 Q497.521 1343.43 495.252 1343.01 Q493.007 1342.62 490.507 1341.81 L490.507 1337.41 Q492.868 1338.63 495.16 1339.26 Q497.451 1339.86 499.697 1339.86 Q502.706 1339.86 504.326 1338.84 Q505.947 1337.8 505.947 1335.93 Q505.947 1334.19 504.766 1333.26 Q503.609 1332.34 499.65 1331.48 L498.169 1331.14 Q494.211 1330.3 492.451 1328.59 Q490.692 1326.85 490.692 1323.84 Q490.692 1320.19 493.285 1318.2 Q495.877 1316.2 500.646 1316.2 Q503.007 1316.2 505.09 1316.55 Q507.173 1316.9 508.933 1317.59 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M533.632 1317.59 L533.632 1321.62 Q531.826 1320.7 529.882 1320.23 Q527.937 1319.77 525.854 1319.77 Q522.683 1319.77 521.085 1320.74 Q519.511 1321.71 519.511 1323.66 Q519.511 1325.14 520.646 1326 Q521.78 1326.83 525.206 1327.59 L526.664 1327.92 Q531.201 1328.89 533.099 1330.67 Q535.021 1332.43 535.021 1335.6 Q535.021 1339.21 532.15 1341.32 Q529.303 1343.43 524.303 1343.43 Q522.22 1343.43 519.951 1343.01 Q517.706 1342.62 515.206 1341.81 L515.206 1337.41 Q517.567 1338.63 519.859 1339.26 Q522.15 1339.86 524.396 1339.86 Q527.405 1339.86 529.025 1338.84 Q530.646 1337.8 530.646 1335.93 Q530.646 1334.19 529.465 1333.26 Q528.308 1332.34 524.349 1331.48 L522.868 1331.14 Q518.909 1330.3 517.15 1328.59 Q515.391 1326.85 515.391 1323.84 Q515.391 1320.19 517.984 1318.2 Q520.576 1316.2 525.345 1316.2 Q527.706 1316.2 529.789 1316.55 Q531.872 1316.9 533.632 1317.59 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M542.405 1336.88 L547.289 1336.88 L547.289 1342.76 L542.405 1342.76 L542.405 1336.88 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M553.817 1316.83 L558.331 1316.83 L566.432 1338.59 L574.534 1316.83 L579.048 1316.83 L569.326 1342.76 L563.539 1342.76 L553.817 1316.83 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M610.228 1306.78 Q607.127 1312.11 605.622 1317.32 Q604.117 1322.52 604.117 1327.87 Q604.117 1333.22 605.622 1338.47 Q607.15 1343.7 610.228 1349.01 L606.525 1349.01 Q603.053 1343.57 601.316 1338.31 Q599.604 1333.06 599.604 1327.87 Q599.604 1322.71 601.316 1317.48 Q603.029 1312.25 606.525 1306.78 L610.228 1306.78 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M633.261 1324.12 Q636.617 1324.84 638.492 1327.11 Q640.39 1329.38 640.39 1332.71 Q640.39 1337.82 636.872 1340.63 Q633.353 1343.43 626.872 1343.43 Q624.696 1343.43 622.381 1342.99 Q620.09 1342.57 617.636 1341.71 L617.636 1337.2 Q619.58 1338.33 621.895 1338.91 Q624.21 1339.49 626.733 1339.49 Q631.131 1339.49 633.423 1337.76 Q635.738 1336.02 635.738 1332.71 Q635.738 1329.65 633.585 1327.94 Q631.455 1326.2 627.636 1326.2 L623.608 1326.2 L623.608 1322.36 L627.821 1322.36 Q631.27 1322.36 633.099 1321 Q634.927 1319.61 634.927 1317.01 Q634.927 1314.35 633.029 1312.94 Q631.154 1311.51 627.636 1311.51 Q625.714 1311.51 623.515 1311.92 Q621.316 1312.34 618.677 1313.22 L618.677 1309.05 Q621.339 1308.31 623.654 1307.94 Q625.992 1307.57 628.052 1307.57 Q633.376 1307.57 636.478 1310 Q639.58 1312.41 639.58 1316.53 Q639.58 1319.4 637.937 1321.39 Q636.293 1323.36 633.261 1324.12 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M663.423 1324.12 Q666.779 1324.84 668.654 1327.11 Q670.552 1329.38 670.552 1332.71 Q670.552 1337.82 667.034 1340.63 Q663.515 1343.43 657.034 1343.43 Q654.858 1343.43 652.543 1342.99 Q650.251 1342.57 647.798 1341.71 L647.798 1337.2 Q649.742 1338.33 652.057 1338.91 Q654.372 1339.49 656.895 1339.49 Q661.293 1339.49 663.585 1337.76 Q665.899 1336.02 665.899 1332.71 Q665.899 1329.65 663.747 1327.94 Q661.617 1326.2 657.798 1326.2 L653.77 1326.2 L653.77 1322.36 L657.983 1322.36 Q661.432 1322.36 663.261 1321 Q665.089 1319.61 665.089 1317.01 Q665.089 1314.35 663.191 1312.94 Q661.316 1311.51 657.798 1311.51 Q655.876 1311.51 653.677 1311.92 Q651.478 1312.34 648.839 1313.22 L648.839 1309.05 Q651.501 1308.31 653.816 1307.94 Q656.154 1307.57 658.214 1307.57 Q663.538 1307.57 666.64 1310 Q669.742 1312.41 669.742 1316.53 Q669.742 1319.4 668.099 1321.39 Q666.455 1323.36 663.423 1324.12 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M679.464 1308.2 L697.821 1308.2 L697.821 1312.13 L683.747 1312.13 L683.747 1320.6 Q684.765 1320.26 685.784 1320.09 Q686.802 1319.91 687.821 1319.91 Q693.608 1319.91 696.987 1323.08 Q700.367 1326.25 700.367 1331.67 Q700.367 1337.25 696.895 1340.35 Q693.422 1343.43 687.103 1343.43 Q684.927 1343.43 682.659 1343.06 Q680.413 1342.69 678.006 1341.95 L678.006 1337.25 Q680.089 1338.38 682.311 1338.94 Q684.534 1339.49 687.01 1339.49 Q691.015 1339.49 693.353 1337.38 Q695.691 1335.28 695.691 1331.67 Q695.691 1328.06 693.353 1325.95 Q691.015 1323.84 687.01 1323.84 Q685.135 1323.84 683.26 1324.26 Q681.409 1324.68 679.464 1325.56 L679.464 1308.2 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M709.626 1308.2 L727.982 1308.2 L727.982 1312.13 L713.908 1312.13 L713.908 1320.6 Q714.927 1320.26 715.945 1320.09 Q716.964 1319.91 717.982 1319.91 Q723.77 1319.91 727.149 1323.08 Q730.529 1326.25 730.529 1331.67 Q730.529 1337.25 727.057 1340.35 Q723.584 1343.43 717.265 1343.43 Q715.089 1343.43 712.82 1343.06 Q710.575 1342.69 708.168 1341.95 L708.168 1337.25 Q710.251 1338.38 712.473 1338.94 Q714.695 1339.49 717.172 1339.49 Q721.177 1339.49 723.515 1337.38 Q725.853 1335.28 725.853 1331.67 Q725.853 1328.06 723.515 1325.95 Q721.177 1323.84 717.172 1323.84 Q715.297 1323.84 713.422 1324.26 Q711.57 1324.68 709.626 1325.56 L709.626 1308.2 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M752.589 1312.27 L740.783 1330.72 L752.589 1330.72 L752.589 1312.27 M751.362 1308.2 L757.242 1308.2 L757.242 1330.72 L762.172 1330.72 L762.172 1334.61 L757.242 1334.61 L757.242 1342.76 L752.589 1342.76 L752.589 1334.61 L736.987 1334.61 L736.987 1330.09 L751.362 1308.2 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M782.751 1312.27 L770.945 1330.72 L782.751 1330.72 L782.751 1312.27 M781.524 1308.2 L787.403 1308.2 L787.403 1330.72 L792.334 1330.72 L792.334 1334.61 L787.403 1334.61 L787.403 1342.76 L782.751 1342.76 L782.751 1334.61 L767.149 1334.61 L767.149 1330.09 L781.524 1308.2 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M814.232 1324.12 Q817.588 1324.84 819.463 1327.11 Q821.362 1329.38 821.362 1332.71 Q821.362 1337.82 817.843 1340.63 Q814.325 1343.43 807.843 1343.43 Q805.667 1343.43 803.352 1342.99 Q801.061 1342.57 798.607 1341.71 L798.607 1337.2 Q800.552 1338.33 802.866 1338.91 Q805.181 1339.49 807.704 1339.49 Q812.102 1339.49 814.394 1337.76 Q816.709 1336.02 816.709 1332.71 Q816.709 1329.65 814.556 1327.94 Q812.426 1326.2 808.607 1326.2 L804.579 1326.2 L804.579 1322.36 L808.792 1322.36 Q812.241 1322.36 814.07 1321 Q815.899 1319.61 815.899 1317.01 Q815.899 1314.35 814.001 1312.94 Q812.126 1311.51 808.607 1311.51 Q806.686 1311.51 804.487 1311.92 Q802.288 1312.34 799.649 1313.22 L799.649 1309.05 Q802.311 1308.31 804.626 1307.94 Q806.964 1307.57 809.024 1307.57 Q814.348 1307.57 817.45 1310 Q820.551 1312.41 820.551 1316.53 Q820.551 1319.4 818.908 1321.39 Q817.264 1323.36 814.232 1324.12 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M844.394 1324.12 Q847.75 1324.84 849.625 1327.11 Q851.523 1329.38 851.523 1332.71 Q851.523 1337.82 848.005 1340.63 Q844.486 1343.43 838.005 1343.43 Q835.829 1343.43 833.514 1342.99 Q831.223 1342.57 828.769 1341.71 L828.769 1337.2 Q830.713 1338.33 833.028 1338.91 Q835.343 1339.49 837.866 1339.49 Q842.264 1339.49 844.556 1337.76 Q846.871 1336.02 846.871 1332.71 Q846.871 1329.65 844.718 1327.94 Q842.588 1326.2 838.769 1326.2 L834.741 1326.2 L834.741 1322.36 L838.954 1322.36 Q842.403 1322.36 844.232 1321 Q846.061 1319.61 846.061 1317.01 Q846.061 1314.35 844.162 1312.94 Q842.287 1311.51 838.769 1311.51 Q836.848 1311.51 834.649 1311.92 Q832.449 1312.34 829.811 1313.22 L829.811 1309.05 Q832.473 1308.31 834.787 1307.94 Q837.125 1307.57 839.186 1307.57 Q844.51 1307.57 847.611 1310 Q850.713 1312.41 850.713 1316.53 Q850.713 1319.4 849.07 1321.39 Q847.426 1323.36 844.394 1324.12 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip100)\" d=\"M859.116 1306.78 L862.82 1306.78 Q866.292 1312.25 868.005 1317.48 Q869.741 1322.71 869.741 1327.87 Q869.741 1333.06 868.005 1338.31 Q866.292 1343.57 862.82 1349.01 L859.116 1349.01 Q862.195 1343.7 863.699 1338.47 Q865.227 1333.22 865.227 1327.87 Q865.227 1322.52 863.699 1317.32 Q862.195 1312.11 859.116 1306.78 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /></svg>","category":"page"},{"location":"examples/inputs/#Unload-FMU","page":"Inputs","title":"Unload FMU","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"unloadFMU(fmu)","category":"page"},{"location":"deprecated/#deprecated-Functions","page":"Deprecated","title":"deprecated Functions","text":"","category":"section"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"this doc page is necessary as all exported functions must be documented in the manual with documenter configured to check for missing documentation, therefor this hidden page exists","category":"page"},{"location":"deprecated/#internal-functions:-remove-export?","page":"Deprecated","title":"internal functions: remove export?","text":"","category":"section"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"fmi2CallbackFunctions","category":"page"},{"location":"deprecated/#FMICore.fmi2CallbackFunctions","page":"Deprecated","title":"FMICore.fmi2CallbackFunctions","text":"Source: FMISpec2.0.2[p.19-22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nThe struct contains pointers to functions provided by the environment to be used by the FMU. It is not allowed to change these functions between fmi2Instantiate(..) and fmi2Terminate(..) calls. Additionally, a pointer to the environment is provided (componentEnvironment) that needs to be passed to the ‚Äúlogger‚Äù function, in order that the logger function can utilize data from the environment, such as mapping a valueReference to a string. In the unlikely case that fmi2Component is also needed in the logger, it has to be passed via argument componentEnvironment. Argument componentEnvironment may be a null pointer. The componentEnvironment pointer is also passed to the stepFinished(..) function in order that the environment can provide an efficient way to identify the slave that called stepFinished(..).\n\n\n\n\n\n","category":"type"},{"location":"deprecated/#deprecated","page":"Deprecated","title":"deprecated","text":"","category":"section"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"Mostly wrappers that are not supposed to be used (call specific wrapped functions instead)","category":"page"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"all gone since 0.14.0 (nice)","category":"page"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"","category":"page"},{"location":"examples/multithreading/#Multithreading","page":"Multithreading","title":"Multithreading","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Tutorial by Jonas Wilfert, Tobias Thummerer","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"üöß This tutorial is under revision and will be replaced by an up-to-date version soon üöß","category":"page"},{"location":"examples/multithreading/#License","page":"Multithreading","title":"License","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar, Jonas Wilfert\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/multithreading/#Motivation","page":"Multithreading","title":"Motivation","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/multithreading/#Introduction-to-the-example","page":"Multithreading","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"This example shows how to parallelize the computation of an FMU in FMI.jl. We can compute a batch of FMU-evaluations in parallel with different initial settings. Parallelization can be achieved using multithreading or using multiprocessing. This example shows multithreading, check multiprocessing.ipynb for multiprocessing. Advantage of multithreading is a lower communication overhead as well as lower RAM usage. However in some cases multiprocessing can be faster as the garbage collector is not shared.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"The model used is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"(Image: svg)  ","category":"page"},{"location":"examples/multithreading/#Target-group","page":"Multithreading","title":"Target group","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/multithreading/#Other-formats","page":"Multithreading","title":"Other formats","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/multithreading/#Getting-started","page":"Multithreading","title":"Getting started","text":"","category":"section"},{"location":"examples/multithreading/#Installation-prerequisites","page":"Multithreading","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install FMICore via add FMICore add \" https://github.com/ThummeTo/FMICore.jl \"\n5. Install Folds via add Folds \n6. Install BenchmarkTools via add BenchmarkTools ","category":"page"},{"location":"examples/multithreading/#Code-section","page":"Multithreading","title":"Code section","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"# imports\nusing FMI\nusing FMIZoo\nusing Folds\nusing BenchmarkTools","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"First, check the amount of available threads:","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Threads.nthreads()","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"If the number of available threads doesn't match your expections, you can increase the number of threads available to the Julia process like described here.","category":"page"},{"location":"examples/multithreading/#Simulation-setup","page":"Multithreading","title":"Simulation setup","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Next, the start time and end time of the simulation are set. Here we also decide the size of the batch.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"t_start = 0.0\nt_step = 0.1\nt_stop = 10.0\ntspan = (t_start, t_stop)\ntData = collect(t_start:t_step:t_stop)\n\n# Best if batchSize is a multiple of the threads/cores\nbatchSize = Threads.nthreads()\n\n# Define an array of arrays randomly\ninput_values = collect(collect.(eachrow(rand(batchSize,2))))\n","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"We need to instantiate one FMU for each parallel execution, as they cannot be easily shared among different threads.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"# a single FMU to compare the performance\nrealFMU = fmiLoad(\"SpringPendulum1D\", \"Dymola\", \"2022x\")\n\n# the FMU batch\nrealFMUBatch = [fmiLoad(\"SpringPendulum1D\", \"Dymola\", \"2022x\") for _ in 1:batchSize]","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"We define a helper function to calculate the FMU solution and combine it into an Matrix.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"function runCalcFormatted(fmu::FMU2, x0::Vector{Float64}, recordValues::Vector{String}=[\"mass.s\", \"mass.v\"])\n    data = fmiSimulateME(fmu, tspan; recordValues=recordValues, saveat=tData, x0=x0, showProgress=false, dtmax=1e-4)\n    return reduce(hcat, data.states.u)\nend","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Running a single evaluation is pretty quick, therefore the speed can be better tested with BenchmarkTools.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"@benchmark data = runCalcFormatted(realFMU, rand(2))","category":"page"},{"location":"examples/multithreading/#Single-Threaded-Batch-Execution","page":"Multithreading","title":"Single Threaded Batch Execution","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"To compute a batch we can collect multiple evaluations. In a single threaded context we can use the same FMU for every call.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"println(\"Single Threaded\")\n@benchmark collect(runCalcFormatted(realFMU, i) for i in input_values)","category":"page"},{"location":"examples/multithreading/#Multithreaded-Batch-Execution","page":"Multithreading","title":"Multithreaded Batch Execution","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"In a multithreaded context we have to provide each thread it's own fmu, as they are not thread safe. To spread the execution of a function to multiple threads, the library Folds can be used.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"println(\"Multi Threaded\")\n@benchmark Folds.collect(runCalcFormatted(fmu, i) for (fmu, i) in zip(realFMUBatch, input_values))","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"As you can see, there is a significant speed-up in the median execution time. But: The speed-up is often much smaller than Threads.nthreads(), this has different reasons. For a rule of thumb, the speed-up should be around n/2 on a n-core-processor with n threads for the Julia process.","category":"page"},{"location":"examples/multithreading/#Unload-FMU","page":"Multithreading","title":"Unload FMU","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"After calculating the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"fmiUnload(realFMU)\nfmiUnload.(realFMUBatch)","category":"page"},{"location":"examples/multithreading/#Summary","page":"Multithreading","title":"Summary","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"In this tutorial it is shown how multi threading with Folds.jl can be used to improve the performance for calculating a Batch of FMUs.","category":"page"},{"location":"fmi2_lowlevel_library_constants/#FMI2-Types-in-FMI-Import/Core-.jl","page":"FMI2 Types in FMI Import/Core .jl","title":"FMI2 Types in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi2_lowlevel_library_constants/","page":"FMI2 Types in FMI Import/Core .jl","title":"FMI2 Types in FMI Import/Core .jl","text":"FMU2\nFMU2Component\nFMU2ComponentEnvironment\nFMI2Struct\nfmi2Initial\nfmi2ScalarVariable\nfmi2SimpleType\nfmi2Type\nfmi2BaseUnit\nfmi2Unit\nfmi2DisplayUnit\nfmi2Char\nfmi2Variability\nfmi2VariableDependency\nfmi2DependencyKind\nfmi2EventInfo\nfmi2Status\nfmi2Annotation\nfmi2ModelDescription\nfmi2FMUstate\nfmi2StatusKind\nfmi2VariableNamingConvention\nfmi2Causality\nfmi2ComponentState","category":"page"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.FMU2","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.FMU2","text":"The mutable struct representing a FMU (and a container for all its instances) in the FMI 2.0.2 Standard. Also contains the paths to the FMU and ZIP folder as well als all the FMI 2.0.2 function pointers.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.FMU2Component","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.FMU2Component","text":"The mutable struct represents an allocated instance of an FMU in the FMI 2.0.2 Standard.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.FMU2ComponentEnvironment","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.FMU2ComponentEnvironment","text":"Source: FMISpec 2.0.3 [p.16f]\n\nThis is a pointer to a data structure in the simulation environment that calls the FMU. Using this pointer, data from the modelDescription.xml file [(for example, mapping of valueReferences to variable names)] can be transferred between the simulation environment and the logger function (see [FMISpec 2.0.3] section 2.1.5).\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.FMI2Struct","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.FMI2Struct","text":"FMI2Struct\n\nA wildcard for FMI2 related structs, namely Union{FMU2, fmi2ModelDescription, FMU2Component}.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Initial","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Initial","text":"Source: FMISpec2.0.2[p.48]: 2.2.7 Definition of Model Variables (ModelVariables)\n\nEnumeration that defines how the variable is initialized. It is not allowed to provide a value for initial if causality = \"input\" or \"independent\":\n\n\"exact\": The variable is initialized with the start value (provided under Real, Integer, Boolean, String or Enumeration). \"approx\": The variable is an iteration variable of an algebraic loop and the iteration at initialization starts with the start value. \"calculated\": The variable is calculated from other variables during initialization. It is not allowed to provide a ‚Äústart‚Äù value. If initial is not present, it is defined by the table below based on causality and variability. If initial = exact or approx, or causality = ‚Ä≥input‚Ä≥, a start value must be provided. If initial = calculated, or causality = ‚Ä≥independent‚Ä≥, it is not allowed to provide a start value. If fmiSetXXX is not called on a variable with causality = ‚Ä≥input‚Ä≥, then the FMU must use the start value as value of this input. Added prefix \"fmi2\" to help with redefinition of constans in enums.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2ScalarVariable","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2ScalarVariable","text":"Source: FMISpec2.0.2[p.46]: 2.2.7 Definition of Model Variables (ModelVariables)\n\nThe fmi2ScalarVariable specifies the type and argument of every exposed variable in the fmu\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2SimpleType","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2SimpleType","text":"Source: FMISpec2.0.3[p.40]: 2.2.3 Definition of Types (TypeDefinitions)\n\nThe fmi2SimpleType describes the attributes of a type definition.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Type","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Type","text":"Source: FMISpec2.0.2[p.19]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nArgument fmuType defines the type of the FMU:\n\nfmi2ModelExchange: FMU with initialization and events; between events simulation of continuous systems is performed with external integrators from the environment.\nfmi2CoSimulation: Black box interface for co-simulation.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2BaseUnit","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2BaseUnit","text":"Source: FMISpec2.0.3[p.35]: 2.2.2 Definition of Units (UnitDefinitions)\n\nfmi2BaseUnit(\n    kg=0, m=0, s=0, A=0, K=0, mol=0, cd=0, rad=0, factor=1.0, offset=0.0)\n\nType for the optional ‚ÄúBaseUnit‚Äù field of an fmi2Unit.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Unit","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Unit","text":"Source: FMISpec2.0.3[p.35]: 2.2.2 Definition of Units (UnitDefinitions)\n\nElement ‚ÄúUnitDefinitions ‚Äù of fmiModelDescription.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2DisplayUnit","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2DisplayUnit","text":"Source: FMISpec2.0.3[p.35]: 2.2.2 Definition of Units (UnitDefinitions)\n\nfmi2DisplayUnit(name, factor=1.0, offset=0.0)\n\nType for the optional ‚ÄúDisplayUnit‚Äù field(s) of an fmi2Unit.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Char","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Char","text":"Source: FMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nFMI2 Data Types To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section. All definitions in this section are provided in the header file ‚Äúfmi2TypesPlatform.h‚Äù.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Variability","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Variability","text":"Source: FMISpec2.0.2[p.49]: 2.2.7 Definition of Model Variables (ModelVariables)\n\nEnumeration that defines the time dependency of the variable, in other words, it defines the time instants when a variable can change its value.\n\n\"constant\": The value of the variable never changes. \"fixed\": The value of the variable is fixed after initialization, in other words, after fmi2ExitInitializationMode was called the variable value does not change anymore. \"tunable\": The value of the variable is constant between external events (ModelExchange) and between Communication Points (Co-Simulation) due to changing variables with causality = \"parameter\" or \"input\" and variability = \"tunable\". Whenever a parameter or input signal with variability = \"tunable\" changes, an event is triggered externally (ModelExchange), or the change is performed at the next Communication Point (Co-Simulation) and the variables with variability = \"tunable\" and causality = \"calculatedParameter\" or \"output\" must be newly computed. \"discrete\": ModelExchange: The value of the variable is constant between external and internal events (= time, state, step events defined implicitly in the FMU). Co-Simulation: By convention, the variable is from a ‚Äúreal‚Äù sampled data system and its value is only changed at Communication Points (also inside the slave). \"continuous\": Only a variable of type = ‚ÄúReal‚Äù can be ‚Äúcontinuous‚Äù. ModelExchange: No restrictions on value changes. Co-Simulation: By convention, the variable is from a differential The default is ‚Äúcontinuous‚Äù. Added prefix \"fmi2\" to help with redefinition of constans in enums.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2VariableDependency","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2VariableDependency","text":"Mutable Struct representing existance and kind of dependencies of an Unknown on Known Variables in Continuous-Time and Event Mode (ME) and at Communication Points (CS)\n\nSee also FMI2.0.3 Spec fmi2VariableDependency [p.60]\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2DependencyKind","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2DependencyKind","text":"Types of dependency:\n\nfmi2DependencyKindDependent: no particular structure, f(v)\nfmi2DependencyKindConstant: constant factor, c*v (for Real valued variables only)\nfmi2DependencyKindFixed: tunable factor, p*v (for Real valued variables only)\nfmi2DependencyKindTunable [ToDo]\nfmi2DependencyKindDiscrete [ToDo]\n\nSource: FMI2.0.3 Spec for fmi2VariableDependency [p.60] \n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2EventInfo","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2EventInfo","text":"Source: FMISpec2.0.2[p.84]: 3.2.2 Evaluation of Model Equations\n\nIf return argument fmi2eventInfo.newDiscreteStatesNeeded = fmi2True, the FMU should stay in Event Mode, and the FMU requires to set new inputs to the FMU (fmi2SetXXX on inputs) to compute and get the outputs (fmi2GetXXX on outputs) and to call fmi2NewDiscreteStates again. Depending on the connection with other FMUs, the environment shall\n\ncall fmi2Terminate, if terminateSimulation = fmi2True is returned by at least one FMU.\ncall fmi2EnterContinuousTimeMode if all FMUs return newDiscreteStatesNeeded = fmi2False.\nstay in Event Mode otherwise.\n\nWhen the FMU is terminated, it is assumed that an appropriate message is printed by the logger function (see section 2.1.5) to explain the reason for the termination. If nominalsOfContinuousStatesChanged = fmi2True, then the nominal values of the states have changed due to the function call and can be inquired with fmi2GetNominalsOfContinuousStates. If valuesOfContinuousStatesChanged = fmi2True. then at least one element of the continuous state vector has changed its value due to the function call. The new values of the states can be retrieved with fmi2GetContinuousStates or individually for each state for which reinit = \"true\" by calling getReal. If no element of the continuous state vector has changed its value, valuesOfContinuousStatesChanged must return fmi2False. [If fmi2True would be returned in this case, an infinite event loop may occur.] If nextEventTimeDefined = fmi2True, then the simulation shall integrate at most until time = nextEventTime, and shall call fmi2EnterEventMode at this time instant. If integration is stopped before nextEventTime, for example, due to a state event, the definition of nextEventTime becomes obsolete.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Status","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Status","text":"Source: FMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nStatus returned by functions. The status has the following meaning:\n\nfmi2OK ‚Äì all well\nfmi2Warning ‚Äì things are not quite right, but the computation can continue. Function ‚Äúlogger‚Äù was called in the model (see below), and it is expected that this function has shown the prepared information message to the user.\nfmi2Discard ‚Äì this return status is only possible if explicitly defined for the corresponding function\n\n(ModelExchange: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2SetContinuousStates, fmi2GetReal, fmi2GetDerivatives, fmi2GetContinuousStates, fmi2GetEventIndicators; CoSimulation: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2DoStep, fmiGetXXXStatus): For ‚Äúmodel exchange‚Äù: It is recommended to perform a smaller step size and evaluate the model equations again, for example because an iterative solver in the model did not converge or because a function is outside of its domain (for example sqrt(<negative number>)). If this is not possible, the simulation has to be terminated. For ‚Äúco-simulation‚Äù: fmi2Discard is returned also if the slave is not able to return the required status information. The master has to decide if the simulation run can be continued. In both cases, function ‚Äúlogger‚Äù was called in the FMU (see below) and it is expected that this function has shown the prepared information message to the user if the FMU was called in debug mode (loggingOn = fmi2True). Otherwise, ‚Äúlogger‚Äù should not show a message.\n\nfmi2Error ‚Äì the FMU encountered an error. The simulation cannot be continued with this FMU instance. If one of the functions returns fmi2Error, it can be tried to restart the simulation from a formerly stored FMU state by calling fmi2SetFMUstate.\n\nThis can be done if the capability flag canGetAndSetFMUstate is true and fmi2GetFMUstate was called before in non-erroneous state. If not, the simulation cannot be continued and fmi2FreeInstance or fmi2Reset must be called afterwards.4 Further processing is possible after this call; especially other FMU instances are not affected. Function ‚Äúlogger‚Äù was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user.\n\nfmi2Fatal ‚Äì the model computations are irreparably corrupted for all FMU instances. [For example, due to a run-time exception such as access violation or integer division by zero during the execution of an fmi function]. Function ‚Äúlogger‚Äù was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user. It is not possible to call any other function for any of the FMU instances.\nfmi2Pending ‚Äì this status is returned only from the co-simulation interface, if the slave executes the function in an asynchronous way. That means the slave starts to compute but returns immediately. The master has to call fmi2GetStatus(..., fmi2DoStepStatus) to determine if the slave has finished the computation. Can be returned only by fmi2DoStep and by fmi2GetStatus (see section 4.2.3).\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Annotation","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Annotation","text":"A not further specified annotation struct.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2ModelDescription","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2ModelDescription","text":"Source: FMISpec2.0.2[p.34]: 2.2.1 Definition of an FMU (fmiModelDescription)\n\nThe ‚ÄúModelVariables‚Äù element of fmiModelDescription is the central part of the model description. It provides the static information of all exposed variables.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2FMUstate","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2FMUstate","text":"fmi2FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant. This allows to restart a simulation from a previous FMU state.\n\nSource: FMI2.0.3 Spec [p.17]; See also section 2.1.8\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2StatusKind","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2StatusKind","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nCoSimulation specific Enum representing state of FMU after fmi2DoStep returned fmi2Pending.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2VariableNamingConvention","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2VariableNamingConvention","text":"ToDo \n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Causality","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Causality","text":"Source: FMISpec2.0.2[p.48]: 2.2.7 Definition of Model Variables (ModelVariables)\n\nEnumeration that defines the causality of the variable. Allowed values of this enumeration:\n\n\"parameter\": Independent parameter (a data value that is constant during the simulation and is provided by the environment and cannot be used in connections). variability must be \"fixed\" or \"tunable\". initial must be exact or not present (meaning exact). \"calculatedParameter\": A data value that is constant during the simulation and is computed during initialization or when tunable parameters change. variability must be \"fixed\" or \"tunable\". initial must be \"approx\", \"calculated\" or not present (meaning calculated). \"input\": The variable value can be provided from another model or slave. It is not allowed to define initial. \"output\": The variable value can be used by another model or slave. The algebraic relationship to the inputs is defined via the dependencies attribute of <fmiModelDescription><ModelStructure><Outputs><Unknown>. \"local\": Local variable that is calculated from other variables or is a continuous-time state (see section 2.2.8). It is not allowed to use the variable value in another model or slave. \"independent\": The independent variable (usually ‚Äútime‚Äù). All variables are a function of this independent variable. variability must be \"continuous\". At most one ScalarVariable of an FMU can be defined as \"independent\". If no variable is defined as \"independent\", it is implicitly present with name = \"time\" and unit = \"s\". If one variable is defined as \"independent\", it must be defined as \"Real\" without a \"start\" attribute. It is not allowed to call function fmi2SetReal on an \"independent\" variable. Instead, its value is initialized with fmi2SetupExperiment and after initialization set by fmi2SetTime for ModelExchange and by arguments currentCommunicationPoint and communicationStepSize of fmi2DoStep for CoSimulation. [The actual value can be inquired with fmi2GetReal.] The default of causality is ‚Äúlocal‚Äù. A continuous-time state must have causality = \"local\" or \"output\", see also section 2.2.8. [causality = \"calculatedParameter\" and causality = \"local\" with variability = \"fixed\" or \"tunable\" are similar. The difference is that a calculatedParameter can be used in another model or slave, whereas a local variable cannot. For example, when importing an FMU in a Modelica environment, a \"calculatedParameter\" should be imported in a public section as final parameter, whereas a \"local\" variable should be imported in a protected section of the model.] Added prefix \"fmi2\" to help with redefinition of constans in enums.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentState","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentState","text":"ToDo \n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/","page":"FMI2 Types in FMI Import/Core .jl","title":"FMI2 Types in FMI Import/Core .jl","text":"fmi2StructMD FMU2Solution FMIImport.fmi2ValueReferenceFormat FMU2Event FMU2ExecutionConfiguration","category":"page"},{"location":"fmi2_lowlevel_library_constants/#FMI2-Constants-in-FMI-Import/Core-.jl","page":"FMI2 Types in FMI Import/Core .jl","title":"FMI2 Constants in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi2_lowlevel_library_constants/","page":"FMI2 Types in FMI Import/Core .jl","title":"FMI2 Types in FMI Import/Core .jl","text":"fmi2True\nfmi2ComponentStateInstantiated\nfmi2ComponentStateInitializationMode\nfmi2ComponentStateEventMode\nfmi2ComponentStateContinuousTimeMode\nfmi2ComponentStateTerminated\nfmi2ComponentStateError\nfmi2ComponentStateFatal","category":"page"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2True","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2True","text":"Source: FMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nTo simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section. All definitions in this section are provided in the header file ‚Äúfmi2TypesPlatform.h‚Äù.\n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateInstantiated","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateInstantiated","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateInitializationMode","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateInitializationMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateEventMode","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateEventMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateContinuousTimeMode","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateContinuousTimeMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateTerminated","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateTerminated","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateError","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateError","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateFatal","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateFatal","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/","page":"FMI2 Types in FMI Import/Core .jl","title":"FMI2 Types in FMI Import/Core .jl","text":"fmi2False fmi2StatusOK fmi2StatusWarning fmi2StatusPending fmi2StatusError fmi2StatusDiscard fmi2StatusFatal","category":"page"},{"location":"fmi2_lowlevel_ME_functions/#FMI-for-Model-Exchange","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"","category":"section"},{"location":"fmi2_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"This chapter contains the interface description to access the equations of a dynamic system from a C program.","category":"page"},{"location":"fmi2_lowlevel_ME_functions/#Providing-Independent-Variables-and-Re-initialization-of-Caching","page":"FMI for Model Exchange","title":"Providing Independent Variables and Re-initialization of Caching","text":"","category":"section"},{"location":"fmi2_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"Depending on the situation, different variables need to be computed. In order to be efficient, it is important that the interface requires only the computation of variables that are needed in the present context. The state derivatives shall be reused from the previous call. This feature is called ‚Äúcaching of variables‚Äù in the sequel. Caching requires that the model evaluation can detect when the input arguments, like time or states, have changed.","category":"page"},{"location":"fmi2_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"fmi2SetTime\nfmi2SetContinuousStates","category":"page"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2SetTime","page":"FMI for Model Exchange","title":"FMICore.fmi2SetTime","text":"Source: FMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSet a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).\n\n\n\n\n\nfmi2SetTime(c::FMU2Component, \n                time::fmi2Real; \n                soft::Bool=false,\n                track::Bool=true,\n                force::Bool=c.fmu.executionConfig.force,\n                time_shift::Bool=c.fmu.executionConfig.autoTimeShift)\n\nSet a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ntime::fmi2Real: Argument time contains a value of type fmi2Real which is a alias type for Real data type. time sets the independent variable time t.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\n-track::Bool=true: If the Keyword track = true\n\ntime_shift::Bool=c.fmu.executionConfig.autoTimeShift:\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSee also fmi2SetTime.\n\n\n\n\n\nfmiSetTime(c::FMU2Component, t::Real)\n\nSet a new time instant and re-initialize caching of variables that depend on time.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nt::Real: Argument t contains a value of type Real. t sets the independent variable time t.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSee also fmi2SetTime\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2SetContinuousStates","page":"FMI for Model Exchange","title":"FMICore.fmi2SetContinuousStates","text":"Source: FMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSet a new (continuous) state vector and re-initialize caching of variables that depend on the states. Argument nx is the length of vector x and is provided for checking purposes\n\n\n\n\n\nfmiSetContinuousStates(c::FMU2Component,\n                             x::Union{AbstractArray{Float32},AbstractArray{Float64}})\n\nSet a new (continuous) state vector and reinitialize chaching of variables that depend on states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx::Union{AbstractArray{Float32},AbstractArray{Float64}}:Argument x is the AbstractArray of the vector values of Float64 or Float32.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSee also fmi2SetContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#Evaluation-of-Model-Equations","page":"FMI for Model Exchange","title":"Evaluation of Model Equations","text":"","category":"section"},{"location":"fmi2_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"fmi2EnterEventMode\nfmi2NewDiscreteStates\nfmi2NewDiscreteStates!\nfmi2EnterContinuousTimeMode\nfmi2CompletedIntegratorStep\nfmi2CompletedIntegratorStep!\nfmi2GetDerivatives\nfmi2GetDerivatives!\nfmi2GetEventIndicators\nfmi2GetEventIndicators!\nfmi2GetContinuousStates\nfmi2GetContinuousStates!\nfmi2GetNominalsOfContinuousStates\nfmi2GetNominalsOfContinuousStates!","category":"page"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2EnterEventMode","page":"FMI for Model Exchange","title":"FMICore.fmi2EnterEventMode","text":"Source: FMISpec2.0.2[p.84]: 3.2.2 Evaluation of Model Equations\n\nThe model enters Event Mode from the Continuous-Time Mode and discrete-time equations may become active (and relations are not ‚Äúfrozen‚Äù).\n\n\n\n\n\nfmi2EnterEventMode(c::FMU2Component; soft::Bool=false)\n\nThe model enters Event Mode from the Continuous-Time Mode and discrete-time equations may become active (and relations are not ‚Äúfrozen‚Äù).\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2EnterEventMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMIImport.fmi2NewDiscreteStates","page":"FMI for Model Exchange","title":"FMIImport.fmi2NewDiscreteStates","text":"fmi2NewDiscreteStates(c::FMU2Component)\n\nReturns the next discrete states\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\neventInfo::fmi2EventInfo*: Strut with fmi2Boolean Variables\n\nMore detailed:\n\nnewDiscreteStatesNeeded::fmi2Boolean: If newDiscreteStatesNeeded = fmi2True the FMU should stay in Event Mode, and the FMU requires to set new inputs to the FMU to compute and get the outputs and to call\n\nfmi2NewDiscreteStates again. If all FMUs return newDiscreteStatesNeeded = fmi2False call fmi2EnterContinuousTimeMode.\n\nterminateSimulation::fmi2Boolean: If terminateSimulation = fmi2True call fmi2Terminate\nnominalsOfContinuousStatesChanged::fmi2Boolean: If nominalsOfContinuousStatesChanged = fmi2True then the nominal values of the states have changed due to the function call and can be inquired with fmi2GetNominalsOfContinuousStates.\nvaluesOfContinuousStatesChanged::fmi2Boolean: If valuesOfContinuousStatesChanged = fmi2True, then at least one element of the continuous state vector has changed its value due to the function call. The new values of the states can be retrieved with fmi2GetContinuousStates. If no element of the continuous state vector has changed its value, valuesOfContinuousStatesChanged must return fmi2False.\nnextEventTimeDefined::fmi2Boolean: If nextEventTimeDefined = fmi2True, then the simulation shall integrate at most until time = nextEventTime, and shall call fmi2EnterEventMode at this time instant. If integration is stopped before nextEventTime, the definition of nextEventTime becomes obsolete.\nnextEventTime::fmi2Real: next event if nextEventTimeDefined=fmi2True\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2NewDiscreteStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2NewDiscreteStates!","page":"FMI for Model Exchange","title":"FMICore.fmi2NewDiscreteStates!","text":"Source: FMISpec2.0.2[p.84]: 3.2.2 Evaluation of Model Equations\n\nThe FMU is in Event Mode and the super dense time is incremented by this call.\n\n\n\n\n\nfmi2NewDiscreteStates!(c::FMU2Component, eventInfo::fmi2EventInfo)\n\nThe FMU is in Event Mode and the super dense time is incremented by this call.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\neventInfo::fmi2EventInfo*: Strut with fmi2Boolean Variables that\n\nMore detailed:\n\nnewDiscreteStatesNeeded::fmi2Boolean: If newDiscreteStatesNeeded = fmi2True the FMU should stay in Event Mode, and the FMU requires to set new inputs to the FMU to compute and get the outputs and to call\n\nfmi2NewDiscreteStates again. If all FMUs return newDiscreteStatesNeeded = fmi2False call fmi2EnterContinuousTimeMode.\n\nterminateSimulation::fmi2Boolean: If terminateSimulation = fmi2True call fmi2Terminate\nnominalsOfContinuousStatesChanged::fmi2Boolean: If nominalsOfContinuousStatesChanged = fmi2True then the nominal values of the states have changed due to the function call and can be inquired with fmi2GetNominalsOfContinuousStates.\nvaluesOfContinuousStatesChanged::fmi2Boolean: If valuesOfContinuousStatesChanged = fmi2True, then at least one element of the continuous state vector has changed its value due to the function call. The new values of the states can be retrieved with fmi2GetContinuousStates. If no element of the continuous state vector has changed its value, valuesOfContinuousStatesChanged must return fmi2False.\nnextEventTimeDefined::fmi2Boolean: If nextEventTimeDefined = fmi2True, then the simulation shall integrate at most until time = nextEventTime, and shall call fmi2EnterEventMode at this time instant. If integration is stopped before nextEventTime, the definition of nextEventTime becomes obsolete.\nnextEventTime::fmi2Real: next event if nextEventTimeDefined=fmi2True\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2NewDiscreteStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2EnterContinuousTimeMode","page":"FMI for Model Exchange","title":"FMICore.fmi2EnterContinuousTimeMode","text":"Source: FMISpec2.0.2[p.85]: 3.2.2 Evaluation of Model Equations\n\nThe model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are ‚Äúfrozen‚Äù. This function has to be called when changing from Event Mode (after the global event iteration in Event Mode over all involved FMUs and other models has converged) into Continuous-Time Mode.\n\n\n\n\n\nfmi2EnterContinuousTimeMode(c::FMU2Component; soft::Bool=false)\n\nThe model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are ‚Äúfrozen‚Äù. This function has to be called when changing from Event Mode (after the global event iteration in Event Mode over all involved FMUs and other models has converged) into Continuous-Time Mode.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2EnterContinuousTimeMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMIImport.fmi2CompletedIntegratorStep","page":"FMI for Model Exchange","title":"FMIImport.fmi2CompletedIntegratorStep","text":"fmiCompletedIntegratorStep(c::FMU2Component, noSetFMUStatePriorToCurrentPoint::fmi2Boolean)\n\nThis function must be called by the environment after every completed step\n\nArguments\n\nC::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nnoSetFMUStatePriorToCurrentPoint::fmi2Boolean: Argument noSetFMUStatePriorToCurrentPoint = fmi2True if fmi2SetFMUState  will no longer be called for time instants prior to current time in this simulation run.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\nenterEventMode::Array{fmi2Boolean, 1}: Returns enterEventMode[1] to signal to the environment if the FMU shall call fmi2EnterEventMode\nterminateSimulation::Array{fmi2Boolean, 1}: Returns terminateSimulation[1] to signal if the simulation shall be terminated.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2CompletedIntegratorStep.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2CompletedIntegratorStep!","page":"FMI for Model Exchange","title":"FMICore.fmi2CompletedIntegratorStep!","text":"Source: FMISpec2.0.2[p.85]: 3.2.2 Evaluation of Model Equations\n\nThis function must be called by the environment after every completed step of the integrator provided the capability flag completedIntegratorStepNotNeeded = false. If enterEventMode == fmi2True, the event mode must be entered If terminateSimulation == fmi2True, the simulation shall be terminated\n\n\n\n\n\nfmi2CompletedIntegratorStep!(c::FMU2Component,\n                                noSetFMUStatePriorToCurrentPoint::fmi2Boolean,\n                                enterEventMode::Ptr{fmi2Boolean},\n                                terminateSimulation::Ptr{fmi2Boolean})\n\nThis function must be called by the environment after every completed step of the integrator provided the capability flag completedIntegratorStepNotNeeded = false.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nnoSetFMUStatePriorToCurrentPoint::fmi2Boolean: Argument noSetFMUStatePriorToCurrentPoint = fmi2True if fmi2SetFMUState  will no longer be called for time instants prior to current time in this simulation run.\nenterEventMode::Ref{fmi2Boolean}: Argument enterEventMode points to the return value (fmi2Boolean) which signals to the environment if the FMU shall call fmi2EnterEventMode. fmi2Boolean is an alias type for Boolean data type.\nterminateSimulation::Ref{fmi2Boolean}: Argument terminateSimulation points to the return value (fmi2Boolean) which signals signal if the simulation shall be terminated. fmi2Boolean is an alias type for Boolean data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2CompletedIntegratorStep!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMIImport.fmi2GetDerivatives","page":"FMI for Model Exchange","title":"FMIImport.fmi2GetDerivatives","text":"fmi2GetDerivatives(c::FMU2Component)\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nderivatives::Array{fmi2Real}: Returns an array of fmi2Real values representing the derivatives for the current states. The ordering of the elements of the derivatives vector is identical to the ordering of the state\n\nvector.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetDerivatives!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2GetDerivatives!","page":"FMI for Model Exchange","title":"FMICore.fmi2GetDerivatives!","text":"Source: FMISpec2.0.2[p.86]: 3.2.2 Evaluation of Model Equations\n\nCompute state derivatives at the current time instant and for the current states.\n\n\n\n\n\nfmi2GetDerivatives!(c::FMU2Component,\n                   derivatives::AbstractArray{fmi2Real},\n                   nx::Csize_t)\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nderivatives::AbstractArray{fmi2Real}: Argument derivatives contains values of type fmi2Real which is a alias type for Real data type.derivatives is the AbstractArray which contains the Real values of the vector that represent the derivatives. The ordering of the elements of the derivatives vector is identical to the ordering of the state vector.\nnx::Csize_t: Argument nx defines the length of vector derivatives and is provided for checking purposes\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetDerivatives!.\n\n\n\n\n\nfmi2GetDerivatives!(c::FMU2Component, derivatives::AbstractArray{fmi2Real})\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nderivatives::Array{fmi2Real}: Stores fmi2Real values representing the derivatives for the current states. The ordering of the elements of the derivatives vector is identical to the ordering of the state vector.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetDerivatives!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMIImport.fmi2GetEventIndicators","page":"FMI for Model Exchange","title":"FMIImport.fmi2GetEventIndicators","text":"fmi2GetEventIndicators(c::FMU2Component)\n\nReturns the event indicators of the FMU\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\neventIndicators::Array{fmi2Real}:The event indicators are returned as a vector represented by an array of \"fmi2Real\" values.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2GetEventIndicators!","page":"FMI for Model Exchange","title":"FMICore.fmi2GetEventIndicators!","text":"Source: FMISpec2.0.2[p.86]: 3.2.2 Evaluation of Model Equations\n\nCompute event indicators at the current time instant and for the current states.\n\n\n\n\n\nfmi2GetEventIndicators!(c::FMU2Component, eventIndicators::AbstractArray{fmi2Real}, ni::Csize_t)\n\nCompute event indicators at the current time instant and for the current states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\neventIndicators::AbstractArray{fmi2Real}: Argument eventIndicators contains values of type fmi2Real which is a alias type for Real data type.eventIndicators is the AbstractArray which contains the Real values of the vector that represent the event indicators.\nni::Csize_t: Argument ni defines the length of vector eventIndicators and is provided for checking purposes\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\nfmi2GetEventIndicators!(c::FMU2Component, eventIndicators::AbstractArray{fmi2Real})\n\nReturns the event indicators of the FMU.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\neventIndicators::AbstractArray{fmi2Real}:The event indicators are in an AbstractArray represented by an array of \"fmi2Real\" values.\n\nReturns\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMIImport.fmi2GetContinuousStates","page":"FMI for Model Exchange","title":"FMIImport.fmi2GetContinuousStates","text":"fmi2GetContinuousStates(c::FMU2Component)\n\nReturn the new (continuous) state vector x\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nx::Array{fmi2Real}: Returns an array of fmi2Real values representing the new continuous state vector x.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2GetContinuousStates!","page":"FMI for Model Exchange","title":"FMICore.fmi2GetContinuousStates!","text":"Source: FMISpec2.0.2[p.86]: 3.2.2 Evaluation of Model Equations\n\nReturn the new (continuous) state vector x.\n\n\n\n\n\nfmi2GetContinuousStates!(c::FMU2Component,\n                            x::AbstractArray{fmi2Real},\n                            nx::Csize_t)\n\nStores the new (continuous) state vector in x.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx::AbstractArray{fmi2Real}: Argument x contains values of type fmi2Real which is a alias type for Real data type.x is the AbstractArray which contains the Real values of the vector that represent the new state vector.\nnx::Csize_t: Argument nx defines the length of vector x and is provided for checking purposes\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMIImport.fmi2GetNominalsOfContinuousStates","page":"FMI for Model Exchange","title":"FMIImport.fmi2GetNominalsOfContinuousStates","text":"fmi2GetNominalsOfContinuousStates(c::FMU2Component)\n\nReturn the new (continuous) state vector x\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nx::Array{fmi2Real}: Returns an array of fmi2Real values representing the new continuous state vector x.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetNominalsOfContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2GetNominalsOfContinuousStates!","page":"FMI for Model Exchange","title":"FMICore.fmi2GetNominalsOfContinuousStates!","text":"Source: FMISpec2.0.2[p.86]: 3.2.2 Evaluation of Model Equations\n\nReturn the nominal values of the continuous states.\n\n\n\n\n\nfmi2GetNominalsOfContinuousStates!(c::FMU2Component, x_nominal::AbstractArray{fmi2Real}, nx::Csize_t)\n\nStores the nominal values of the continuous states in x_nominal.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx_nominal::AbstractArray{fmi2Real}: Argument x_nominal contains values of type fmi2Real which is a alias type for Real data type.x_nominal is the AbstractArray which contains the Real values of the vector that represent the nominal values of the continuous states.\nnx::Csize_t: Argument nx defines the length of vector x and is provided for checking purposes\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"examples/simulate/#Simulate-an-FMU-in-different-modes","page":"Simulate","title":"Simulate an FMU in different modes","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"üöß This tutorial is under revision and will be replaced by an up-to-date version soon üöß","category":"page"},{"location":"examples/simulate/#License","page":"Simulate","title":"License","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/simulate/#Motivation","page":"Simulate","title":"Motivation","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/simulate/#Introduction-to-the-example","page":"Simulate","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In this example we want to show how fast and easy the simulation for an FMU is. For this purpose, the FMU is simulated in co-simulation mode and in model-exchange mode. After the FMU has been simulated, the simulation results are displayed in a graph. The graphs of the different modes are compared with each other. The used model is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"(Image: svg)  ","category":"page"},{"location":"examples/simulate/#Target-group","page":"Simulate","title":"Target group","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/simulate/#Other-formats","page":"Simulate","title":"Other formats","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/simulate/#Getting-started","page":"Simulate","title":"Getting started","text":"","category":"section"},{"location":"examples/simulate/#Installation-prerequisites","page":"Simulate","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install Plots via add Plots ","category":"page"},{"location":"examples/simulate/#Code-section","page":"Simulate","title":"Code section","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots","category":"page"},{"location":"examples/simulate/#Simulation-setup","page":"Simulate","title":"Simulation setup","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Next, the start time and end time of the simulation are set. Finally, a step size is specified to store the results of the simulation at these time steps.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"tStart = 0.0\ntStep = 0.01\ntStop = 8.0\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/simulate/#Import-FMU","page":"Simulate","title":"Import FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\")\n\nmyFMU = fmiLoad(pathToFMU)\n# fmiLoad(\"path/to/myFMU.fmu\"; unpackPath = \"path/to/unpacked/fmu/\")\n\nfmiInfo(myFMU)","category":"page"},{"location":"examples/simulate/#Simulate-FMU","page":"Simulate","title":"Simulate FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In the following, the FMU is simulated in the two different simulation modes.","category":"page"},{"location":"examples/simulate/#Simulate-as-Co-Simulation","page":"Simulate","title":"Simulate as Co-Simulation","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In the next steps the recorded values are defined. The first state is the position of the mass and the second state is the velocity. In the function fmiSimulateCS() the FMU is simulated in co-simulation mode (CS) with an adaptive step size but with fixed save points tSave. In addition, the start and end time and the recorded variables are specified.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"vrs = [\"mass.s\", \"mass.v\"]\n\ndataCS = fmiSimulateCS(myFMU, (tStart, tStop); recordValues=vrs, saveat=tSave)","category":"page"},{"location":"examples/simulate/#Simulate-as-Model-Exchange","page":"Simulate","title":"Simulate as Model-Exchange","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In the function fmiSimulateME() the FMU is simulated in model-exchange mode (ME) with an adaptive step size but with fixed save points tSave. In addition, the start and end time are specified. In contrast to the co-simulation, the values to be stored are not specified here, since the states and events of the FMU are always output as well. The identifiers given above just correspond to the states of the FMU.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"dataME = fmiSimulateME(myFMU, (tStart, tStop); saveat=tSave)","category":"page"},{"location":"examples/simulate/#Plotting-FMU","page":"Simulate","title":"Plotting FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"After the simulation is finished the results of the FMU for the co-simulation and model-exchange mode can be plotted. In the plot for the FMU it can be seen that the oscillation continues to decrease due to the effect of the friction. If you simulate long enough, the oscillation comes to a standstill in a certain time.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"fmiPlot(dataCS)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"fmiPlot(dataME)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"From both graphs it can be seen that the simulation calculates exactly the same results.","category":"page"},{"location":"examples/simulate/#Unload-FMU","page":"Simulate","title":"Unload FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"fmiUnload(myFMU)","category":"page"},{"location":"examples/simulate/#Summary","page":"Simulate","title":"Summary","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Based on this tutorial it can be seen that simulating in the different mode is very easy, and it only takes a few commands to simulate the FMU. ","category":"page"},{"location":"fmi3_lowlevel_library_constants/#FMI3-Types-in-FMI-Import/Core-.jl","page":"FMI3 Types in FMI Import/Core .jl","title":"FMI3 Types in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi3_lowlevel_library_constants/","page":"FMI3 Types in FMI Import/Core .jl","title":"FMI3 Types in FMI Import/Core .jl","text":"FMU3\nFMU3Instance\nFMU3InstanceEnvironment\nFMI3Struct\nfmi3Instance\nfmi3InstanceEnvironment\nfmi3InstanceState\nfmi3FMUState\nfmi3Initial\nfmi3ValueReference\nfmi3Variable\nfmi3VariableDependency\nfmi3Binary\nfmi3SimpleType\nfmi3Type\nfmi3Unit\nfmi3Boolean\nfmi3Byte\nfmi3Char\nfmi3Float32\nfmi3Float64\nfmi3Int8\nfmi3Int16\nfmi3Int32\nfmi3Int64\nfmi3UInt8\nfmi3UInt16\nfmi3UInt32\nfmi3UInt64\nfmi3String\nfmi3Clock\nfmi3IntervalQualifier\nfmi3Variability\nfmi3DependencyKind\nfmi3Status\nfmi3Annotation\nfmi3ModelDescription\nfmi3VariableNamingConvention\nfmi3Causality","category":"page"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.FMU3","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.FMU3","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.1. Header Files and Naming of Functions\n\nThe mutable struct representing an FMU in the FMI 3.0 Standard. Also contains the paths to the FMU and ZIP folder as well als all the FMI 3.0 function pointers\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.FMU3Instance","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.FMU3Instance","text":"Source: FMISpec3.0, Version D5ef1c1:: 2.2.1. Header Files and Naming of Functions\n\nThe mutable struct represents a pointer to an FMU specific data structure that contains the information needed to process the model equations or to process the co-simulation of the model/subsystem represented by the FMU.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.FMU3InstanceEnvironment","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.FMU3InstanceEnvironment","text":"This is a pointer to a data structure in the importer. Using this pointer, data may be transferred between the importer and callback functions the importer provides with the instantiation functions.\n\nSource: FMISpec 3.0.1 [2.2.3. Platform Dependent Definitions]\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.FMI3Struct","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.FMI3Struct","text":"FMI3Struct\n\nA wildcard for FMI3 related structs, namely Union{FMU3, fmi3ModelDescription, FMU3Instance}.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Instance","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Instance","text":"fmi3Instance (alias for Ptr{Cvoid})\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3InstanceEnvironment","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3InstanceEnvironment","text":"fmi3InstanceEnvironment (alias for Ptr{Cvoid})\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceState","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceState","text":"ToDo \n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3FMUState","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3FMUState","text":"fmi3FMUState (alias for Ptr{Cvoid})\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Initial","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Initial","text":"Source: FMISpec3.0, Version D5ef1c1:2.4.7.5. Type specific properties Enumeration that defines how the variable is initialized, i.e. if a fmi3Set{VariableType} is allowed and how the FMU internally treats this value in Instantiated and Initialization Mode. For the variable with causality = independent, the attribute initial must not be provided, because its start value is set with the startTime parameter of fmi3EnterInitializationMode.\n\nThe attribute initial for other variables can have the following values and meanings:\n\nexact - The variable is initialized with the start value (provided under the variable type element).\n\napprox - The start value provides an approximation that may be modified during initialization, e.g., if the FMU is part of an algebraic loop where the variable might be an iteration variable and start value is taken as initial value for an iterative solution process.\n\ncalculated - The variable is calculated from other variables during initialization. It is not allowed to provide a start value.\n\nIf initial is not present, it is defined by Table 22 based on causality and variability. If initial = exact or approx, or causality = input, a start value must be provided. If initial = calculated, or causality = independent, it is not allowed to provide a start value.\n\n[The environment decides when to use the start value of a variable with causality = input. Examples: * Automatic tests of FMUs are performed, and the FMU is tested by providing the start value as constant input. * For a Model Exchange FMU, the FMU might be part of an algebraic loop. If the input variable is iteration variable of this algebraic loop, then initialization starts with its start value.]\n\nIf fmi3Set{VariableType} is not called on a variable with causality = input, then the FMU must use the start value as value of this input.\n\nAdded prefix \"fmi3\" to help with redefinition of constans in enums.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3ValueReference","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3ValueReference","text":"fmi3ValueReference (alias for Cuint)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Variable","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Variable","text":"Source: FMISpec3.0, Version D5ef1c1: 2.4.7. Definition of Model Variables\n\nA fmi3Variable describes the the type, name, valueRefence and optional information for every variable in the Modeldescription.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3VariableDependency","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3VariableDependency","text":"Mutable Struct representing existance and kind of dependencies of an Unknown on Known Variables.\n\nSee also FMI3.0.1 Spec [fig 30]\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Binary","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Binary","text":"fmi3Binary (alias for Ptr{fmi3Byte})\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3SimpleType","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3SimpleType","text":"ToDo: Not implemented\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Type","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Type","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable\n\nArgument fmuType defines the type of the FMU:\n\nfmi3ModelExchange: FMU with initialization and events; between events simulation of continuous systems is performed with external integrators from the environment.\nfmi3CoSimulation: Black box interface for co-simulation.\nfmi3ScheduledExecution: Concurrent computation of model partitions on a single computational resource (e.g. CPU-core)\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Unit","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Unit","text":"ToDo: Not implemented\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Boolean","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Boolean","text":"fmi3Boolean (alias for Cuchar)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Byte","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Byte","text":"fmi3Byte (alias for Cuchar)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Char","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Char","text":"fmi3Char (alias for Cuchar)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Float32","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Float32","text":"fmi3Float32 (alias for Cfloat)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Float64","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Float64","text":"fmi3Float64 (alias for Cdouble)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Int8","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Int8","text":"fmi3Int8 (alias for Cchar)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Int16","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Int16","text":"fmi3Int16 (alias for Cshort)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Int32","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Int32","text":"fmi3Int32 (alias for Cint)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Int64","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Int64","text":"fmi3Int64 (alias for Clonglong)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3UInt8","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3UInt8","text":"fmi3UInt8 (alias for Cuchar)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3UInt16","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3UInt16","text":"fmi3UInt16 (alias for Cushort)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3UInt32","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3UInt32","text":"fmi3UInt32 (alias for Cuint)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3UInt64","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3UInt64","text":"fmi3UInt64 (alias for Culonglong)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3String","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3String","text":"fmi3String (alias for Ptr{fmi3Char})\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Clock","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Clock","text":"fmi3Clock (alias for Cint)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3IntervalQualifier","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3IntervalQualifier","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.9.4. Scheduled Execution Enumeration that defines the IntervalQualifiers which describe how to treat the intervals and intervalCounters arguments. They have the following meaning: fmi3IntervalNotYetKnown -  is returned for a countdown aperiodic Clock for which the next interval is not yet known. This qualifier value can only be returned directly after the Clock was active and previous calls to fmi3GetInterval never returned fmi3IntervalChanged (nor fmi3IntervalUnchanged). In Scheduled Execution this return value means that the corresponding model partition cannot be scheduled yet.\n\nfmi3IntervalUnchanged - is returned if a previous call to fmi3GetInterval already returned a value qualified with fmi3IntervalChanged which has not changed since. In Scheduled Execution this means the corresponding model partition has already been scheduled.\n\nfmi3IntervalChanged - is returned to indicate that the value for the interval has changed for this Clock. Any previously returned intervals (if any) are overwritten with the current value. The new Clock interval is relative to the time of the current Event Mode or Clock Update Mode in contrast to the interval of a periodic Clock, where the interval is defined as the time between consecutive Clock ticks. In Scheduled Execution this means that the corresponding model partition has to be scheduled or re-scheduled (if a previous call to fmi3GetInterval returned fmi3IntervalChanged).\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Variability","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Variability","text":"Source: FMISpec3.0, Version D5ef1c1: 2.4.7.4. Variable Attributes Enumeration that defines the time dependency of the variable, in other words, it defines the time instants when a variable can change its value. [The purpose of this attribute is to define when a result value needs to be inquired and to be stored. For example, discrete variables change their values only at event instants (ME) or at a communication point (CS and SE) and it is therefore only necessary to inquire them with fmi3Get{VariableType} and store them at event times.] Allowed values of this enumeration: constant - The value of the variable never changes.\n\nfixed - The value of the variable is fixed after initialization, in other words, after fmi3ExitInitializationMode was called the variable value does not change anymore.\n\ntunable - The value of the variable is constant between events (ME) and between communication points (CS and SE) due to changing variables with causality = parameter and variability = tunable. Whenever a parameter with variability = tunable changes, an event is triggered externally (ME or CS if events are supported), or the change is performed at the next communication point (CS and SE) and the variables with variability = tunable and causality = calculatedParameter or output must be newly computed. [tunable inputs are not allowed, see Table 18.]\n\ndiscrete - Model Exchange: The value of the variable is constant between external and internal events (= time, state, step events defined implicitly in the FMU). Co-Simulation: By convention, the variable is from a real sampled data system and its value is only changed at communication points (including event handling). During intermediateUpdate, discrete variables are not allowed to change. [If the simulation algorithm notices a change in a discrete variable during intermediateUpdate, the simulation algorithm will delay the change, raise an event with earlyReturnRequested == fmi3True and during the communication point it can change the discrete variable, followed by event handling.]\n\ncontinuous - Only a variable of type == fmi3GetFloat32 or type == fmi3GetFloat64 can be continuous. Model Exchange: No restrictions on value changes (see Section 4.1.1).\n\nThe default is continuous for variables of type <Float32> and <Float64>, and discrete for all other types.\n\nFor variables of type Clock and clocked variables the variability is always discrete or tunable.\n\n[Note that the information about continuous states is defined with elements <ContinuousStateDerivative> in <ModelStructure>.]\n\nAdded prefix \"fmi3\" to help with redefinition of constans in enums.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3DependencyKind","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3DependencyKind","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.10. Dependencies of Variables\n\nEnumeration that defines the dependencies a single unknown variable vunknown can have in relation to a known variable vknown. They have the following meaning: dependent - no particular structure, f(.., v_{known,i}, ..)\n\nOnly for floating point type unknowns v_{unknown}:\n\nconstant - constant factor, c ‚ãÖ v_{known,i} where c is an expression that is evaluated before fmi3EnterInitializationMode is called.\n\nOnly for floating point type unknowns v_{unknown} in Event and Continuous-Time Mode (ME) and at communication points (CS and SE), and not for <InitialUnknown> for Initialization Mode:\n\nfixed - fixed factor, p‚ãÖv_{known,i} where p is an expression that is evaluated before fmi3ExitInitializationMode is called.\n\ntunable - tunable factor, p‚ãÖv_{known,i} where p is an expression that is evaluated before fmi3ExitInitializationMode is called and in Event Mode due to event handling (ME) or at a communication point (CS and SE)\n\ndiscrete - discrete factor, d‚ãÖv_{known,i} where d is an expression that is evaluated before fmi3ExitInitializationMode is called and in Event Mode due to an external or internal event or at a communication point (CS and SE).\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Status","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Status","text":"Defines the status flag (an enumeration of type fmi3Status defined in file fmi3FunctionTypes.h) that is returned by functions to indicate the success of the function call: The status has the following meaning:\n\nfmi3OK: The call was successful. The output argument values are defined.\nfmi3Warning: A non-critical problem was detected, but the computation can continue. The output argument values are defined. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings.\n\n[In certain applications, e.g. in a prototyping environment, warnings may be acceptable. For production environments warnings should be treated like errors unless they can be safely ignored.]\n\nfmi3Discard: The call was not successful and the FMU is in the same state as before the call. The output argument values are not defined, but the computation can continue. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. Advanced simulation algorithms can try alternative approaches to drive the simulation by calling the function with different arguments or calling another function. Otherwise the simulation algorithm has to treat this return code like fmi3Error and has to terminate the simulation.\n\n[Examples for usage of fmi3Discard are handling of min/max violation, or signal numerical problems during model evaluation forcing smaller step sizes.]\n\nfmi3Error: The call failed. The output argument values are undefined and the simulation cannot be continued. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. If a function returns fmi3Error, it is possible to restore a previously retrieved FMU state by calling fmi3SetFMUState. Otherwise fmi3FreeInstance or fmi3Reset must be called. When detecting illegal arguments or a function call not allowed in the current state according to the respective state machine, the FMU must return fmi3Error. Other instances of this FMU are not affected by the error.\nfmi3Fatal: The state of all instances of the model is irreparably corrupted. [For example, due to a runtime exception such as access violation or integer division by zero during the execution of an FMI function.] Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings, if still possible. It is not allowed to call any other function for any instance of the FMU.\n\nSource: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Annotation","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Annotation","text":"A not further specified annotation struct.\n\nSource: [ToDo]\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3ModelDescription","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3ModelDescription","text":"Source: FMISpec3.0, Version D5ef1c1: 2.4.1. Definition of an FMU\n\nThe central FMU data structure defining all variables of the FMU that are visible/accessible via the FMU functions.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3VariableNamingConvention","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3VariableNamingConvention","text":"[TODO]\n\nSource: FMISpec3.0, Version D5ef1c1: 2.4.7.5.1. Variable Naming Conventions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Causality","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Causality","text":"Source: FMISpec3.0, Version D5ef1c1: 2.4.7.4. Variable Attributes Enumeration that defines the causality of the variable. Allowed values of this enumeration:\n\nparameter - A data value that is constant during the simulation (except for tunable parameters, see there) and is provided by the environment and cannot be used in connections, except for parameter propagation in terminals as described in Section 2.4.9.2.6. variability must be fixed or tunable. These parameters can be changed independently, unlike calculated parameters. initial must be exact or not present (meaning exact).\n\ncalculatedParameter - A data value that is constant during the simulation and is computed during initialization or when tunable parameters change. variability must be fixed or tunable. initial must be approx, calculated or not present (meaning calculated).\n\ninput - The variable value can be provided by the importer. [For example, the importer could forward the output of another FMU into this input.]\n\noutput -  The variable value can be used by the importer. [For example, this value can be forwarded to an input of another FMU.] The algebraic relationship to the inputs can be defined via the dependencies attribute of <fmiModelDescription><ModelStructure><Output>.\n\nlocal -  Local variables are:\n\ncontinuous states and their ContinuousStateDerivatives, ClockedStates, EventIndicators or InitialUnknowns. These variables are listed in the <fmiModelDescription><ModelStructure>.\ninternal, intermediate variables or local clocks which can be read for debugging purposes and are not listed in the <fmiModelDescription><ModelStructure>.\n\nSetting of local variables:\n\nIn Initialization Mode and before, local variables need to be set if they do have start values or are listed as <InitialUnknown>.\nIn super state Initialized, fmi3Set{VariableType} must not be called on any of the local variables. Only in Model Exchange, continuous states can be set with fmi3SetContinuousStates. Local variable values must not be used as input to another model or FMU.\n\nindependent - The independent variable (usually time [but could also be, for example, angle]). All variables are a function of this independent variable. variability must be continuous. Exactly one variable of an FMU must be defined as independent.  For Model Exchange the value is the last value set by fmi3SetTime. For Co-Simulation the value of the independent variable is lastSuccessfulTime return by the last call to fmi3DoStep or the value of argument intermediateUpdateTime of fmi3CallbackIntermediateUpdate. For Scheduled Execution the value of the independent variable is not defined. [The main purpose of this variable in Scheduled Execution is to define a quantity and unit for the independent variable.] The initial value of the independent variable is the value of the argument startTime of fmi3EnterInitializationMode for both Co-Simulation and Model Exchange.  If the unit for the independent variable is not defined, it is implicitly s (seconds). If one variable is defined as independent, it must be defined with a floating point type without a start attribute. It is not allowed to call function fmi3Set{VariableType} on an independent variable. Instead, its value is initialized with fmi3EnterInitializationMode and after initialization set by fmi3SetTime for Model Exchange and by arguments currentCommunicationPoint and communicationStepSize of fmi3DoStep for Co-Simulation FMUs. [The actual value can be inquired with fmi3Get{VariableType}.]\n\nstructuralParameter - The variable value can only be changed in Configuration Mode or Reconfiguration Mode. The variability attribute must be fixed or tunable. The initial attribute must be exact or not present (meaning exact). The start attribute is mandatory. A structural parameter must not have a <Dimension> element. A structural parameter may be referenced in <Dimension> elements. If a structural parameters is referenced in <Dimension> elements, it must be of type <UInt64> and its start attribute must be larger than 0. The min attribute might still be 0.\n\nThe default of causality is local. A continuous-time state or an event indicator must have causality = local or output, see also Section 2.4.8.\n\n[causality = calculatedParameter and causality = local with variability = fixed or tunable are similar. The difference is that a calculatedParameter can be used in another model or FMU, whereas a local variable cannot. For example, when importing an FMU in a Modelica environment, a calculatedParameter should be imported in a public section as final parameter, whereas a local variable should be imported in a protected section of the model.]\n\nThe causality of variables of type Clock must be either input or output.\n\nAdded prefix \"fmi3\" to help with redefinition of constans in enums.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMI3-Constants-in-FMI-Import/Core-.jl","page":"FMI3 Types in FMI Import/Core .jl","title":"FMI3 Constants in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi3_lowlevel_library_constants/","page":"FMI3 Types in FMI Import/Core .jl","title":"FMI3 Types in FMI Import/Core .jl","text":"fmi3True\nfmi3False\nfmi3StatusOK\nfmi3StatusWarning\nfmi3StatusDiscard\nfmi3StatusError\nfmi3StatusFatal\nfmi3InstanceStateInstantiated\nfmi3InstanceStateInitializationMode\nfmi3InstanceStateEventMode\nfmi3InstanceStateStepMode\nfmi3InstanceStateClockActivationMode\nfmi3InstanceStateContinuousTimeMode\nfmi3InstanceStateConfigurationMode\nfmi3InstanceStateReconfigurationMode\nfmi3InstanceStateTerminated\nfmi3InstanceStateError\nfmi3InstanceStateFatal\nfmi3VariableNamingConventionFlat\nfmi3VariableNamingConventionStructured\nfmi3CausalityParameter\nfmi3CausalityCalculatedParameter\nfmi3CausalityInput\nfmi3CausalityOutput\nfmi3CausalityLocal\nfmi3CausalityIndependent\nfmi3CausalityStructuralParameter","category":"page"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3True","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3True","text":"fmi2True\n\nEquals a binary true in FMI3.\n\nSource: [TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3False","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3False","text":"fmi2False\n\nEquals a binary false in FMI3.\n\nSource: [TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3StatusOK","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3StatusOK","text":"fmi3OK: The call was successful. The output argument values are defined.\n\nSource: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3StatusWarning","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3StatusWarning","text":"fmi3Warning: A non-critical problem was detected, but the computation can continue. The output argument values are defined. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. [In certain applications, e.g. in a prototyping environment, warnings may be acceptable. For production environments warnings should be treated like errors unless they can be safely ignored.]\n\nSource: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3StatusDiscard","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3StatusDiscard","text":"fmi3Discard: The call was not successful and the FMU is in the same state as before the call. The output argument values are not defined, but the computation can continue. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. Advanced simulation algorithms can try alternative approaches to drive the simulation by calling the function with different arguments or calling another function. Otherwise the simulation algorithm has to treat this return code like fmi3Error and has to terminate the simulation. [Examples for usage of fmi3Discard are handling of min/max violation, or signal numerical problems during model evaluation forcing smaller step sizes.]\n\nSource: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3StatusError","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3StatusError","text":"fmi3Error: The call failed. The output argument values are undefined and the simulation cannot be continued. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. If a function returns fmi3Error, it is possible to restore a previously retrieved FMU state by calling fmi3SetFMUState. Otherwise fmi3FreeInstance or fmi3Reset must be called. When detecting illegal arguments or a function call not allowed in the current state according to the respective state machine, the FMU must return fmi3Error. Other instances of this FMU are not affected by the error.\n\nSource: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3StatusFatal","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3StatusFatal","text":"fmi3Fatal: The state of all instances of the model is irreparably corrupted. [For example, due to a runtime exception such as access violation or integer division by zero during the execution of an FMI function.] Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings, if still possible. It is not allowed to call any other function for any instance of the FMU.\n\nSource: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateInstantiated","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateInstantiated","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateInitializationMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateInitializationMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateEventMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateEventMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateStepMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateStepMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateClockActivationMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateClockActivationMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateContinuousTimeMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateContinuousTimeMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateConfigurationMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateConfigurationMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateReconfigurationMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateReconfigurationMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateTerminated","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateTerminated","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateError","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateError","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateFatal","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateFatal","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3VariableNamingConventionFlat","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3VariableNamingConventionFlat","text":"[TODO]\n\nSource: FMISpec3.0, Version D5ef1c1: 2.4.7.5.1. Variable Naming Conventions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3VariableNamingConventionStructured","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3VariableNamingConventionStructured","text":"[TODO]\n\nSource: FMISpec3.0, Version D5ef1c1: 2.4.7.5.1. Variable Naming Conventions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityParameter","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityParameter","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityCalculatedParameter","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityCalculatedParameter","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityInput","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityInput","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityOutput","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityOutput","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityLocal","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityLocal","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityIndependent","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityIndependent","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityStructuralParameter","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityStructuralParameter","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_functions/#FMI-Common-Concepts-for-Model-Exchange-and-Co-Simulation","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"In both cases, FMI defines an input/output block of a dynamic model where the distribution of the block, the platform dependent header file, several access functions, as well as the schema files are identical.","category":"page"},{"location":"fmi3_lowlevel_library_functions/#Creation,-Destruction-and-Logging-of-FMU-Instances","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Creation, Destruction and Logging of FMU Instances","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3InstantiateCoSimulation\nfmi3InstantiateCoSimulation!\nfmi3InstantiateModelExchange\nfmi3InstantiateModelExchange!\nfmi3InstantiateScheduledExecution\nfmi3InstantiateScheduledExecution!\nfmi3FreeInstance\nfmi3FreeInstance!\nfmi3SetDebugLogging","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3InstantiateCoSimulation","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3InstantiateCoSimulation","text":"Source: FMISpec3.0, Version D5ef1c1:: 2.3.1. Super State: FMU State Setable\n\nThis function instantiates a Co-Simulation FMU (see Section 4). It is allowed to call this function only if modelDescription.xml includes a <CoSimulation> element.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3InstantiateCoSimulation!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3InstantiateCoSimulation!","text":"fmi3InstantiateCoSimulation!(fmu::FMU3; instanceName::String=fmu.modelName, type::fmi3Type=fmu.type, pushInstances::Bool = true, visible::Bool = false, loggingOn::Bool = fmu.executionConfig.loggingOn, externalCallbacks::Bool = fmu.executionConfig.externalCallbacks, \n    eventModeUsed::Bool = false, ptrIntermediateUpdate=nothing, logStatusOK::Bool=true, logStatusWarning::Bool=true, logStatusDiscard::Bool=true, logStatusError::Bool=true, logStatusFatal::Bool=true)\n\nCreate a new coSimulation instance of the given fmu, adds a logger if logginOn == true.\n\nArguments\n\nfmu::FMU3: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.\n\nKeywords\n\ninstanceName::String=fmu.modelName: Name of the instance\ntype::fmi3Type=fmu.type: Defines whether a Co-Simulation or Model Exchange is present\npushInstances::Bool = true: Defines if the fmu instances should be pushed in the application.\nvisible::Bool = false if the FMU should be started with graphic interface, if supported (default=false)\nloggingOn::Bool = fmu.executionConfig.loggingOn if the FMU should log and display function calls (default=false)\nexternalCallbacks::Bool = fmu.executionConfig.externalCallbacks if an external shared library should be used for the fmi3CallbackFunctions, this may improve readability of logging messages (default=false)\neventModeUsed::Bool = false: Defines if the FMU instance can use the event mode. (default=false)\nptrIntermediateUpdate=nothing: Points to a function handling intermediate Updates (defalut=nothing) \nlogStatusOK::Bool=true whether to log status of kind fmi3OK (default=true)\nlogStatusWarning::Bool=true whether to log status of kind fmi3Warning (default=true)\nlogStatusDiscard::Bool=true whether to log status of kind fmi3Discard (default=true)\nlogStatusError::Bool=true whether to log status of kind fmi3Error (default=true)\nlogStatusFatal::Bool=true whether to log status of kind fmi3Fatal (default=true)\n\nReturns\n\nReturns the instance of a new FMU coSimulation instance.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.4.7  Model variables\nFMISpec3.0: 2.3.1. Super State: FMU State Setable\n\nSee also fmi3InstantiateCoSimulation.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3InstantiateModelExchange","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3InstantiateModelExchange","text":"Source: FMISpec3.0, Version D5ef1c1:: 2.3.1. Super State: FMU State Setable\n\nThis function instantiates a Model Exchange FMU (see Section 3). It is allowed to call this function only if modelDescription.xml includes a <ModelExchange> element.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3InstantiateModelExchange!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3InstantiateModelExchange!","text":"fmi3InstantiateModelExchange!(fmu::FMU3; instanceName::String=fmu.modelName, type::fmi3Type=fmu.type, pushInstances::Bool = true, visible::Bool = false, loggingOn::Bool = fmu.executionConfig.loggingOn, externalCallbacks::Bool = fmu.executionConfig.externalCallbacks,\n    logStatusOK::Bool=true, logStatusWarning::Bool=true, logStatusDiscard::Bool=true, logStatusError::Bool=true, logStatusFatal::Bool=true)\n\nCreate a new modelExchange instance of the given fmu, adds a logger if logginOn == true.\n\nArguments\n\nfmu::FMU3: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.\n\nKeywords\n\ninstanceName::String=fmu.modelName: Name of the instance\ntype::fmi3Type=fmu.type: Defines whether a Co-Simulation or Model Exchange is present\npushInstances::Bool = true: Defines if the fmu instances should be pushed in the application.\nvisible::Bool = false if the FMU should be started with graphic interface, if supported (default=false)\nloggingOn::Bool = fmu.executionConfig.loggingOn if the FMU should log and display function calls (default=false)\nexternalCallbacks::Bool = fmu.executionConfig.externalCallbacks if an external shared library should be used for the fmi3CallbackFunctions, this may improve readability of logging messages (default=false)\nlogStatusOK::Bool=true whether to log status of kind fmi3OK (default=true)\nlogStatusWarning::Bool=true whether to log status of kind fmi3Warning (default=true)\nlogStatusDiscard::Bool=true whether to log status of kind fmi3Discard (default=true)\nlogStatusError::Bool=true whether to log status of kind fmi3Error (default=true)\nlogStatusFatal::Bool=true whether to log status of kind fmi3Fatal (default=true)\n\nReturns\n\nReturns the instance of a new FMU modelExchange instance.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.4.7  Model variables\nFMISpec3.0: 2.3.1. Super State: FMU State Setable\n\nSee also fmi3InstantiateModelExchange.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3InstantiateScheduledExecution","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3InstantiateScheduledExecution","text":"Source: FMISpec3.0, Version D5ef1c1:: 2.3.1. Super State: FMU State Setable\n\nThis function instantiates a Scheduled Execution FMU (see Section 4). It is allowed to call this function only if modelDescription.xml includes a <ScheduledExecution> element.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3InstantiateScheduledExecution!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3InstantiateScheduledExecution!","text":"fmi3InstantiateScheduledExecution!(fmu::FMU3; ptrlockPreemption::Ptr{Cvoid}, ptrunlockPreemption::Ptr{Cvoid}, instanceName::String=fmu.modelName, type::fmi3Type=fmu.type, pushInstances::Bool = true, visible::Bool = false, loggingOn::Bool = fmu.executionConfig.loggingOn, externalCallbacks::Bool = fmu.executionConfig.externalCallbacks, \n    logStatusOK::Bool=true, logStatusWarning::Bool=true, logStatusDiscard::Bool=true, logStatusError::Bool=true, logStatusFatal::Bool=true)\n\nCreate a new ScheduledExecution instance of the given fmu, adds a logger if logginOn == true.\n\nArguments\n\nfmu::FMU3: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.\n\nKeywords\n\nptrlockPreemption::Ptr{Cvoid}: Points to a function handling locking Preemption\nptrunlockPreemption::Ptr{Cvoid}: Points to a function handling unlocking Preemption\ninstanceName::String=fmu.modelName: Name of the instance\ntype::fmi3Type=fmu.type: Defines whether a Co-Simulation or Model Exchange is present\npushInstances::Bool = true: Defines if the fmu instances should be pushed in the application.\nvisible::Bool = false if the FMU should be started with graphic interface, if supported (default=false)\nloggingOn::Bool = fmu.executionConfig.loggingOn if the FMU should log and display function calls (default=false)\nexternalCallbacks::Bool = fmu.executionConfig.externalCallbacks if an external shared library should be used for the fmi3CallbackFunctions, this may improve readability of logging messages (default=false)\nlogStatusOK::Bool=true whether to log status of kind fmi3OK (default=true)\nlogStatusWarning::Bool=true whether to log status of kind fmi3Warning (default=true)\nlogStatusDiscard::Bool=true whether to log status of kind fmi3Discard (default=true)\nlogStatusError::Bool=true whether to log status of kind fmi3Error (default=true)\nlogStatusFatal::Bool=true whether to log status of kind fmi3Fatal (default=true)\n\nReturns\n\nReturns the instance of a new FMU ScheduledExecution instance.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.4.7  Model variables\nFMISpec3.0: 2.3.1. Super State: FMU State Setable\n\nSee also fmi3InstantiateScheduledExecution.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3FreeInstance","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3FreeInstance","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable\n\nDisposes the given instance, unloads the loaded model, and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface. If a NULL pointer is provided for argument instance, the function call is ignored (does not have an effect).\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3FreeInstance!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3FreeInstance!","text":"fmi3FreeInstance!(c::FMU3Instance; popInstance::Bool = true)\n\nDisposes the given instance, unloads the loaded model, and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface. If a null pointer is provided for ‚Äúc‚Äù, the function call is ignored (does not have an effect).\n\nRemoves the component from the FMUs component list.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\npopInstance::Bool=true: If the Keyword popInstance = true the freed instance is deleted\n\nReturns\n\nnothing\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetDebugLogging","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetDebugLogging","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable\n\nThe function controls debug logging that is output via the logger function callback. If loggingOn = fmi3True, debug logging is enabled, otherwise it is switched off.\n\n\n\n\n\nfmi3SetDebugLogging(c::FMU3Instance, logginOn::fmi3Boolean, nCategories::UInt, categories::Ptr{Nothing})\n\nControl the use of the logging callback function, version independent.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nlogginOn::fmi3Boolean: If loggingOn = fmi3True, debug logging is enabled for the log categories specified in categories, otherwise it is disabled. Type fmi3Boolean is defined as an alias Type for the C-Type Boolean and is to be used with fmi3True and fmi3False.\nnCategories::UInt: Argument nCategories defines the length of the argument categories.\ncategories::Ptr{Nothing}:\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.1. Super State: FMU State Setable\n\nSee also fmi3SetDebugLogging.\n\n\n\n\n\nfmi3SetDebugLogging(c::FMU3Instance)\n\nSet the DebugLogger for the FMU.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nReturns a warning if str.state is not called in fmi3InstanceStateInstantiated.\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.1. Super State: FMU State Setable\n\nSee also fmi3SetDebugLogging.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#Initialization,-Termination,-and-Resetting-an-FMU","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Initialization, Termination, and Resetting an FMU","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"This section documents functions that deal with initialization, termination, resetting of an FMU.","category":"page"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3EnterInitializationMode\nfmi3ExitInitializationMode\nfmi3EnterConfigurationMode\nfmi3ExitConfigurationMode\nfmi3Terminate\nfmi3Reset","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3EnterInitializationMode","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3EnterInitializationMode","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.2. State: Instantiated\n\nInforms the FMU to enter Initialization Mode. Before calling this function, all variables with attribute <Datatype initial = \"exact\" or \"approx\"> can be set with the ‚Äúfmi3SetXXX‚Äù functions (the ScalarVariable attributes are defined in the Model Description File, see section 2.4.7). Setting other variables is not allowed. Also sets the simulation start and stop time.\n\n\n\n\n\nfmi3EnterInitializationMode(c::FMU3Instance, toleranceDefined::fmi3Boolean,\n    tolerance::fmi3Float64,\n    startTime::fmi3Float64,\n    stopTimeDefined::fmi3Boolean,\n    stopTime::fmi3Float64)\n\nInforms the FMU to enter Initialization Mode. Before calling this function, all variables with attribute <Datatype initial = \"exact\" or \"approx\"> can be set with the ‚Äúfmi3SetXXX‚Äù functions (the ScalarVariable attributes are defined in the Model Description File, see section 2.4.7). Setting other variables is not allowed. Also sets the simulation start and stop time.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\ntoleranceDefined::fmi3Boolean: Arguments toleranceDefined depend on the FMU type:\nfmuType = fmi3ModelExchange: If toleranceDefined = fmi3True, then the model is called with a numerical integration scheme where the step size is controlled by using tolerance for error estimation. In such a case, all numerical algorithms used inside the model (for example, to solve non-linear algebraic equations) should also operate with an error estimation of an appropriate smaller relative tolerance.\nfmuType = fmi3CoSimulation: If toleranceDefined = fmi3True, then the communication interval of the slave is controlled by error estimation.  In case the slave utilizes a numerical integrator with variable step size and error estimation, it is suggested to use ‚Äútolerance‚Äù for the error estimation of the internal integrator (usually as relative tolerance). An FMU for Co-Simulation might ignore this argument.\ntolerance::fmi3Float64: Argument tolerance is the desired tolerance\nstartTime::fmi3Float64: Argument startTime can be used to check whether the model is valid within the given boundaries or to allocate memory which is necessary for storing results. It is the fixed initial value of the independent variable and if the independent variable is time, startTime is the starting time of initializaton.\nstopTimeDefined::fmi3Boolean:  If stopTimeDefined = fmi3True, then stopTime is the defined final value of the independent variable and if stopTimeDefined = fmi3False, then no final value\n\nof the independent variable is defined and argument stopTime is meaningless.\n\nstopTime::fmi3Float64: Argument stopTime can be used to check whether the model is valid within the given boundaries or to allocate memory which is necessary for storing results. It is the fixed final value of the independent variable and if the independent variable is ‚Äútime‚Äù, stopTime is the stop time of the simulation.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3EnterInitializationMode.\n\n\n\n\n\nfmi3EnterInitializationMode(c::FMU3Instance, startTime::Union{Real, Nothing} = nothing, stopTime::Union{Real, Nothing} = nothing; tolerance::Union{Real, Nothing} = nothing)\n\nFMU enters Initialization mode.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nstartTime::Union{Real, Nothing} = nothing: startTime is a real number which sets the value of starting time of the experiment. The default value is set automatically if doing nothing (default = nothing).\nstopTime::Union{Real, Nothing} = nothing: stopTime is a real number which sets the value of ending time of the experiment. The default value is set automatically if doing nothing (default = nothing).\n\nKeywords\n\ntolerance::Union{Real, Nothing} = nothing: tolerance is a real number which sets the value of tolerance range. The default value is set automatically if doing nothing (default = nothing).\n\nReturns\n\nReturns a warning if str.state is not called in fmi3InstanceStateInstantiated.\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3EnterInitializationMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3ExitInitializationMode","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3ExitInitializationMode","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.3. State: Initialization Mode\n\nInforms the FMU to exit Initialization Mode.\n\n\n\n\n\nfmi3ExitInitializationMode(c::FMU3Instance)\n\nInforms the FMU to exit Initialization Mode.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.3. State: Initialization Mode\n\nSee also fmi3ExitInitializationMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3EnterConfigurationMode","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3EnterConfigurationMode","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.2. State: Instantiated\n\nIf the importer needs to change structural parameters, it must move the FMU into Configuration Mode using fmi3EnterConfigurationMode.\n\n\n\n\n\nfmi3EnterConfigurationMode(c::FMU3Instance; soft::Bool=false)\n\nIf the importer needs to change structural parameters, it must move the FMU into Configuration Mode using fmi3EnterConfigurationMode.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state  fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3EnterConfigurationMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3ExitConfigurationMode","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3ExitConfigurationMode","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.6. State: Configuration Mode\n\nExits the Configuration Mode and returns to state Instantiated.\n\n\n\n\n\nfmi3ExitConfigurationMode(c::FMU3Instance; soft::Bool=false)\n\nExits the Configuration Mode and returns to state Instantiated.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state  fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.6. State: Configuration Mode\n\nSee also fmi3ExitConfigurationMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3Terminate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3Terminate","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.4. Super State: Initialized\n\nInforms the FMU that the simulation run is terminated.\n\n\n\n\n\nfmi3Terminate(c::FMU3Instance; soft::Bool=false)\n\nInforms the FMU that the simulation run is terminated.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state  fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.4. Super State: Initialized\n\nSee also fmi3Terminate.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3Reset","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3Reset","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable\n\nIs called by the environment to reset the FMU after a simulation run. The FMU goes into the same state as if fmi3InstantiateXXX would have been called.\n\n\n\n\n\nfmi3Reset(c::FMU3Instance; soft::Bool = false)\n\nIs called by the environment to reset the FMU after a simulation run. The FMU goes into the same state as if fmi3InstantiateXXX would have been called.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.1. Super State: FMU State Setable\n\nSee also fmi3Reset.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#Getting-and-Setting-Variable-Values","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Getting and Setting Variable Values","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"All variable values of an FMU are identified with a variable handle called ‚Äúvalue reference‚Äù. The handle is defined in the modelDescription.xml file (as attribute ‚ÄúvalueReference‚Äù in element ‚ÄúScalarVariable‚Äù). Element ‚ÄúvalueReference‚Äù might not be unique for all variables. If two or more variables of the same base data type (such as fmi3Float64) have the same valueReference, then they have identical values but other parts of the variable definition might be different (for example, min/max attributes).","category":"page"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3GetFloat32\nfmi3GetFloat32!\nfmi3GetFloat64\nfmi3GetFloat64!\nfmi3GetInt8\nfmi3GetInt8!\nfmi3GetInt16\nfmi3GetInt16!\nfmi3GetInt32\nfmi3GetInt32!\nfmi3GetInt64\nfmi3GetInt64!\nfmi3GetUInt8\nfmi3GetUInt8!\nfmi3GetUInt16\nfmi3GetUInt16!\nfmi3GetUInt32\nfmi3GetUInt32!\nfmi3GetUInt64\nfmi3GetUInt64!\nfmi3GetBoolean\nfmi3GetBoolean!\nfmi3GetString\nfmi3GetString!\nfmi3GetBinary\nfmi3GetBinary!\nfmi3SetFloat32\nfmi3SetFloat64\nfmi3SetInt8\nfmi3SetInt16\nfmi3SetInt32\nfmi3SetInt64\nfmi3SetUInt8\nfmi3SetUInt16\nfmi3SetUInt32\nfmi3SetUInt64\nfmi3SetBoolean\nfmi3SetString\nfmi3SetBinary","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetFloat32","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetFloat32","text":"fmi3GetFloat32(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Float32 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Float32}: returns values of an array of fmi3Float32 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetFloat32.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetFloat32!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetFloat32!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetFloat32!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Float32}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Float32}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetFloat32!.\n\n\n\n\n\nfmi3GetFloat32!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Float32})\n\nWrites the real values of an array of variables in the given field\n\nfmi3GetFloat32! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Float32}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetFloat32!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetFloat64","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetFloat64","text":"fmi3GetFloat64(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Float64 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Float64}: returns values of an array of fmi3Float64 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetFloat64.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetFloat64!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetFloat64!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetFloat64!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Float64}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Float64}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetFloat64!.\n\n\n\n\n\nfmi3GetFloat64!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Float64})\n\nWrites the real values of an array of variables in the given field\n\nfmi3GetFloat64! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Float64}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetFloat64!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetInt8","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetInt8","text":"fmi3GetInt8(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Int8 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Int8}: returns values of an array of fmi3Int8 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt8.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetInt8!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetInt8!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetInt8!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int8}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int8}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt8!.\n\n\n\n\n\nfmi3GetInt8!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Int8})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetInt8! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Int8}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt8!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetInt16","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetInt16","text":"fmi3GetInt16(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Int16 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Int16}: returns values of an array of fmi3Int16 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt16.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetInt16!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetInt16!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetInt16!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int16}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int16}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt16!.\n\n\n\n\n\nfmi3GetInt16!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Int16})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetInt16! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Int16}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt16!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetInt32","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetInt32","text":"fmi3GetInt32(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Int32 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Int32}: returns values of an array of fmi3Int32 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt32.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetInt32!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetInt32!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetInt32!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int32}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int32}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt32!.\n\n\n\n\n\nfmi3GetInt32!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Int32})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetInt32! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Int32}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt32!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetInt64","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetInt64","text":"fmi3GetInt64(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Int64 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Int64}: returns values of an array of fmi3Int64 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt64.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetInt64!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetInt64!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetInt64!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int64}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int64}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt64!.\n\n\n\n\n\nfmi3GetInt64!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Int64})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetInt64! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Int64}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt64!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetUInt8","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetUInt8","text":"fmi3GetUInt8(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3UInt8 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3UInt8}: returns values of an array of fmi3UInt8 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt8.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetUInt8!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetUInt8!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetUInt8!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt8}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt8}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt8!.\n\n\n\n\n\nfmi3GetUInt8!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3UInt8})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetUInt8! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3UInt8}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt8!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetUInt16","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetUInt16","text":"fmi3GetUInt16(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3UInt16 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3UInt16}: returns values of an array of fmi3UInt16 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt16.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetUInt16!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetUInt16!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetUInt16(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt16}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt16}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt16!.\n\n\n\n\n\nfmi3GetUInt16!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3UInt16})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetUInt16! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3UInt16}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt16!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetUInt32","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetUInt32","text":"fmi3GetUInt32(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3UInt32 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3UInt32}: returns values of an array of fmi3UInt32 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt32.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetUInt32!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetUInt32!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetUInt32!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt32}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt32}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt32!.\n\n\n\n\n\nfmi3GetUInt32!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3UInt32})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetUInt32! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3UInt32}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt32!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetUInt64","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetUInt64","text":"fmi3GetUInt64(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3UInt64 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3UInt64}: returns values of an array of fmi3UInt64 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt64.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetUInt64!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetUInt64!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetUInt64!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt64}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt64}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt64!.\n\n\n\n\n\nfmi3GetUInt64!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3UInt64})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetUInt64! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3UInt64}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt64!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetBoolean","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetBoolean","text":"fmi3GetBoolean(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Boolean variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Boolean}: returns values of an array of fmi3Boolean variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetBoolean.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetBoolean!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetBoolean!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetBoolean!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Boolean}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Boolean}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetBoolean!.\n\n\n\n\n\nfmi3GetBoolean!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Boolean})\n\nWrites the boolean values of an array of variables in the given field\n\nfmi3GetBoolean! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Boolean}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetBoolean!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetString","text":"fmi3GetString(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3String variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3String}: returns values of an array of fmi3String variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetString.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetString!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetString!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetString!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3String}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3String}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetString!.\n\n\n\n\n\nfmi3GetString!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3String})\n\nWrites the string values of an array of variables in the given field\n\nfmi3GetString! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3String}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetString!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetBinary","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetBinary","text":"fmi3GetBinary(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Binary variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Binary}: returns values of an array of fmi3Binary variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetBinary.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetBinary!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetBinary!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValues - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetBinary!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, valueSizes::AbstractArray{Csize_t}, value::AbstractArray{fmi3Binary}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalueSizes::AbstractArray{Csize_t}: Argument valueSizes defines the size of a binary element of each variable.\nvalue::AbstractArray{fmi3Binary}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetBinary!.\n\n\n\n\n\nfmi3GetBinary!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Binary})\n\nWrites the binary values of an array of variables in the given field\n\nfmi3GetBinary! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Binary}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetBinary!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetFloat32","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetFloat32","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetFloat32(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Float32}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Float32}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetFloat32.\n\n\n\n\n\nfmi3SetFloat32(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Float32}, fmi3Float32})\n\nSet the values of an array of real variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Float32}, fmi3Float32}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetFloat32.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetFloat64","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetFloat64","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetFloat64(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Float64}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Float64}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetFloat64.\n\n\n\n\n\nfmi3SetFloat64(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Float64}, fmi3Float64})\n\nSet the values of an array of real variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Float64}, fmi3Float64}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetFloat64.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetInt8","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetInt8","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetInt8(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int8}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int8}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\n\n\n\n\nfmi3SetInt8(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Int8}, fmi3Int8})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Int8}, fmi3Int8}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt8.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetInt16","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetInt16","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetInt16(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int16}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int16}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt16.\n\n\n\n\n\nfmi3SetInt16(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Int16}, fmi3Int16})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Int16}, fmi3Int16}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt16.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetInt32","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetInt32","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetInt32(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int32}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int32}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt32.\n\n\n\n\n\nfmi3SetInt32(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Int32}, fmi3Int32})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Int32}, fmi3Int32}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt32.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetInt64","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetInt64","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetInt64(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int64}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int64}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt64.\n\n\n\n\n\nfmi3SetInt64(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Int64}, fmi3Int64})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Int64}, fmi3Int64}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt64.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetUInt8","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetUInt8","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetUInt8(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt8}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt8}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt8.\n\n\n\n\n\nfmi3SetUInt8(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3UInt8}, fmi3UInt8})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3UInt8}, fmi3UInt8}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt8.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetUInt16","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetUInt16","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetUInt16(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt16}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt16}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\n\n\n\n\nfmi3SetUInt16(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3UInt16}, fmi3UInt16})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3UInt16}, fmi3UInt16}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt16.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetUInt32","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetUInt32","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetInt32(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt32}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt32}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt32.\n\n\n\n\n\nfmi3SetUInt32(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3UInt32}, fmi3UInt32})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3UInt32}, fmi3UInt32}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt32.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetUInt64","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetUInt64","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetUInt64(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt64}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt64}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt64.\n\n\n\n\n\nfmi3SetUInt64(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3UInt64}, fmi3UInt64})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3UInt64}, fmi3UInt64}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt64.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetBoolean","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetBoolean","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetBoolean(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Boolean}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Boolean}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetBoolean.\n\n\n\n\n\nfmi3SetBoolean(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{Bool}, Bool})\n\nSet the values of an array of boolean variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{Bool}, Bool}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetBoolean.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetString","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetString(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3String}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3String}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetString.\n\n\n\n\n\nfmi3SetString(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{String}, String})\n\nSet the values of an array of string variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{String}, String}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetString.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetBinary","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetBinary","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetBinary(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, valueSizes::AbstractArray{Csize_t}, value::AbstractArray{fmi3Binary}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalueSizes::AbstractArray{Csize_t}: Argument valueSizes defines the size of a binary element of each variable.\nvalue::AbstractArray{fmi3Binary}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetBinary.\n\n\n\n\n\nfmi3SetBinary(c::FMU3Instance, vr::fmi3ValueReferenceFormat, valueSizes::Union{AbstractArray{Csize_t}, Csize_t}, values::Union{AbstractArray{fmi3Binary}, fmi3Binary})\n\nSet the values of an array of binary variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalueSizes::Union{AbstractArray{Csize_t}, Csize_t}: Argument valueSizes defines the size of a binary element of each variable.\nvalues::Union{AbstractArray{fmi3Binary}, fmi3Binary}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetBinary.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3Get fmi3Get! fmi3Set","category":"page"},{"location":"fmi3_lowlevel_library_functions/#Getting-and-Setting-the-Complete-FMU-State","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Getting and Setting the Complete FMU State","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"The FMU has an internal state consisting of all values that are needed to continue a simulation. This internal state consists especially of the values of the continuous-time states, iteration variables, parameter values, input values, delay buffers, file identifiers, and FMU internal status information. With the functions of this section, the internal FMU state can be copied and the pointer to this copy is returned to the environment. The FMU state copy can be set as actual FMU state, in order to continue the simulation from it.","category":"page"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3GetFMUState\nfmi3GetFMUState!\nfmi3SetFMUState\nfmi3FreeFMUState\nfmi3SerializeFMUState\nfmi3SerializeFMUState!\nfmi3SerializedFMUStateSize\nfmi3SerializedFMUStateSize!\nfmi3DeSerializeFMUState\nfmi3DeSerializeFMUState!\nfmi3UpdateDiscreteStates\nfmi3EvaluateDiscreteStates\nfmi3GetNominalsOfContinuousStates","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetFMUState","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetFMUState","text":"fmi3GetFMUState(c::FMU3Instance)\n\nMakes a copy of the internal FMU state and returns a pointer to this copy.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nReturn state is a pointer to a copy of the internal FMU state.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3GetFMUState.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetFMUState!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetFMUState!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State\n\nfmi3GetFMUstate makes a copy of the internal FMU state and returns a pointer to this copy\n\n\n\n\n\nfmi3GetFMUState!(c::FMU3Instance, FMUstate::Ref{fmi3FMUState})\n\nMakes a copy of the internal FMU state and returns a pointer to this copy\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nFMUstate::Ref{fmi3FMUstate}:If on entry FMUstate == NULL, a new allocation is required. If FMUstate != NULL, then FMUstate points to a previously returned FMUstate that has not been modified since.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3GetFMUState!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetFMUState","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetFMUState","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State\n\nfmi3SetFMUstate copies the content of the previously copied FMUstate back and uses it as actual new FMU state.\n\n\n\n\n\nfmi3SetFMUState(c::FMU3Instance, FMUstate::fmi3FMUState)\n\nCopies the content of the previously copied FMUstate back and uses it as actual new FMU state.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nFMUstate::fmi3FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3SetFMUState.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3FreeFMUState","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3FreeFMUState","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State\n\nfmi3FreeFMUstate frees all memory and other resources allocated with the fmi3GetFMUstate call for this FMUstate.\n\n\n\n\n\nfmi3FreeFMUState(c::FMU3Instance, FMUstate::Ref{fmi3FMUState})\n\nFrees all memory and other resources allocated with the fmi3GetFMUstate call for this FMUstate.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nFMUstate::fmi3FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\n\n\n\n\nfmi3FreeFMUState!(c::FMU3Instance, state::fmi3FMUState)\n\nFree the allocated memory for the FMU state.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nstate::fmi3FMUState: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nReturn singleton instance of type Nothing, if there is no value to return (as in a C void function) or when a variable or field holds no value.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3SerializeFMUState","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3SerializeFMUState","text":"fmi3SerializeFMUState(c::FMU3Instance, state::fmi3FMUState)\n\nSerializes the data referenced by the pointer FMUstate and copies this data into the byte vector serializedState of length size to be provided by the environment.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nstate::fmi3FMUState: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nserializedState:: Array{fmi3Byte}: Return serializedState contains the copy of the serialized data referenced by the pointer FMUstate\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3SerializeFMUState.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SerializeFMUState!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SerializeFMUState!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State\n\nfmi3SerializeFMUstate serializes the data which is referenced by pointer FMUstate and copies this data in to the byte vector serializedState of length size\n\n\n\n\n\nfmi3SerializeFMUState!(c::FMU3Instance, FMUstate::fmi3FMUState, serialzedState::AbstractArray{fmi3Byte}, size::Csize_t)\n\nSerializes the data which is referenced by pointer FMUState and copies this data in to the byte vector serializedState of length size, that must be provided by the environment.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nFMUstate::fmi3FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nserialzedState::AbstractArray{fmi3Byte}: Argument serializedState contains the copy of the serialized data referenced by the pointer FMUstate.\nsize::Ref{Csize_t}: Argument size is an object that safely references a value of type Csize_t and defines the size of the byte vector in which the FMUstate can be stored.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3SerializeFMUState!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3SerializedFMUStateSize","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3SerializedFMUStateSize","text":"fmi3SerializedFMUStateSize(c::FMU3Instance, state::fmi3FMUState)\n\nReturns the size of the byte vector in which the FMUstate can be stored.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nstate::fmi3FMUState: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nReturn size is an object that safely references a value of type Csize_t.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3SerializedFMUStateSize.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SerializedFMUStateSize!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SerializedFMUStateSize!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State\n\nfmi3SerializedFMUstateSize returns the size of the byte vector which is needed to store FMUstate in it.\n\n\n\n\n\nfmi3SerializedFMUStateSize!(c::FMU3Instance, FMUstate::fmi3FMUState, size::Ref{Csize_t})\n\nFrees all memory and other resources allocated with the fmi3GetFMUstate call for this FMUstate.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nFMUstate::fmi3FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nsize::Ref{Csize_t}: Argument size is an object that safely references a value of type Csize_t and defines the size of the byte vector in which the FMUstate can be stored.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3SerializedFMUStateSize!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3DeSerializeFMUState","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3DeSerializeFMUState","text":"fmi3SerializeFMUState(c::FMU3Instance, state::fmi3FMUState)\n\nSerializes the data referenced by the pointer FMUstate and copies this data into the byte vector serializedState of length size to be provided by the environment.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nserializedState::Array{fmi3Byte}: Argument serializedState contains the fmi3Byte field to be deserialized.\n\nReturns\n\nReturn state is a pointer to a copy of the internal FMU state.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3DeSerializeFMUState.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3DeSerializeFMUState!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3DeSerializeFMUState!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State\n\nfmi3DeSerializeFMUstate deserializes the byte vector serializedState of length size, constructs a copy of the FMU state and returns FMUstate, the pointer to this copy.\n\n\n\n\n\nfmi3DeSerializeFMUState!(c::FMU3Instance, serialzedState::AbstractArray{fmi3Byte}, size::Csize_t, FMUstate::Ref{fmi3FMUState})\n\nDeserializes the byte vector serializedState of length size, constructs a copy of the FMU state and stores the FMU state in the given address of the reference FMUstate, the pointer to this copy.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nFMUstate::fmi3FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nserialzedState::AbstractArray{fmi3Byte}: Argument serializedState contains the copy of the serialized data referenced by the pointer FMUstate.\nsize::Ref{Csize_t}: Argument size is an object that safely references a value of type Csize_t and defines the size of the byte vector in which the FMUstate can be stored.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3DeSerializeFMUState!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3UpdateDiscreteStates","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3UpdateDiscreteStates","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.5. State: Event Mode\n\nThis function is called to signal a converged solution at the current super-dense time instant. fmi3UpdateDiscreteStates must be called at least once per super-dense time instant.\n\n\n\n\n\nfmi3UpdateDiscreteStates(c::FMU3Instance, discreteStatesNeedUpdate::Ref{fmi3Boolean}, terminateSimulation::Ref{fmi3Boolean}, \n                                nominalsOfContinuousStatesChanged::Ref{fmi3Boolean}, valuesOfContinuousStatesChanged::Ref{fmi3Boolean},\n                                nextEventTimeDefined::Ref{fmi3Boolean}, nextEventTime::Ref{fmi3Float64})\n\nThis function is called to signal a converged solution at the current super-dense time instant. fmi3UpdateDiscreteStates must be called at least once per super-dense time instant.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\ndiscreteStatesNeedUpdate::Ref{fmi3Boolean}: \nterminateSimulation::Ref{fmi3Boolean}: \nnominalsOfContinuousStatesChanged::Ref{fmi3Boolean}: \nvaluesOfContinuousStatesChanged::Ref{fmi3Boolean}: \nnextEventTimeDefined::Ref{fmi3Boolean}: \nnextEventTime::Ref{fmi3Float64}: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.5. State: Event Mode\n\n\n\n\n\nfmi3UpdateDiscreteStates(c::FMU3Instance)\n\nThis function is called to signal a converged solution at the current super-dense time instant. fmi3UpdateDiscreteStates must be called at least once per super-dense time instant. Results are returned, use fmi3UpdateDiscreteStates! for the inplace variant.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\ndiscreteStatesNeedUpdate\nterminateSimulation\nnominalsOfContinuousStatesChanged\nvaluesOfContinuousStatesChanged\nnextEventTimeDefined\nnextEventTime\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.3.5. State: Event Mode\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3EvaluateDiscreteStates","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3EvaluateDiscreteStates","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.3. State: Initialization Mode\n\nThis function is called to trigger the evaluation of fdisc to compute the current values of discrete states from previous values.  The FMU signals the support of fmi3EvaluateDiscreteStates via the capability flag providesEvaluateDiscreteStates.\n\n\n\n\n\nfmi3EvaluateDiscreteStates(c::FMU3Instance)\n\nThis function is called to trigger the evaluation of fdisc to compute the current values of discrete states from previous values.  The FMU signals the support of fmi3EvaluateDiscreteStates via the capability flag providesEvaluateDiscreteStates.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.3. State: Initialization Mode\n\nSee also fmi3EvaluateDiscreteStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetNominalsOfContinuousStates","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetNominalsOfContinuousStates","text":"fmi3GetNominalsOfContinuousStates(c::FMU3Instance)\n\nReturn the nominal values of the continuous states.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nx::Array{fmi3Float64}: Returns an array of fmi3Float64 values representing the new nominals of continuous state vector x.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.3.3. State: Initialization Mode\n\nSee also fmi3GetNominalsOfContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#Getting-Partial-Dervatives","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Getting Partial Dervatives","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"It is optionally possible to provide evaluation of partial derivatives for an FMU. For Model Exchange, this means computing the partial derivatives at a particular time instant. For Co-Simulation, this means to compute the partial derivatives at a particular communication point. One function is provided to compute directional derivatives. This function can be used to construct the desired partial derivative matrices.","category":"page"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3GetDirectionalDerivative\nfmi3GetDirectionalDerivative!\nfmi3GetContinuousStateDerivatives\nfmi3GetContinuousStateDerivatives!\nfmi3GetAdjointDerivative\nfmi3GetAdjointDerivative!\nfmi3GetOutputDerivatives\nfmi3GetOutputDerivatives!","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetDirectionalDerivative","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetDirectionalDerivative","text":"fmi3GetDirectionalDerivative(c::FMU3Instance,\n    unknowns::AbstractArray{fmi3ValueReference},\n    knowns::AbstractArray{fmi3ValueReference},\n    seed::AbstractArray{fmi3Float64})\n\nWrapper Function call to compute the partial derivative with respect to the variables unknowns.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = ùê°(knowns, rest)\n\nunknowns: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknown> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Output> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><ContinuousStateDerivative>).\nEvent Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Output> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Output> with type Real and variability = continuous or discrete. If <ModelStructure><ContinuousStateDerivative> is present, also the variables listed here as state derivatives.\nknowns: Real input variables of function h that changes its value in the actual Mode.\nrest: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables ùêØ_known:\n\nŒîunknowns = (Œ¥h / Œ¥knowns) Œîknowns\n\nArguments\n\nc::FMU3Instance Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nunknowns::AbstracArray{fmi3ValueReference}: Argument unknowns contains values of typefmi3ValueReference which are identifiers of a variable value of the model. unknowns can be equated with unknowns(variable described above).\nknowns::AbstractArray{fmi3ValueReference}: Argument knowns contains values of type fmi3ValueReference which are identifiers of a variable value of the model.knowns can be equated with knowns(variable described above).\nseed::AbstractArray{fmi3Float64}:The vector values Compute the partial derivative with respect to the given entries in vector knowns with the matching evaluate of sensitivity.\n\nReturns\n\nsensitivity::Array{fmi3Float64}: Return sensitivity contains the directional derivative vector values.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.11. Getting Partial Derivatives\n\nSee also fmi3GetDirectionalDerivative.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetDirectionalDerivative!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetDirectionalDerivative!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.11. Getting Partial Derivatives\n\nThis function computes the directional derivatives v{sensitivity} = J ‚ãÖ v{seed} of an FMU.\n\nunknowns - contains value references to the unknowns.\n\nnUnknowns - contains the length of argument unknowns.\n\nknowns - contains value references of the knowns.\n\nnKnowns - contains the length of argument knowns.\n\nseed - contains the components of the seed vector.\n\nnSeed - contains the length of seed.\n\nsensitivity - contains the components of the sensitivity vector.\n\nnSensitivity - contains the length of sensitivity.\n\nThis function can only be called if the 'ProvidesDirectionalDerivatives' tag in the ModelDescription is set.\n\n\n\n\n\nfmi3GetDirectionalDerivative!(c::FMU3Instance,\n                                   unknowns::AbstractArray{fmi3ValueReference},\n                                   nUnknowns::Csize_t,\n                                   knowns::AbstractArray{fmi3ValueReference},\n                                   nKnowns::Csize_t,\n                                   seed::AbstractArray{fmi3Float64},\n                                   nSeed::Csize_t,\n                                   sensitivity::AbstractArray{fmi3Float64},\n                                   nSensitivity::Csize_t)\n\nWrapper Function call to compute the partial derivative with respect to the variables unknowns.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = ùê°(knowns, rest)\n\nunknowns: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknown> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Output> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><ContinuousStateDerivative>).\nEvent Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Output> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Output> with type Real and variability = continuous or discrete. If <ModelStructure><ContinuousStateDerivative> is present, also the variables listed here as state derivatives.\nknowns: Real input variables of function h that changes its value in the actual Mode.\nrest: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables ùêØ_known:\n\nŒîunknowns = (Œ¥h / Œ¥knowns) Œîknowns\n\nArguments\n\nc::FMU3Instance Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nunknowns::AbstracArray{fmi3ValueReference}: Argument unknowns contains values of typefmi3ValueReference which are identifiers of a variable value of the model. unknowns can be equated with unknowns(variable described above).\nnUnknowns::Csize_t:\nknowns::AbstractArray{fmi3ValueReference}: Argument knowns contains values of type fmi3ValueReference which are identifiers of a variable value of the model.knowns can be equated with knowns(variable described above).\nnKnowns::Csize_t:\nseed::AbstractArray{fmi3Float64}:The vector values Compute the partial derivative with respect to the given entries in vector knowns with the matching evaluate of sensitivity.\nnKnowns::Csize_t:\nsensitivity::AbstractArray{fmi3Float64}: Stores the directional derivative vector values.\nnKnowns::Csize_t:\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.11. Getting Partial Derivatives\n\nSee also fmi3GetDirectionalDerivative.\n\n\n\n\n\nfmi3GetDirectionalDerivative!(c::FMU3Instance,\n    unknowns::AbstractArray{fmi3ValueReference},\n    knowns::AbstractArray{fmi3ValueReference},\n    sensitivity::AbstractArray{fmi3Float64},\n    seed::AbstractArray{fmi3Float64})\n\nWrapper Function call to compute the partial derivative with respect to the variables unknowns.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = ùê°(knowns, rest)\n\nunknowns: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknown> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Output> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><ContinuousStateDerivative>).\nEvent Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Output> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Output> with type Real and variability = continuous or discrete. If <ModelStructure><ContinuousStateDerivative> is present, also the variables listed here as state derivatives.\nknowns: Real input variables of function h that changes its value in the actual Mode.\nrest: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables ùêØ_known:\n\nŒîunknowns = (Œ¥h / Œ¥knowns) Œîknowns\n\nArguments\n\nc::FMU3Instance Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nunknowns::AbstracArray{fmi3ValueReference}: Argument unknowns contains values of typefmi3ValueReference which are identifiers of a variable value of the model. unknowns can be equated with unknowns(variable described above).\nknowns::AbstractArray{fmi3ValueReference}: Argument knowns contains values of type fmi3ValueReference which are identifiers of a variable value of the model.knowns can be equated with knowns(variable described above).\nsensitivity::AbstractArray{fmi3Float64}: Stores the directional derivative vector values.\nseed::AbstractArray{fmi3Float64}:The vector values Compute the partial derivative with respect to the given entries in vector knowns with the matching evaluate of sensitivity.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.11. Getting Partial Derivatives\n\nSee also fmi3GetDirectionalDerivative!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetContinuousStateDerivatives","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetContinuousStateDerivatives","text":"fmi3GetContinuousStateDerivatives(c::FMU3Instance)\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nderivatives::Array{fmi3Float64}: Returns an array of fmi3Float64 values representing the derivatives for the current states. The ordering of the elements of the derivatives vector is identical to the ordering of the state\n\nvector.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3GetContinuousStateDerivatives.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetContinuousStateDerivatives!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetContinuousStateDerivatives!","text":"Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode\n\nCompute first-oder state derivatives at the current time instant and for the current states.\n\n\n\n\n\nfmi3GetContinuousStateDerivatives!(c::FMU3Instance,\n                        derivatives::AbstractArray{fmi3Float64},\n                        nx::Csize_t)\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nderivatives::AbstractArray{fmi3Float64}: Argument derivatives contains values of type fmi3Float64 which is a alias type for Real data type.derivatives is the AbstractArray which contains the Real values of the vector that represent the derivatives. The ordering of the elements of the derivatives vector is identical to the ordering of the state vector.\nnx::Csize_t: Argument nx defines the length of vector derivatives and is provided for checking purposes\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3GetContinuousStateDerivatives!.\n\n\n\n\n\nfmi3GetContinuousStateDerivatives!(c::FMU3Instance, derivatives::Array{fmi3Float64})\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nderivatives::AbstractArray{fmi3Float64}: Argument derivatives contains values of type fmi3Float64 which is a alias type for Real data type.derivatives is the AbstractArray which contains the Real values of the vector that represent the derivatives. The ordering of the elements of the derivatives vector is identical to the ordering of the state vector.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3GetContinuousStateDerivatives!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetAdjointDerivative","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetAdjointDerivative","text":"fmi3GetAdjointDerivative(c::FMU3Instance,\n    unknowns::AbstractArray{fmi3ValueReference},\n    knowns::AbstractArray{fmi3ValueReference},\n    seed::AbstractArray{fmi3Float64})\n\nWrapper Function call to compute the partial derivative with respect to the variables unknowns.\n\nComputes the adjoint derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = ùê°(knowns, rest)\n\nunknowns: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknown> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Output> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><ContinuousStateDerivative>).\nEvent Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Output> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Output> with type Real and variability = continuous or discrete. If <ModelStructure><ContinuousStateDerivative> is present, also the variables listed here as state derivatives.\nknowns: Real input variables of function h that changes its value in the actual Mode.\nrest: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables ùêØ_known:\n\nŒîunknowns = (Œ¥h / Œ¥knowns) Œîknowns\n\nArguments\n\nc::FMU3Instance Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nunknowns::AbstracArray{fmi3ValueReference}: Argument unknowns contains values of typefmi3ValueReference which are identifiers of a variable value of the model. unknowns can be equated with unknowns(variable described above).\nknowns::AbstractArray{fmi3ValueReference}: Argument knowns contains values of type fmi3ValueReference which are identifiers of a variable value of the model.knowns can be equated with knowns(variable described above).\nseed::AbstractArray{fmi3Float64}:The vector values Compute the partial derivative with respect to the given entries in vector knowns with the matching evaluate of sensitivity.\n\nReturns\n\nsensitivity::Array{fmi3Float64}: Return sensitivity contains the directional derivative vector values.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.11. Getting Partial Derivatives\n\nSee also fmi3GetAdjointDerivative.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetAdjointDerivative!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetAdjointDerivative!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.11. Getting Partial Derivatives\n\nThis function computes the adjoint derivatives v^T{sensitivity}= v^T{seed} ‚ãÖ J of an FMU.\n\nunknowns - contains value references to the unknowns.\n\nnUnknowns - contains the length of argument unknowns.\n\nknowns - contains value references of the knowns.\n\nnKnowns - contains the length of argument knowns.\n\nseed - contains the components of the seed vector.\n\nnSeed - contains the length of seed.\n\nsensitivity - contains the components of the sensitivity vector.\n\nnSensitivity - contains the length of sensitivity.\n\nThis function can only be called if the 'ProvidesAdjointDerivatives' tag in the ModelDescription is set.\n\n\n\n\n\nfmi3GetAdjointDerivative!(c::FMU3Instance,\n            unknowns::AbstractArray{fmi3ValueReference},\n            nUnknowns::Csize_t,\n            knowns::AbstractArray{fmi3ValueReference},\n            nKnowns::Csize_t,\n            seed::AbstractArray{fmi3Float64},\n            nSeed::Csize_t,\n            sensitivity::AbstractArray{fmi3Float64},\n            nSensitivity::Csize_t)\n\nWrapper Function call to compute the partial derivative with respect to the variables unknowns.\n\nComputes the adjoint derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = ùê°(knowns, rest)\n\nunknowns: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknown> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Output> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><ContinuousStateDerivative>).\nEvent Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Output> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Output> with type Real and variability = continuous or discrete. If <ModelStructure><ContinuousStateDerivative> is present, also the variables listed here as state derivatives.\nknowns: Real input variables of function h that changes its value in the actual Mode.\nrest: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables ùêØ_known:\n\nŒîunknowns = (Œ¥h / Œ¥knowns) Œîknowns\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nunknowns::AbstracArray{fmi3ValueReference}: Argument unknowns contains values of typefmi3ValueReference which are identifiers of a variable value of the model. unknowns can be equated with unknowns(variable described above).\nnUnknowns::Csize_t:\nknowns::AbstractArray{fmi3ValueReference}: Argument knowns contains values of type fmi3ValueReference which are identifiers of a variable value of the model.knowns can be equated with knowns(variable described above).\nnKnowns::Csize_t:\nseed::AbstractArray{fmi3Float64}:The vector values Compute the partial derivative with respect to the given entries in vector knowns with the matching evaluate of sensitivity.\nnKnowns::Csize_t:\nsensitivity::AbstractArray{fmi3Float64}: Stores the adjoint derivative vector values.\nnKnowns::Csize_t:\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.11. Getting Partial Derivatives\n\nSee also fmi3GetAdjointDerivative!.\n\n\n\n\n\nfmi3GetAdjointDerivative!(c::FMU3Instance,\n    unknowns::AbstractArray{fmi3ValueReference},\n    knowns::AbstractArray{fmi3ValueReference},\n    sensitivity::AbstractArray{fmi3Float64},\n    seed::AbstractArray{fmi3Float64})\n\nWrapper Function call to compute the partial derivative with respect to the variables unknowns.\n\nComputes the adjoint derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = ùê°(knowns, rest)\n\nunknowns: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknown> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Output> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><ContinuousStateDerivative>).\nEvent Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Output> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Output> with type Real and variability = continuous or discrete. If <ModelStructure><ContinuousStateDerivative> is present, also the variables listed here as state derivatives.\nknowns: Real input variables of function h that changes its value in the actual Mode.\nrest: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables ùêØ_known:\n\nŒîunknowns = (Œ¥h / Œ¥knowns) Œîknowns\n\nArguments\n\nc::FMU3Instance Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nunknowns::AbstracArray{fmi3ValueReference}: Argument unknowns contains values of typefmi3ValueReference which are identifiers of a variable value of the model. unknowns can be equated with unknowns(variable described above).\nknowns::AbstractArray{fmi3ValueReference}: Argument knowns contains values of type fmi3ValueReference which are identifiers of a variable value of the model.knowns can be equated with knowns(variable described above).\nsensitivity::AbstractArray{fmi3Float64}: Stores the directional derivative vector values.\nseed::AbstractArray{fmi3Float64}:The vector values Compute the partial derivative with respect to the given entries in vector knowns with the matching evaluate of sensitivity.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.11. Getting Partial Derivatives\n\nSee also fmi3GetAdjointDerivative!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetOutputDerivatives","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetOutputDerivatives","text":"fmi3GetOutputDerivatives!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nValueReferences::Csizet, order::AbstractArray{fmi3Int32}, values::AbstractArray{fmi3Float64}, nValues::Csizet)\n\nRetrieves the n-th derivative of output values.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::Array{fmi3ValueReference}: Argument vr is an array of nValueReferences value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\norder::Array{fmi3Int32}: Argument order is an array of fmi3Int32 values witch specifys the corresponding order of derivative of the real input variable.\n\nReturns\n\nvalue::AbstactArray{fmi3Float64}: Return value is an array which represents a vector with the values of the derivatives.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.12. Getting Derivatives of Continuous Outputs\n\nSee also fmi3GetOutputDerivatives.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetOutputDerivatives!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetOutputDerivatives!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.12. Getting Derivatives of Continuous Outputs\n\nRetrieves the n-th derivative of output values.\n\nvalueReferences - is a vector of value references that define the variables whose derivatives shall be retrieved. If multiple derivatives of a variable shall be retrieved, list the value reference multiple times.\n\nnValueReferences - is the dimension of the arguments valueReferences and orders.\n\norders - contains the orders of the respective derivative (1 means the first derivative, 2 means the second derivative, ‚Ä¶, 0 is not allowed).  If multiple derivatives of a variable shall be retrieved, provide a list of them in the orders array, corresponding to a multiply occurring value reference in the valueReferences array. The highest order of derivatives retrievable can be determined by the 'maxOutputDerivativeOrder' tag in the ModelDescription.\n\nvalues - is a vector with the values of the derivatives. The order of the values elements is derived from a twofold serialization: the outer level corresponds to the combination of a value reference (e.g., valueReferences[k]) and order (e.g., orders[k]), and the inner level to the serialization of variables as defined in Section 2.2.6.1. The inner level does not exist for scalar variables.\n\nnValues - is the size of the argument values. nValues only equals nValueReferences if all corresponding output variables are scalar variables.\n\n\n\n\n\nfmi3GetOutputDerivatives!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nValueReferences::Csize_t, order::AbstractArray{fmi3Int32}, values::AbstractArray{fmi3Float64}, nValues::Csize_t)\n\nRetrieves the n-th derivative of output values.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::Array{fmi3ValueReference}: Argument vr is an array of nValueReferences value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\nnValueReferences::Csize_t: Argument nValueReferences defines the size of vr.\norder::Array{fmi3Int32}: Argument order is an array of fmi3Int32 values witch specifys the corresponding order of derivative of the real input variable.\nvalues::Array{fmi3Float64}: Argument values is an array with the actual values of these variables.\nnValues::Csize_t: Argument nValues defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.12. Getting Derivatives of Continuous Outputs\n\nSee also fmi3GetOutputDerivatives!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3SampleDirectionalDerivative fmi3SampleDirectionalDerivative! fmi3GetJacobian fmi3GetJacobian! fmi3GetFullJacobian fmi3GetFullJacobian!","category":"page"},{"location":"fmi3_lowlevel_library_functions/#TODO:-Clockstuff","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"TODO: Clockstuff","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3GetIntervalDecimal!\nfmi3SetIntervalDecimal\nfmi3GetIntervalFraction!\nfmi3SetIntervalFraction\nfmi3GetShiftDecimal!\nfmi3GetShiftFraction!\nfmi3GetClock\nfmi3GetClock!\nfmi3SetClock\nfmi3ActivateModelPartition","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetIntervalDecimal!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetIntervalDecimal!","text":"fmi3GetIntervalDecimal!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, intervals::AbstractArray{fmi3Float64}, qualifiers::fmi3IntervalQualifier)\n\nfmi3GetIntervalDecimal retrieves the interval until the next clock tick.\n\nFor input Clocks it is allowed to call this function to query the next activation interval. For changing aperiodic Clock, this function must be called in every Event Mode where this clock was activated. For countdown aperiodic Clock, this function must be called in every Event Mode. Clock intervals are computed in fmi3UpdateDiscreteStates (at the latest), therefore, this function should be called after fmi3UpdateDiscreteStates. For information about fmi3IntervalQualifiers, call ?fmi3IntervalQualifier\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nintervals::AbstractArray{fmi3Float64}: \nqualifiers::fmi3IntervalQualifier: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.9. Clocks\n\nSee also fmi3GetIntervalDecimal!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetIntervalDecimal","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetIntervalDecimal","text":"fmi3SetIntervalDecimal(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, intervals::AbstractArray{fmi3Float64})\n\nSets the interval until the next clock tick\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nintervals::AbstractArray{fmi3Float64}: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.9. Clocks\n\nSee also fmi3SetIntervalDecimal.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetIntervalFraction!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetIntervalFraction!","text":"fmi3GetIntervalFraction!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, intervalCounters::AbstractArray{fmi3UInt64}, resolutions::AbstractArray{fmi3UInt64}, qualifiers::fmi3IntervalQualifier)\n\nfmi3GetIntervalFraction retrieves the interval until the next clock tick.\n\nFor input Clocks it is allowed to call this function to query the next activation interval. For changing aperiodic Clock, this function must be called in every Event Mode where this clock was activated. For countdown aperiodic Clock, this function must be called in every Event Mode. Clock intervals are computed in fmi3UpdateDiscreteStates (at the latest), therefore, this function should be called after fmi3UpdateDiscreteStates. For information about fmi3IntervalQualifiers, call ?fmi3IntervalQualifier\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nintervalCounters::AbstractArray{fmi3UInt64}: \nresolutions::AbstractArray{fmi3UInt64}: \nqualifiers::fmi3IntervalQualifier: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.9. Clocks\n\nSee also fmi3GetIntervalFraction!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetIntervalFraction","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetIntervalFraction","text":"fmi3SetIntervalFraction(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, intervalCounters::AbstractArray{fmi3UInt64}, resolutions::AbstractArray{fmi3UInt64})\n\nSets the interval until the next clock tick. Only allowed if the attribute 'supportsFraction' is set.\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nintervalCounters::AbstractArray{fmi3UInt64}: \nresolutions::AbstractArray{fmi3UInt64}: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.9. Clocks\n\nSee also fmi3SetIntervalFraction.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetShiftDecimal!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetShiftDecimal!","text":"fmi3GetShiftDecimal!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, shifts::AbstractArray{fmi3Float64})\n\nfmi3GetShiftDecimal retrieves the delay to the first Clock tick from the FMU.\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nshifts::AbstractArray{fmi3Float64}:\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.9. Clocks\n\nSee also fmi3GetShiftDecimal!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetShiftFraction!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetShiftFraction!","text":"fmi3GetShiftFraction!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, shiftCounters::AbstractArray{fmi3UInt64}, resolutions::AbstractArray{fmi3UInt64})\n\nfmi3GetShiftFraction retrieves the delay to the first Clock tick from the FMU.\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nshiftCounters::AbstractArray{fmi3UInt64}:\nresolutions::AbstractArray{fmi3UInt64}:\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.9. Clocks\n\nSee also fmi3GetShiftFraction!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetClock","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetClock","text":"fmi3GetClock(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Clock variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Clock}: returns values of an array of fmi3Clock variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetClock.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetClock!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetClock!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetClock!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Clock}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::AbstractArray{fmi3Clock}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetClock!.\n\n\n\n\n\nfmi3GetClock!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Clock})\n\nWrites the clock values of an array of variables in the given field\n\nfmi3GetClock! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Clock}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetClock!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetClock","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetClock","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetClock(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Clock}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::AbstractArray{fmi3Clock}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetClock.\n\n\n\n\n\nfmi3SetClock(c::FMU3Instance, vr::fmi3ValueReferenceFormat, valueSizes::Union{AbstractArray{Csize_t}, Csize_t}, values::Union{AbstractArray{fmi3Clock}, fmi3Clock})\n\nSet the values of an array of clock variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Clock}, fmi3Clock}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetClock.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3ActivateModelPartition","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3ActivateModelPartition","text":"fmi3ActivateModelPartition(c::FMU3Instance, vr::fmi3ValueReference, activationTime::AbstractArray{fmi3Float64})\n\nDuring Clock Activation Mode (see 5.2.2.) after fmi3ActivateModelPartition has been called for a calculated, tunable or changing Clock the FMU provides the information on when the Clock will tick again, i.e. when the corresponding model partition has to be scheduled the next time.\n\nEach fmi3ActivateModelPartition call is associated with the computation of an exposed model partition of the FMU and therefore to an input Clock.\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReference: Argument vr is the value handel called \"ValueReference\" that define the variable that shall be inquired.\nactivationTime::AbstractArray{fmi3Float64}: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 5.2.2. State: Clock Activation Mode\n\nSee also fmi3ActivateModelPartition.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3CallbackClockUpdate","category":"page"},{"location":"fmi3_lowlevel_library_functions/#Conversion-functions","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Conversion functions","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"stringToType\ntypeToString\nstringToVariableNamingConvention\nvariableNamingConventionToString\nintervalQualifierToString","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMIBase.stringToType","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.stringToType","text":"stringToType(s::AbstractString)\n\nConvert s (\"coSimulation\", \"modelExchange\", \"scheduledExecution\") to the corresponding fmi3Type.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIBase.typeToString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.typeToString","text":"typeToString(c::fmi3Type)\n\nConvert fmi3Type c to the corresponding String (\"coSimulation\", \"modelExchange\", \"scheduledExecution\").\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIBase.stringToVariableNamingConvention","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.stringToVariableNamingConvention","text":"stringToVariableNamingConvention(s::AbstractString)\n\nConvert s (\"flat\", \"structured\") to the corresponding fmi3VariableNamingConvention.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIBase.variableNamingConventionToString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.variableNamingConventionToString","text":"variableNamingConventionToString(c::fmi3VariableNamingConvention)\n\nConvert fmi3VariableNamingConvention c to the corresponding String (\"flat\", \"structured\").\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIBase.intervalQualifierToString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.intervalQualifierToString","text":"intervalQualifierToString(c::fmi3IntervalQualifier)\n\nConvert fmi3IntervalQualifier c to the corresponding String (\"intervalNotYetKnown\", \"intervalUnchanged\", \"intervalChanged\").\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3StringToCausality fmi3StatusToString fmi3StringToInitial","category":"page"},{"location":"fmi3_lowlevel_library_functions/#External/Additional-functions","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"External/Additional functions","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3GetNumberOfVariableDependencies\nfmi3GetNumberOfVariableDependencies!\nfmi3GetVariableDependencies\nfmi3GetVariableDependencies!","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetNumberOfVariableDependencies","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetNumberOfVariableDependencies","text":"fmi3GetNumberOfVariableDependencies(c::FMU3Instance, vr::fmi3ValueReference, nvr::Ref{Csize_t})\n\nThe number of dependencies of a given variable, which may change if structural parameters are changed, can be retrieved by calling fmi3GetNumberOfVariableDependencies.\n\nThis information can only be retrieved if the 'providesPerElementDependencies' tag in the ModelDescription is set.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::Union{fmi3ValueReference, String}: Argument vr is the value handel called \"ValueReference\" that define the variable that shall be inquired.\n\nReturns\n\nsize::Integer: Return size is the number of variable dependencies for the given variable \n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.10. Dependencies of Variables\n\nSee also fmi3GetNumberOfVariableDependencies.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetNumberOfVariableDependencies!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetNumberOfVariableDependencies!","text":"fmi3GetNumberOfVariableDependencies!(c::FMU3Instance, vr::fmi3ValueReference, nvr::Ref{Csize_t})\n\nThe number of dependencies of a given variable, which may change if structural parameters are changed, can be retrieved by calling fmi3GetNumberOfVariableDependencies.\n\nThis information can only be retrieved if the 'providesPerElementDependencies' tag in the ModelDescription is set.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReference: Argument vr is the value handel called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.10. Dependencies of Variables\n\nSee also fmi3GetNumberOfVariableDependencies!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetVariableDependencies","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetVariableDependencies","text":"fmi3GetVariableDependencies(c::FMU3Instance, vr::Union{fmi3ValueReference, String})\n\nThe actual dependencies (of type dependenciesKind) can be retrieved by calling the function fmi3GetVariableDependencies:\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::Union{fmi3ValueReference, String}: Argument vr is the value handel called \"ValueReference\" that define the variable that shall be inquired.\n\nReturns\n\nelementIndicesOfDependent::AbstractArray{Csize_t}: must point to a buffer of size_t values of size nDependencies allocated by the calling environment.    It is filled in by this function with the element index of the dependent variable that dependency information is provided for. The element indices start with 1. Using the element index 0 means all elements of the variable. (Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in Section 2.2.6.1.)\nindependents::AbstractArray{fmi3ValueReference}:  must point to a buffer of fmi3ValueReference values of size nDependencies allocated by the calling environment.    It is filled in by this function with the value reference of the independent variable that this dependency entry is dependent upon.\nelementIndicesIndependents::AbstractArray{Csize_t}: must point to a buffer of size_t values of size nDependencies allocated by the calling environment.    It is filled in by this function with the element index of the independent variable that this dependency entry is dependent upon. The element indices start with 1. Using the element index 0 means all elements of the variable. (Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in Section 2.2.6.1.)\ndependencyKinds::AbstractArray{fmi3DependencyKind}: must point to a buffer of dependenciesKind values of size nDependencies allocated by the calling environment.    It is filled in by this function with the enumeration value describing the dependency of this dependency entry.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.10. Dependencies of Variables\n\nSee also fmi3GetVariableDependencies!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetVariableDependencies!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetVariableDependencies!","text":"fmi3GetVariableDependencies!(c::FMU3Instance, vr::fmi3ValueReference, elementIndiceOfDependents::AbstractArray{Csize_t}, independents::AbstractArray{fmi3ValueReference},  \n    elementIndiceOfInpendents::AbstractArray{Csize_t}, dependencyKind::AbstractArray{fmi3DependencyKind}, ndependencies::Csize_t)\n\nThe actual dependencies (of type dependenciesKind) can be retrieved by calling the function fmi3GetVariableDependencies:\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReference: Argument vr is the value handel called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nelementIndiceOfDependents::AbstractArray{Csize_t}: must point to a buffer of size_t values of size nDependencies allocated by the calling environment.    It is filled in by this function with the element index of the dependent variable that dependency information is provided for. The element indices start with 1. Using the element index 0 means all elements of the variable. (Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in Section 2.2.6.1.)\nindependents::AbstractArray{fmi3ValueReference}:  must point to a buffer of fmi3ValueReference values of size nDependencies allocated by the calling environment.    It is filled in by this function with the value reference of the independent variable that this dependency entry is dependent upon.\nelementIndiceOfInpendents::AbstractArray{Csize_t}: must point to a buffer of size_t values of size nDependencies allocated by the calling environment.    It is filled in by this function with the element index of the independent variable that this dependency entry is dependent upon. The element indices start with 1. Using the element index 0 means all elements of the variable. (Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in Section 2.2.6.1.)\ndependencyKind::AbstractArray{fmi3DependencyKind}: must point to a buffer of dependenciesKind values of size nDependencies allocated by the calling environment.    It is filled in by this function with the enumeration value describing the dependency of this dependency entry.\nndependencies::Csize_t: specifies the number of dependencies that the calling environment allocated space for in the result buffers, and should correspond to value obtained by calling fmi3GetNumberOfVariableDependencies.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.10. Dependencies of Variables\n\nSee also fmi3GetVariableDependencies!.\n\n\n\n\n\n","category":"function"},{"location":"examples/parameter_optimization/#FMU-Parameter-Optimization","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Tutorial by Tobias Thummerer","category":"page"},{"location":"examples/parameter_optimization/#License","page":"FMU Parameter Optimization","title":"License","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/parameter_optimization/#Introduction-to-the-example","page":"FMU Parameter Optimization","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"This example shows how a parameter optimization can be set up for a FMU. The goal is to fit FMU parameters (and initial states), so that a reference trajectory is fit as good as possible.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Note, that this tutorial covers optimization without gradient information. Basically, FMI.jl supports gradient based optimization, too.","category":"page"},{"location":"examples/parameter_optimization/#Other-formats","page":"FMU Parameter Optimization","title":"Other formats","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/parameter_optimization/#Getting-started","page":"FMU Parameter Optimization","title":"Getting started","text":"","category":"section"},{"location":"examples/parameter_optimization/#Installation-prerequisites","page":"FMU Parameter Optimization","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":" Description Command\n1. Enter Package Manager via ]\n2. Install FMI via add FMI\n3. Install FMIZoo via add FMIZoo\n4. Install Optim  via add Optim\n5. Install Plots  via add Plots","category":"page"},{"location":"examples/parameter_optimization/#Code-section","page":"FMU Parameter Optimization","title":"Code section","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"# imports\nusing FMI\nusing FMIZoo\nusing Optim\nusing Plots","category":"page"},{"location":"examples/parameter_optimization/#Simulation-setup","page":"FMU Parameter Optimization","title":"Simulation setup","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Next, the start time and end time of the simulation are set.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"tStart = 0.0\ntStop = 5.0\ntStep = 0.1\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/parameter_optimization/#Import-FMU","page":"FMU Parameter Optimization","title":"Import FMU","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"# we use an FMU from the FMIZoo.jl\nfmu = loadFMU(\"SpringPendulum1D\", \"Dymola\", \"2022x\"; type=:ME)\ninfo(fmu)","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Now, the optimization objective (the function to minimize) needs to be defined. In this case, we just want to do a simulation and compare it to a regular sin wave.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"s_tar = 1.0 .+ sin.(tSave)\n\n# a function to simulate the FMU for given parameters\nfunction simulateFMU(p)\n    s0, v0, c, m = p # unpack parameters: s0 (start position), v0 (start velocity), c (spring constant) and m (pendulum mass)\n\n    # pack the parameters into a dictionary\n    paramDict = Dict{String, Any}()\n    paramDict[\"spring.c\"] = c \n    paramDict[\"mass.m\"] = m\n\n    # pack the start state\n    x0 = [s0, v0]\n\n    # simulate with given start stae and parameters\n    sol = simulate(fmu, (tStart, tStop); x0=x0, parameters=paramDict, saveat=tSave)\n\n    # get state with index 1 (the position) from the solution\n    s_res = getState(sol, 1; isIndex=true) \n\n    return s_res\nend\n\n# the optimization objective\nfunction objective(p)\n    s_res = simulateFMU(p)\n\n    # return the position error sum between FMU simulation (s_res) and target (s_tar)\n    return sum(abs.(s_tar .- s_res))    \nend","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Now let's see how far we are away for our guess parameters:","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"s0 = 0.0 \nv0 = 0.0\nc = 1.0\nm = 1.0 \np = [s0, v0, c, m]\n\nobj_before = objective(p) # not really good!","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Let's have a look on the differences:","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"s_fmu = simulateFMU(p); # simulate the position\n\nplot(tSave, s_fmu; label=\"FMU\")\nplot!(tSave, s_tar; label=\"Optimization target\")","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Not that good. So let's do a bit of optimization!","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"opt = Optim.optimize(objective, p; iterations=250) # do max. 250 iterations\nobj_after = opt.minimum # much better!\np_res = opt.minimizer # the optimized parameters","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Looks promising, let's have a look on the results plot:","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"s_fmu = simulateFMU(p_res); # simulate the position\n\nplot(tSave, s_fmu; label=\"FMU\")\nplot!(tSave, s_tar; label=\"Optimization target\")","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Actually a pretty fit! If you have higher requirements, check out the Optim.jl library.","category":"page"},{"location":"examples/parameter_optimization/#Summary","page":"FMU Parameter Optimization","title":"Summary","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"This tutorial showed how a parameter (and start value) optimization can be performed on a FMU with a gradient free optimizer. This tutorial will be extended soon to further show how convergence for large parameter spaces can be improoved!","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMI-Common-Concepts-for-Model-Exchange-and-Co-Simulation","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"In both cases, FMI defines an input/output block of a dynamic model where the distribution of the block, the platform dependent header file, several access functions, as well as the schema files are identical.","category":"page"},{"location":"fmi2_lowlevel_library_functions/#Opening-and-closing-FMUs","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Opening and closing FMUs","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"","category":"page"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2Unzip fmi2Load fmi2Reload fmi2Unload","category":"page"},{"location":"fmi2_lowlevel_library_functions/#Creation,-Destruction-and-Logging-of-FMU-Instances","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Creation, Destruction and Logging of FMU Instances","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2Instantiate!\nfmi2Instantiate\nfmi2FreeInstance\nfmi2SetDebugLogging","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2Instantiate!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2Instantiate!","text":"fmi2Instantiate!(fmu::FMU2;\n                    instanceName::String=fmu.modelName,\n                    type::fmi2Type=fmu.type,\n                    pushComponents::Bool = true,\n                    visible::Bool = false,\n                    loggingOn::Bool = fmu.executionConfig.loggingOn,\n                    externalCallbacks::Bool = fmu.executionConfig.externalCallbacks,\n                    logStatusOK::Bool=true,\n                    logStatusWarning::Bool=true,\n                    logStatusDiscard::Bool=true,\n                    logStatusError::Bool=true,\n                    logStatusFatal::Bool=true,\n                    logStatusPending::Bool=true)\n\nCreate a new instance of the given fmu, adds a logger if logginOn == true.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nKeywords\n\ninstanceName::String=fmu.modelName: Name of the instance\ntype::fmi2Type=fmu.type: Defines whether a Co-Simulation or Model Exchange is present\npushComponents::Bool = true: Defines if the fmu components should be pushed in the application.\nvisible::Bool = false if the FMU should be started with graphic interface, if supported (default=false)\nloggingOn::Bool = fmu.executionConfig.loggingOn if the FMU should log and display function calls (default=false)\nexternalCallbacks::Bool = fmu.executionConfig.externalCallbacks if an external shared library should be used for the fmi2CallbackFunctions, this may improve readability of logging messages (default=false)\nlogStatusOK::Bool=true whether to log status of kind fmi2OK (default=true)\nlogStatusWarning::Bool=true whether to log status of kind fmi2Warning (default=true)\nlogStatusDiscard::Bool=true whether to log status of kind fmi2Discard (default=true)\nlogStatusError::Bool=true whether to log status of kind fmi2Error (default=true)\nlogStatusFatal::Bool=true whether to log status of kind fmi2Fatal (default=true)\nlogStatusPending::Bool=true whether to log status of kind fmi2Pending (default=true)\n\nReturns\n\nReturns the instance of a new FMU component.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\nSee also fmi2Instantiate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2Instantiate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2Instantiate","text":"Source: FMISpec2.0.2[p.19]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nThe function returns a new instance of an FMU.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2FreeInstance","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2FreeInstance","text":"Source: FMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nDisposes the given instance, unloads the loaded model, and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface. If a null pointer is provided for ‚Äúc‚Äù, the function call is ignored (does not have an effect).\n\nRemoves the component from the FMUs component list.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetDebugLogging","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetDebugLogging","text":"Source: FMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nThe function controls debug logging that is output via the logger function callback. If loggingOn = fmi2True, debug logging is enabled, otherwise it is switched off.\n\n\n\n\n\nfmi2SetDebugLogging(c::FMU2Component, loggingOn::fmi2Boolean, nCategories::Unsigned, categories::Ptr{Nothing})\n\nControl the use of the logging callback function, version independent.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nloggingOn::fmi2Boolean: If loggingOn = fmi2True, debug logging is enabled for the log categories specified in categories, otherwise it is disabled. Type fmi2Boolean is defined as an alias Type for the C-Type Boolean and is to be used with fmi2True and fmi2False.\nnCategories::Unsigned: Argument nCategories defines the length of the argument categories.\ncategories::Ptr{Nothing}:\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nSee also fmi2SetDebugLogging.\n\n\n\n\n\nfmi2SetDebugLogging(c::FMU2Component)\n\nControl the use of the logging callback function, version independent.\n\nArguments\n\nc::FMU2Component: Argument c is a mutable struct representing an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nSee also fmi2SetDebugLogging.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#Initialization,-Termination,-and-Resetting-an-FMU","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Initialization, Termination, and Resetting an FMU","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2SetupExperiment\nfmi2EnterInitializationMode\nfmi2ExitInitializationMode\nfmi2Terminate\nfmi2Reset","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetupExperiment","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetupExperiment","text":"Source: FMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nInforms the FMU to setup the experiment. This function must be called after fmi2Instantiate and before fmi2EnterInitializationMode is called.The function controls debug logging that is output via the logger function callback. If loggingOn = fmi2True, debug logging is enabled, otherwise it is switched off.\n\n\n\n\n\nfmi2SetupExperiment(c::FMU2Component, toleranceDefined::fmi2Boolean, tolerance::fmi2Real, startTime::fmi2Real, stopTimeDefined::fmi2Boolean, stopTime::fmi2Real)\n\nInforms the FMU to setup the experiment. This function must be called after fmi2Instantiate and before fmi2EnterInitializationMode is called.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ntoleranceDefined::fmi2Boolean: Arguments toleranceDefined depend on the FMU type:\nfmuType = fmi2ModelExchange: If toleranceDefined = fmi2True, then the model is called with a numerical integration scheme where the step size is controlled by using tolerance for error estimation. In such a case, all numerical algorithms used inside the model (for example, to solve non-linear algebraic equations) should also operate with an error estimation of an appropriate smaller relative tolerance.\nfmuType = fmi2CoSimulation: If toleranceDefined = fmi2True, then the communication interval of the slave is controlled by error estimation.  In case the slave utilizes a numerical integrator with variable step size and error estimation, it is suggested to use ‚Äútolerance‚Äù for the error estimation of the internal integrator (usually as relative tolerance). An FMU for Co-Simulation might ignore this argument.\nstartTime::fmi2Real: Argument startTime can be used to check whether the model is valid within the given boundaries or to allocate memory which is necessary for storing results. It is the fixed initial value of the independent variable and if the independent variable is time, startTime is the starting time of initializaton.\nstopTimeDefined::fmi2Boolean:  If stopTimeDefined = fmi2True, then stopTime is the defined final value of the independent variable and if stopTimeDefined = fmi2False, then no final value\n\nof the independent variable is defined and argument stopTime is meaningless.\n\nstopTime::fmi2Real: Argument stopTime can be used to check whether the model is valid within the given boundaries or to allocate memory which is necessary for storing results. It is the fixed final value of the independent variable and if the independent variable is ‚Äútime‚Äù, stopTime is the stop time of the simulation.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2SetupExperiment.\n\n\n\n\n\nfmi2SetupExperiment(c::FMU2Component, \n                        startTime::Union{Real, Nothing} = nothing, \n                        stopTime::Union{Real, Nothing} = nothing; \n                        tolerance::Union{Real, Nothing} = nothing)\n\nSetup the simulation but without defining all of the parameters.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct representing an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstartTime::Union{Real, Nothing} = nothing: startTime is a real number which sets the value of starting time of the experiment. The default value is set automatically if doing nothing (default = nothing).\nstopTime::Union{Real, Nothing} = nothing: stopTime is a real number which sets the value of ending time of the experiment. The default value is set automatically if doing nothing (default = nothing).\n\nKeywords\n\ntolerance::Union{Real, Nothing} = nothing: tolerance is a real number which sets the value of tolerance range. The default value is set automatically if doing nothing (default = nothing).\n\nReturns\n\nReturns a warning if str.state is not called in fmi2ComponentStateInstantiated.\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2SetupExperiment.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2EnterInitializationMode","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2EnterInitializationMode","text":"Source: FMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nInforms the FMU to enter Initialization Mode. Before calling this function, all variables with attribute <ScalarVariable initial = \"exact\" or \"approx\"> can be set with the ‚Äúfmi2SetXXX‚Äù functions (the ScalarVariable attributes are defined in the Model Description File, see section 2.2.7). Setting other variables is not allowed. Furthermore, fmi2SetupExperiment must be called at least once before calling fmi2EnterInitializationMode, in order that startTime is defined.\n\n\n\n\n\nfmi2EnterInitializationMode(c::FMU2Component)\n\nInforms the FMU to enter Initialization Mode. Before calling this function, all variables with attribute <ScalarVariable initial = \"exact\" or \"approx\"> can be set with the ‚Äúfmi2SetXXX‚Äù functions (the ScalarVariable attributes are defined in the Model Description File, see section 2.2.7). Setting other variables is not allowed. Furthermore, fmi2SetupExperiment must be called at least once before calling fmi2EnterInitializationMode, in order that startTime is defined.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2EnterInitializationMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2ExitInitializationMode","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2ExitInitializationMode","text":"Source: FMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nInforms the FMU to exit Initialization Mode.\n\n\n\n\n\nfmi2ExitInitializationMode(c::FMU2Component)\n\nInforms the FMU to exit Initialization Mode.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2EnterInitializationMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2Terminate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2Terminate","text":"Source: FMISpec2.0.2[p.24]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nInforms the FMU that the simulation run is terminated.\n\n\n\n\n\nfmi2Terminate(c::FMU2Component; soft::Bool=false)\n\nInforms the FMU that the simulation run is terminated.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2Terminate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2Reset","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2Reset","text":"Source: FMISpec2.0.2[p.24]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nIs called by the environment to reset the FMU after a simulation run. The FMU goes into the same state as if fmi2Instantiate would have been called.\n\n\n\n\n\nfmi2Reset(c::FMU2Component; soft::Bool=false)\n\nIs called by the environment to reset the FMU after a simulation run. The FMU goes into the same state as if fmi2Instantiate would have been called.All variables have their default values. Before starting a new run, fmi2SetupExperiment and fmi2EnterInitializationMode have to be called.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.3 Link: https://fmi-standard.org/\nFMISpec2.0.3[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.3[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.3[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2Terminate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#Getting-and-Setting-Variable-Values","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Getting and Setting Variable Values","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"All variable values of an FMU are identified with a variable handle called ‚Äúvalue reference‚Äù. The handle is defined in the modelDescription.xml file (as attribute ‚ÄúvalueReference‚Äù in element ‚ÄúScalarVariable‚Äù). Element ‚ÄúvalueReference‚Äù might not be unique for all variables. If two or more variables of the same base data type (such as fmi2Real) have the same valueReference, then they have identical values but other parts of the variable definition might be different (for example, min/max attributes).","category":"page"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2GetReal\nfmi2GetReal!\nfmi2GetInteger\nfmi2GetInteger!\nfmi2GetBoolean\nfmi2GetBoolean!\nfmi2GetString\nfmi2GetString!\nfmi2SetReal\nfmi2SetInteger\nfmi2SetBoolean\nfmi2SetString","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2GetReal","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2GetReal","text":"fmi2GetReal(c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nGet the values of an array of fmi2Real variables.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fm2Real}: Returns values of an array of fmi2Real variables with the dimension of fmi2ValueReferenceFormat length.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetReal.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetReal!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetReal!","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2GetReal!(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Real})\n\nFunctions to get and set values of variables idetified by their valueReference\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fm2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetReal!.\n\n\n\n\n\nfmi2GetReal!(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::AbstractArray{fmi2Real})\n\nGet the values of an array of fmi2Real variables.\n\nrites the real values of an array of variables in the given field\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fm2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetReal!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2GetInteger","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2GetInteger","text":"fmi2GetInteger(c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nReturns the integer values of an array of variables\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi2Integer}: Return values is an array with the actual values of these variables.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetInteger!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetInteger!","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2GetInteger!(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Integer})\n\nWrites the integer values of an array of variables in the given field\n\nfmi2GetInteger! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels, called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi2Integer}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!.\n\n\n\n\n\nfmi2GetInteger!(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::AbstractArray{fmi2Integer})\n\nWrites the integer values of an array of variables in the given field\n\nfmi2GetInteger! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::Array{fmi2Integer}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2GetBoolean","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2GetBoolean","text":"fmi2GetBoolean(c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nGet the values of an array of fmi2Boolean variables.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi2Boolean}: Return values is an array with the actual values of these variables.\n\nSee also fmi2GetBoolean!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetBoolean!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetBoolean!","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2GetBoolean!(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Boolean})\n\nWrites the boolean values of an array of variables in the given field\n\nfmi2GetBoolean! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::AbstractArray{fmi2Boolean}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean!.\n\n\n\n\n\nfmi2GetBoolean!(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::AbstractArray{fmi2Boolean})\n\nWrites the boolean values of an array of variables in the given field\n\nfmi2GetBoolean! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi2Boolean}: Argument value is an array with the actual values of these variables\n\nReturns\n\nReturn singleton instance of type Nothing, if there is no value to return (as in a C void function) or when a variable or field holds no value.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2GetString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2GetString","text":"fmi2GetString(c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nGet the values of an array of fmi2String variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi2String}:  Return values is an array with the actual values of these variables.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetString!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetString!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetString!","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2GetString!(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::Union{AbstractArray{Ptr{Cchar}}, AbstractArray{Ptr{UInt8}}})\n\nFunctions to get and set values of variables idetified by their valueReference\n\nThese functions are especially used to get the actual values of output variables if a model is connected with other models.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::Union{AbstractArray{Ptr{Cchar}, AbstractArray{Ptr{UInt8}}}: The value argument is an AbstractArray of values whose memory address refers to data of type Cchar or UInt8and describes a vector with the actual values of these. variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetString!.\n\n\n\n\n\nfmi2GetString!(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::AbstractArray{fmi2String})\n\nWrites the string values of an array of variables in the given field\n\nThese functions are especially used to get the actual values of output variables if a model is connected with other models.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi2String}: Argument values is an AbstractArray with the actual values of these variables\n\nReturns\n\nReturn singleton instance of type Nothing, if there is no value to return (as in a C void function) or when a variable or field holds no value.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetString!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetReal","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetReal","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2SetReal(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Real})\n\nFunctions to get and set values of variables idetified by their valueReference\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels, called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fm2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetReal.\n\n\n\n\n\nfmi2SetReal(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{AbstractArray{<:Real}, <:Real})\n\nSet the values of an array of real variables\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{Array{<:Real}, <:Real}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2SetReal.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetInteger","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetInteger","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2SetInteger(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Integer})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels, called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi2Integer}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!.\n\n\n\n\n\nfmi2SetInteger(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{AbstractArray{<:Integer}, <:Integer})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nvalues::Union{Array{<:Integer}, <:Integer}: Argument values is an array or a single value with type Integer or any subtyp\n\nReturns\n\nstatus::fmi2Status: Return status indicates the success of the function call.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2SetInteger.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetBoolean","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetBoolean","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2SetBoolean(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Boolean})\n\nFunctions to get and set values of variables idetified by their valueReference\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::AbstractArray{fmi2Boolean}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean.\n\n\n\n\n\nfmi2SetBoolean(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{AbstractArray{Bool}, Bool})\n\nSet the values of an array of boolean variables\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{Array{Bool}, Bool}: Argument values is an array or a single value with type Boolean or any subtyp\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetString","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2SetString(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::Union{AbstractArray{Ptr{Cchar}}, AbstractArray{Ptr{UInt8}}})\n\nSet the values of an array of string variables\n\nFor the exact rules on which type of variables fmi2SetXXX can be called see FMISpec2.0.2 section 2.2.7 , as well as FMISpec2.0.2 section 3.2.3 in case of ModelExchange and FMISpec2.0.2 section 4.2.4 in case ofCoSimulation.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::Union{AbstractArray{Ptr{Cchar}, AbstractArray{Ptr{UInt8}}}: The value argument is an AbstractArray of values whose memory address refers to data of type Cchar or UInt8and describes a vector with the actual values of these. variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetString!.\n\n\n\n\n\nfmi2SetString(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{AbstractArray{String}, String})\n\nSet the values of an array of string variables\n\nFor the exact rules on which type of variables fmi2SetXXX can be called see FMISpec2.0.2 section 2.2.7 , as well as FMISpec2.0.2 section 3.2.3 in case of ModelExchange and FMISpec2.0.2 section 4.2.4 in case of CoSimulation.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{Array{String}, String}: Argument values is an array or a single value with type String.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.46]: 2.2.7 Definition of Model Variables\nFMISpec2.0.2[p.46]: 3.2.3 State Machine of Calling Sequence\nFMISpec2.0.2[p.108]: 4.2.4 State Machine of Calling Sequence from Master to Slave\n\nSee also fmi2SetString.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2Get fmi2Get! fmi2Set","category":"page"},{"location":"fmi2_lowlevel_library_functions/#Getting-and-Setting-the-Complete-FMU-State","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Getting and Setting the Complete FMU State","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"The FMU has an internal state consisting of all values that are needed to continue a simulation. This internal state consists especially of the values of the continuous-time states, iteration variables, parameter values, input values, delay buffers, file identifiers, and FMU internal status information. With the functions of this section, the internal FMU state can be copied and the pointer to this copy is returned to the environment. The FMU state copy can be set as actual FMU state, in order to continue the simulation from it.","category":"page"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2GetFMUstate\nfmi2GetFMUstate!\nfmi2SetFMUstate\nfmi2FreeFMUstate\nfmi2SerializedFMUstateSize\nfmi2SerializedFMUstateSize!\nfmi2SerializeFMUstate\nfmi2SerializeFMUstate!\nfmi2DeSerializeFMUstate\nfmi2DeSerializeFMUstate!","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2GetFMUstate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2GetFMUstate","text":"fmi2GetFMUstate(c::FMU2Component)\n\nMakes a copy of the internal FMU state and returns a pointer to this copy.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nReturn state is a pointer to a copy of the internal FMU state.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2GetFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetFMUstate!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetFMUstate!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2GetFMUstate makes a copy of the internal FMU state and returns a pointer to this copy\n\n\n\n\n\nfmi2GetFMUstate!(c::FMU2Component, FMUstate::Ref{fmi2FMUstate})\n\nMakes a copy of the internal FMU state and returns a pointer to this copy.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::Ref{fmi2FMUstate}:If on entry FMUstate == NULL, a new allocation is required. If FMUstate != NULL, then FMUstate points to a previously returned FMUstate that has not been modified since.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetFMUstate!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetFMUstate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetFMUstate","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2SetFMUstate copies the content of the previously copied FMUstate back and uses it as actual new FMU state.\n\n\n\n\n\nfmi2SetFMUstate(c::FMU2Component, FMUstate::fmi2FMUstate)\n\nCopies the content of the previously copied FMUstate back and uses it as actual new FMU state.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::fmi2FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2GetFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2FreeFMUstate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2FreeFMUstate","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and setting the complete FMU state\n\nfmi2FreeFMUstate frees all memory and other resources allocated with the fmi2GetFMUstate call for this FMUstate.\n\n\n\n\n\nfmi2FreeFMUstate(c::FMU2Component, FMUstate::Ref{fmi2FMUstate})\n\nFrees all memory and other resources allocated with the fmi2GetFMUstate call for this FMUstate.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::Ref{fmi2FMUstate}: Argument FMUstate is an object that safely references data of type fmi3FMUstate which is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2FreeFMUstate.\n\n\n\n\n\nfmi2FreeFMUstate!(c::FMU2Component, state::fmi2FMUstate)\n\nFree the memory for the allocated FMU state\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nReturn singleton instance of type Nothing, if there is no value to return (as in a C void function) or when a variable or field holds no value.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2FreeFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2SerializedFMUstateSize","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2SerializedFMUstateSize","text":"fmi2SerializedFMUstateSize(c::FMU2Component, state::fmi2FMUstate)\n\nReturns the size of the byte vector in which the FMUstate can be stored.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nReturn size is an object that safely references a value of type Csize_t.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializedFMUstateSize.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SerializedFMUstateSize!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SerializedFMUstateSize!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2SerializedFMUstateSize returns the size of the byte vector, in order that FMUstate can be stored in it.\n\n\n\n\n\nfmi2SerializedFMUstateSize!(c::FMU2Component, FMUstate::fmi2FMUstate, size::Ref{Csize_t})\n\nStores the size of the byte vector in the given referenced Address, in order that FMUstate can be stored in it.\n\nArgument\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::fmi2FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nsize::Ref{Csize_t}: Argument size is an object that safely references a value of type Csize_t and defines the size of the byte vector in which the FMUstate can be stored.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializedFMUstateSize!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2SerializeFMUstate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2SerializeFMUstate","text":"fmi2SerializeFMUstate(c::FMU2Component, state::fmi2FMUstate)\n\nSerializes the data referenced by the pointer FMUstate and copies this data into the byte vector serializedState of length size to be provided by the environment.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nserializedState:: Array{fmi2Byte}: Return serializedState contains the copy of the serialized data referenced by the pointer FMUstate\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializeFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SerializeFMUstate!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SerializeFMUstate!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2SerializeFMUstate serializes the data which is referenced by pointer FMUstate and copies this data in to the byte vector serializedState of length size\n\n\n\n\n\nfmi2SerializeFMUstate!(c::FMU2Component, FMUstate::fmi2FMUstate, serialzedState::AbstractArray{fmi2Byte}, size::Csize_t)\n\nSerializes the data which is referenced by pointer FMUstate and copies this data in to the byte vector serializedState of length size, that must be provided by the environment.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nserialzedState::AbstractArray{fmi2Byte}: Argument serializedState contains the copy of the serialized data referenced by the pointer FMUstate.\nsize::Csize_t: Argument size defines the length of the serialized vector.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializeFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2DeSerializeFMUstate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2DeSerializeFMUstate","text":"fmi2DeSerializeFMUstate(c::FMU2Component, serializedState::AbstractArray{fmi2Byte})\n\nDeserialize the data in the serializedState fmi2Byte field\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nserializedState::Array{fmi2Byte}: Argument serializedState contains the fmi2Byte field to be deserialized.\n\nReturns\n\nReturn state is a pointer to a copy of the internal FMU state.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2DeSerializeFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2DeSerializeFMUstate!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2DeSerializeFMUstate!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2DeSerializeFMUstate deserializes the byte vector serializedState of length size, constructs a copy of the FMU state and returns FMUstate, the pointer to this copy.\n\n\n\n\n\nfmi2DeSerializeFMUstate!(c::FMU2Component, serializedState::AbstractArray{fmi2Byte}, size::Csize_t, FMUstate::Ref{fmi2FMUstate})\n\nDeserializes the byte vector serializedState of length size, constructs a copy of the FMU state and stores the FMU state in the given address of the reference FMUstate, the pointer to this copy.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nserialzedState::AbstractArray{fmi2Byte}: Argument serializedState contains the copy of the serialized data referenced by the pointer FMUstate.\nsize::Csize_t: Argument size defines the length of the serialized vector.\nFMUstate::Ref{fmi2FMUstate}: Argument FMUstate is an object that safely references data of type fmi3FMUstate which is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2DeSerializeFMUstate!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#Getting-Partial-Dervatives","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Getting Partial Dervatives","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"It is optionally possible to provide evaluation of partial derivatives for an FMU. For Model Exchange, this means computing the partial derivatives at a particular time instant. For Co-Simulation, this means to compute the partial derivatives at a particular communication point. One function is provided to compute directional derivatives. This function can be used to construct the desired partial derivative matrices.","category":"page"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2GetDirectionalDerivative\nfmi2GetDirectionalDerivative!\nfmi2SetRealInputDerivatives\nfmi2GetRealOutputDerivatives!","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2GetDirectionalDerivative","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2GetDirectionalDerivative","text":"fmi2GetDirectionalDerivative(c::FMU2Component,\n                                  vUnknown_ref::AbstractArray{fmi2ValueReference},\n                                  vKnown_ref::AbstractArray{fmi2ValueReference},\n                                  dvKnown::Union{AbstractArray{fmi2Real}, Nothing} = nothing)\n\nWrapper Function call to compute the partial derivative with respect to the variables vKnown_ref.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns.The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1). In every Mode, the general form of the FMU equations are: ùêØunknown = ùê°(ùêØknown, ùêØ_rest)\n\nv_unknown: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknowns> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Outputs> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><Derivatives>).\nEvent Mode (ModelExchange): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Outputs> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Outputs> with type Real and variability = continuous or discrete. If <ModelStructure><Derivatives> is present, also the variables listed here as state derivatives.\nv_known: Real input variables of function h that changes its value in the actual Mode.\nv_rest:Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables ùêØ_known:\n\nŒîv_unknown = (Œ¥h / Œ¥v_known) Œîv_known\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::AbstractArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model. vUnknown_ref can be equated with v_unknown(variable described above).\nvKnown_ref::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref can be equated with v_known(variable described above).\ndvKnown::Union{AbstractArray{fmi2Real}, Nothing} = nothing: If no seed vector is passed the value nothing is used. The vector values Compute the partial derivative with respect to the given entries in vector vKnown_ref with the matching evaluate of dvKnown.  # geh√∂rt das zu den v_rest values\n\nReturns\n\ndvUnknown::Array{fmi2Real}: Return dvUnknown contains the directional derivative vector values.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.9 Getting Partial Derivatives\n\nSee also fmi2GetDirectionalDerivative!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetDirectionalDerivative!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetDirectionalDerivative!","text":"Source: FMISpec2.0.2[p.26]: 2.1.9 Getting Partial Derivatives\n\nThis function computes the directional derivatives of an FMU.\n\nŒîvUnknown = ‚àÇh / ‚àÇvKnown ‚ãÖ ŒîvKnown\n\n\n\n\n\nfmi2GetDirectionalDerivative!(c::FMU2Component,\n                                   vUnknown_ref::AbstractArray{fmi2ValueReference},\n                                   nUnknown::Csize_t,\n                                   vKnown_ref::AbstractArray{fmi2ValueReference},\n                                   nKnown::Csize_t,\n                                   dvKnown::AbstractArray{fmi2Real},\n                                   dvUnknown::AbstractArray{fmi2Real})\n\nWrapper Function call to compute the partial derivative with respect to the variables vKnown_ref.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1). In every Mode, the general form of the FMU equations are: ùêØunknown = ùê°(ùêØknown, ùêØ_rest)\n\nv_unknown: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknowns> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Outputs> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><Derivatives>).\nEvent Mode (ModelExchange): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Outputs> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Outputs> with type Real and variability = continuous or discrete. If <ModelStructure><Derivatives> is present, also the variables listed here as state derivatives.\nv_known: Real input variables of function h that changes its value in the actual Mode.\nv_rest:Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables ùêØ_known:\n\nŒîvunknown = (Œ¥h / Œ¥vknown) Œîv_known\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::AbstracArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model. vUnknown_ref can be equated with v_unknown(variable described above).\nnUnknown::Csize_t: Length of the Unknown Array.\nvKnown_ref::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref can be equated with v_known(variable described above).\nnKnown::Csize_t: Length of the Known Array.\ndvKnown::AbstractArray{fmi2Real}:The vector values Compute the partial derivative with respect to the given entries in vector vKnown_ref with the matching evaluate of dvKnown.\ndvUnknown::AbstractArray{fmi2Real}: Stores the directional derivative vector values.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.9 Getting Partial Derivatives\n\nSee also fmi2GetDirectionalDerivative!.\n\n\n\n\n\nfmiGetDirectionalDerivative!(c::FMU2Component,\n                                  vUnknown_ref::AbstractArray{fmi2ValueReference},\n                                  vKnown_ref::AbstractArray{fmi2ValueReference},\n                                  dvKnown::Array{fmi2Real},\n                                  dvUnknown::AbstractArray)\n\nWrapper Function call to compute the partial derivative with respect to the variables vKnown_ref.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns.The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1). In every Mode, the general form of the FMU equations are: ùêØunknown = ùê°(ùêØknown, ùêØ_rest)\n\nv_unknown: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknowns> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Outputs> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><Derivatives>).\nEvent Mode (ModelExchange): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Outputs> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Outputs> with type Real and variability = continuous or discrete. If <ModelStructure><Derivatives> is present, also the variables listed here as state derivatives.\nv_known: Real input variables of function h that changes its value in the actual Mode.\nv_rest:Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables ùêØ_known:\n\nŒîv_unknown = (Œ¥h / Œ¥v_known) Œîv_known\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::AbstracArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model. vUnknown_ref can be equated with v_unknown(variable described above).\nvKnown_ref::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref can be equated with v_known(variable described above).\ndvUnknown::AbstractArray{fmi2Real}: Stores the directional derivative vector values.\ndvKnown::Union{AbstractArray{fmi2Real}, Nothing} = nothing: If no seed vector is passed the value nothing is used. The vector values Compute the partial derivative with respect to the given entries in vector vKnown_ref with the matching evaluate of dvKnown.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.9 Getting Partial Derivatives\n\nSee also fmi2GetDirectionalDerivative!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetRealInputDerivatives","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetRealInputDerivatives","text":"Source: FMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\nSets the n-th time derivative of real input variables. vr defines the value references of the variables the array order specifies the corresponding order of derivation of the variables\n\n\n\n\n\nfmi2SetRealInputDerivatives(c::FMU2Component,\n                                vr::AbstractArray{fmi2ValueReference},\n                                nvr::Csize_t,\n                                order::AbstractArray{fmi2Integer}, \n                                value::AbstractArray{fmi2Real})\n\nSets the n-th time derivative of real input variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\nnvr::Csize_t: Argument nvr defines the size of vr.\norder::AbstractArray{fmi2Integer}: Argument order is an AbstractArray of fmi2Integer values witch specifys the corresponding order of derivative of the real input variable.\nvalues::AbstractArray{fmi2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\nSee also fmi2SetRealInputDerivatives.\n\n\n\n\n\nfmi2SetRealInputDerivatives(c::FMU2Component, \n                                vr::AbstractArray{fmi2ValueReference}, \n                                order::AbstractArray{fmi2Integer}, \n                                values::AbstractArray{fmi2Real})\n\nSets the n-th time derivative of real input variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variables whose derivatives shall be set.\norder::AbstractArray{fmi2Integer}: Argument order is an AbstractArray of fmi2Integer values witch specifys the corresponding order of derivative of the real input variable.\nvalues::AbstractArray{fmi2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\nSee also fmi2SetRealInputDerivatives.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetRealOutputDerivatives!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetRealOutputDerivatives!","text":"Source: FMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\nRetrieves the n-th derivative of output values. vr defines the value references of the variables the array order specifies the corresponding order of derivation of the variables\n\n\n\n\n\nfmi2GetRealOutputDerivatives!(c::FMU2Component,  \n                                vr::AbstractArray{fmi2ValueReference}, \n                                nvr::Csize_t, order::AbstractArray{fmi2Integer}, \n                                value::AbstractArray{fmi2Real})\n\nSets the n-th time derivative of real input variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\nnvr::Csize_t: Argument nvr defines the size of vr.\norder::Array{fmi2Integer}: Argument order is an array of fmi2Integer values witch specifys the corresponding order of derivative of the real input variable.\nvalues::Array{fmi2Real}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2SampleJacobian fmi2SampleJacobian!","category":"page"},{"location":"fmi2_lowlevel_library_functions/#External/Additional-functions","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"External/Additional functions","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"setDiscreteStates\ngetDiscreteStates\ngetDiscreteStates!\ngetSimpleTypeAttributeStruct\ngetDeclaredType","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMIBase.setDiscreteStates","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.setDiscreteStates","text":"ToDo\n\n\n\n\n\nsetDiscreteStates(c::FMU2Component,\n                             x::Union{AbstractArray{Float32},AbstractArray{Float64}})\n\nSet a new (discrete) state vector and reinitialize chaching of variables that depend on states.\n\nArguments\n\n[ToDo]\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIBase.getDiscreteStates","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.getDiscreteStates","text":"getDiscreteStates(c)\n\nSets a new (discrete) state vector (out-of-place).\n\nArguments\n\nc::FMU2Component\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIBase.getDiscreteStates!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.getDiscreteStates!","text":"getDiscreteStates!(c, xd)\n\nSets a new (discrete) state vector (in-place).\n\nArguments\n\nc::FMU2Component\nxd::AbstractArray{Union{fmi2Real, fmi2Integer, fmi2Boolean}}\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIBase.getSimpleTypeAttributeStruct","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.getSimpleTypeAttributeStruct","text":"getSimpleTypeAttributeStruct(st::fmi2SimpleType)\n\nReturns the attribute structure for the simple type st. Depending on definition, this is either st.Real, st.Integer, st.String, st.Boolean or st.Enumeration.\n\nArguments\n\nst::fmi2SimpleType: Struct which provides the information on custom SimpleTypes.\n\nSource\n\nFMISpec2.0.3 Link: https://fmi-standard.org/\nFMISpec2.0.3[p.40]: 2.2.3 Definition of Types (TypeDefinitions)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIBase.getDeclaredType","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.getDeclaredType","text":"getDeclaredType(md::fmi2ModelDescription, mv::fmi2ScalarVariable)\n\nReturns the fmi2SimpleType of the corresponding model variable mv as defined in md.typeDefinitions. If mv does not have a declared type, return nothing. If mv has a declared type, but it is not found, issue a warning and return nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\nmv::fmi2ScalarVariable: The ‚ÄúModelVariables‚Äù element consists of an ordered set of ‚ÄúScalarVariable‚Äù elements. A ‚ÄúScalarVariable‚Äù represents a variable of primitive type, like a real or integer variable.\n\nSource\n\nFMISpec2.0.3 Link: https://fmi-standard.org/\nFMISpec2.0.3: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2GetSolutionDerivative fmi2GetSolutionState fmi2GetSolutionValue fmi2GetSolutionTime fmi2GetJacobian fmi2GetJacobian! fmi2GetFullJacobian fmi2GetFullJacobian!","category":"page"},{"location":"fmi3_lowlevel_CS_functions/#FMI-for-Co-Simulation","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"","category":"section"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"This chapter defines the Functional Mock-up Interface (FMI) for the coupling of two or more simulation models in a Co-Simulation environment (FMI for Co-Simulation). Co-Simulation is a rather general approach to the simulation of coupled technical systems and coupled physical phenomena in engineering with focus on instationary (time-dependent) problems.","category":"page"},{"location":"fmi3_lowlevel_CS_functions/#Transfer-of-Input-/-Output-Values-and-Parameters","page":"FMI for Co-Simulation","title":"Transfer of Input / Output Values and Parameters","text":"","category":"section"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"In order to enable the slave to interpolate the continuous real inputs between communication steps, the derivatives of the inputs with respect to time can be provided. Also, higher derivatives can be set to allow higher order interpolation.","category":"page"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"","category":"page"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"fmi3CallbackIntermediateUpdate","category":"page"},{"location":"fmi3_lowlevel_CS_functions/#Computation","page":"FMI for Co-Simulation","title":"Computation","text":"","category":"section"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"The computation of time steps is controlled by the following function.","category":"page"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"fmi3EnterStepMode\nfmi3DoStep!","category":"page"},{"location":"fmi3_lowlevel_CS_functions/#FMICore.fmi3EnterStepMode","page":"FMI for Co-Simulation","title":"FMICore.fmi3EnterStepMode","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.5. State: Event Mode\n\nThis function must be called to change from Event Mode into Step Mode in Co-Simulation (see 4.2.).\n\n\n\n\n\nfmi3EnterStepMode(c::FMU3Instance; soft::Bool=false)\n\nThis function must be called to change from Event Mode into Step Mode in Co-Simulation (see 4.2.).\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state  fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.5. State: Event Mode\n\nSee also fmi3EnterStepMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_CS_functions/#FMICore.fmi3DoStep!","page":"FMI for Co-Simulation","title":"FMICore.fmi3DoStep!","text":"Source: FMISpec3.0, Version D5ef1c1: 4.2.1. State: Step Mode\n\nThe computation of a time step is started.\n\n\n\n\n\nfmi3DoStep!(c::FMU3Instance, currentCommunicationPoint::fmi3Float64, communicationStepSize::fmi3Float64, noSetFMUStatePriorToCurrentPoint::fmi3Boolean,\n                eventEncountered::Ref{fmi3Boolean}, terminateSimulation::Ref{fmi3Boolean}, earlyReturn::Ref{fmi3Boolean}, lastSuccessfulTime::Ref{fmi3Float64})\n\nThe computation of a time step is started.\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\ncurrentCommunicationPoint::fmi3Float64:  \ncommunicationStepSize::fmi3Float64: \nnoSetFMUStatePriorToCurrentPoint::fmi3Boolean: \neventEncountered::Ref{fmi3Boolean}: \nterminateSimulation::Ref{fmi3Boolean}: \nearlyReturn::Ref{fmi3Boolean}: \nlastSuccessfulTime::Ref{fmi3Float64}: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 4.2.1. State: Step Mode\n\nSee also fmi3DoStep!.\n\n\n\n\n\nfmi3DoStep!(c::FMU3Instance, currentCommunicationPoint::Union{Real, Nothing} = nothing, communicationStepSize::Union{Real, Nothing} = nothing, noSetFMUStatePriorToCurrentPoint::Bool = true,\n    eventEncountered::fmi3Boolean = fmi3False, terminateSimulation::fmi3Boolean = fmi3False, earlyReturn::fmi3Boolean = fmi3False, lastSuccessfulTime::fmi3Float64 = 0.0)\n\nThe computation of a time step is started.\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\ncurrentCommunicationPoint::Union{Real, Nothing} = nothing\ncommunicationStepSize::Union{Real, Nothing} = nothing\nnoSetFMUStatePriorToCurrentPoint::Bool = true\neventEncountered::fmi3Boolean = fmi3False\nterminateSimulation::fmi3Boolean = fmi3False\nearlyReturn::fmi3Boolean = fmi3False\nlastSuccessfulTime::fmi3Float64 = 0.0\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 4.2.1. State: Step Mode\n\nSee also fmi3DoStep!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_CS_functions/#Retrieving-Status-Information-from-the-Slave","page":"FMI for Co-Simulation","title":"Retrieving Status Information from the Slave","text":"","category":"section"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"Status information is retrieved from the slave by the following functions:","category":"page"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"","category":"page"},{"location":"fmi_lowlevel_library_functions/#Functions-in-FMI-Import/Core-.jl","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi_lowlevel_library_functions/","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"logInfo\nlogWarning\nlogError","category":"page"},{"location":"fmi_lowlevel_library_functions/#FMIBase.logInfo","page":"Functions in FMI Import/Core .jl","title":"FMIBase.logInfo","text":"Prints a message with level info if the log level allows it.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.logWarning","page":"Functions in FMI Import/Core .jl","title":"FMIBase.logWarning","text":"Prints a message with level warn if the log level allows it.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.logError","page":"Functions in FMI Import/Core .jl","title":"FMIBase.logError","text":"Prints a message with level error if the log level allows it.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"loadBinary eval!","category":"page"},{"location":"fmi_lowlevel_library_functions/#Conversion-functions","page":"Functions in FMI Import/Core .jl","title":"Conversion functions","text":"","category":"section"},{"location":"fmi_lowlevel_library_functions/","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"stringToStatus\nstatusToString\nstringToDependencyKind\ndependencyKindToString\nvalueReferenceToString\nstringToInitial\ninitialToString\nstringToIntervalQualifier\nstringToDataType\nstringToCausality\ncausalityToString\nstringToVariability\nvariabilityToString","category":"page"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToStatus","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToStatus","text":"stringToStatus(s)\n\nConverts a String s to fmi2Status.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.statusToString","page":"Functions in FMI Import/Core .jl","title":"FMIBase.statusToString","text":"statusToString(::struct, status::Union{fmi2Status, Integer})\n\nConverts fmi2Status status into a String (\"OK\", \"Warning\", \"Discard\", \"Error\", \"Fatal\", \"Pending\").\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToDependencyKind","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToDependencyKind","text":"stringToDependencyKind(s::AbstractString)\n\nConverts s (\"dependent\", \"constant\", \"fixed\", \"tunable\", \"discrete\") to the corresponding fmi2DependencyKind\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.dependencyKindToString","page":"Functions in FMI Import/Core .jl","title":"FMIBase.dependencyKindToString","text":"dependencyKindToString(c::fmi2DependencyKind)\n\nConverts fmi2DependencyKind c to the corresponding String (\"dependent\", \"constant\", \"fixed\", \"tunable\", \"discrete\")\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.valueReferenceToString","page":"Functions in FMI Import/Core .jl","title":"FMIBase.valueReferenceToString","text":"valueReferenceToString(obj, reference)\n\nwhere: \n\nobj ‚àà (fmi2ModelDescription, fmi3ModelDescription, FMU2, FMU3) reference ‚àà (fmi2ValueReference, fmi3ValueReference, Integer\n\nReturns the string identifier for a give value reference.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToInitial","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToInitial","text":"stringToInitial(s::AbstractString)\n\nConverts s (\"approx\", \"exact\", \"calculated\") to the corresponding fmi2Initial.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.initialToString","page":"Functions in FMI Import/Core .jl","title":"FMIBase.initialToString","text":"fmi2InitialToString(c::fmi2Initial)\n\nConverts fmi2Initial c to the corresponding String (\"approx\", \"exact\", \"calculated\").\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToIntervalQualifier","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToIntervalQualifier","text":"stringToIntervalQualifier(::FMI3Struct, s::AbstractString)\n\nConvert s (\"intervalNotYetKnown\", \"intervalUnchanged\", \"intervalChanged\") to the corresponding fmi3IntervalQualifier.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToDataType","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToDataType","text":"stringToDataType(modelDescription, typename)\n\nConverts a typename to type, for example \"Float64\" (::String) to fmi3Float64 (::DataType).\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToCausality","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToCausality","text":"stringToCausality(s::AbstractString)\n\nConverts s (\"parameter\", \"calculatedParameter\", \"input\", \"output\", \"local\", \"independent\") to the corresponding fmi2Causality.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.causalityToString","page":"Functions in FMI Import/Core .jl","title":"FMIBase.causalityToString","text":"causalityToString(c::fmi2Causality)\n\nConverts fmi2Causality c to the corresponding String (\"parameter\", \"calculatedParameter\", \"input\", \"output\", \"local\", \"independent\").\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToVariability","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToVariability","text":"stringToVariability(s::AbstractString)\n\nConverts s (\"constant\", \"fixed\", \"tunable\", \"discrete\", \"continuous\") to the corresponding fmi2Variability.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.variabilityToString","page":"Functions in FMI Import/Core .jl","title":"FMIBase.variabilityToString","text":"variabilityToString(c::fmi2Variability)\n\nConverts fmi2Variability c to the corresponding String (\"constant\", \"fixed\", \"tunable\", \"discrete\", \"continuous\").\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"fmi2StringToInitial","category":"page"},{"location":"fmi_lowlevel_library_functions/#External/Additional-functions","page":"Functions in FMI Import/Core .jl","title":"External/Additional functions","text":"","category":"section"},{"location":"fmi_lowlevel_library_functions/","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"getInitial\ngetStartValue\nhasCurrentInstance\ngetCurrentInstance\nmodelVariablesForValueReference\nsetValue\ngetValue\ngetValue!\ngetUnit","category":"page"},{"location":"fmi_lowlevel_library_functions/#FMIBase.getInitial","page":"Functions in FMI Import/Core .jl","title":"FMIBase.getInitial","text":"getInitial(mv::fmi2ScalarVariable)\n\nReturns the inital entry of the corresponding model variable.\n\nArguments\n\nfmi2GetStartValue(mv::fmi2ScalarVariable): The ‚ÄúModelVariables‚Äù element consists of an ordered set of ‚ÄúScalarVariable‚Äù elements. A ‚ÄúScalarVariable‚Äù represents a variable of primitive type, like a real or integer variable.\n\nReturns\n\nmv.Real.unit: Returns the inital entry of the corresponding ScalarVariable representing a variable of the primitive type Real. Otherwise nothing is returned.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.getStartValue","page":"Functions in FMI Import/Core .jl","title":"FMIBase.getStartValue","text":"getStartValue(md::fmi2ModelDescription, vrs::fmi2ValueReferenceFormat = md.valueReferences)\n\nReturns the start/default value for a given value reference.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\nvrs::fmi2ValueReferenceFormat = md.valueReferences: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nstarts::Array{fmi2ValueReferenceFormat}: start/default value for a given value reference\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.hasCurrentInstance","page":"Functions in FMI Import/Core .jl","title":"FMIBase.hasCurrentInstance","text":"ToDo: Doc String\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.getCurrentInstance","page":"Functions in FMI Import/Core .jl","title":"FMIBase.getCurrentInstance","text":"ToDo: Doc String\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.modelVariablesForValueReference","page":"Functions in FMI Import/Core .jl","title":"FMIBase.modelVariablesForValueReference","text":"modelVariablesForValueReference(obj, vr)\n\nwhere:\n\nobj ‚àà (fmi2ModelDescription, fmi3ModelDescription, FMU2, FMU3) vr ‚àà (fmi2ValueReference, fmi3ValueReference)\n\nReturns the model variable(s) matching the value reference.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.setValue","page":"Functions in FMI Import/Core .jl","title":"FMIBase.setValue","text":"setValue(component,\n            vrs::fmi2ValueReferenceFormat,\n            srcArray::AbstractArray;\n            filter=nothing)\n\nStores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference and returns an array that indicates the Status.\n\nArguments\n\ncomp::FMUInstance (FMU2Component or FMU3Instance): Mutable struct represents an instantiated instance of an FMU in the FMI 2 or 3.\nvrs::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\nsrcArray::AbstractArray: Stores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference to the input variable vr (vr = vrs[i]). srcArray has the same length as vrs.\n\nKeywords\n\nfilter=nothing: It is applied to each ModelVariable to determine if it should be updated.\n\nReturns\n\nretcodes::Array{fmi2Status}: Returns an array of length length(vrs) with Type fmi2Status. Type fmi2Status is an enumeration and indicates the success of the function call.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.getValue","page":"Functions in FMI Import/Core .jl","title":"FMIBase.getValue","text":"getValue(comp::FMU2Component, vrs::fmi2ValueReferenceFormat)\n\nReturns the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference in an array.\n\nArguments\n\ncomp::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvrs::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\ndstArray::Array{Any,1}(undef, length(vrs)): Stores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference to the input variable vr (vr = vrs[i]). dstArray is a 1-Dimensional Array that has the same length as vrs.\n\n\n\n\n\ngetValue(solution::FMUSolution, vr::fmi2ValueReferenceFormat; isIndex::Bool=false)\n\nReturns the Solution values.\n\nArguments\n\nsolution::FMUSolution: Struct contains information about the solution value, success, state and  events of a specific FMU.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nisIndex::Bool=false: Argument isIndex exists to check if vr ist the specific solution element (\"index\") that equals the given fmi2ValueReferenceFormat\n\nReturn\n\nIf he length of the given references equals 1, each element u in the collection solution.values.saveval is selecting the element at the index represented by indices[1] and returns it.\n\nThus, the collect() function is taking the generator expression and returning an array of the selected elements. \n\nIf more than one reference is given, the same process takes place as before. The difference is that now more than one index is accessed.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.getValue!","page":"Functions in FMI Import/Core .jl","title":"FMIBase.getValue!","text":"getValue!(comp::FMU2Component, vrs::fmi2ValueReferenceFormat, dst::AbstractArray)\n\nRetrieves values for the refernces vrs and stores them in dst\n\nArguments\n\ncomp::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvrs::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\ndst::AbstractArray: The array of destinations, must match the data types of the value references.\n\nReturns\n\nretcodes::Array{fmi2Status}: Returns an array of length length(vrs) with Type fmi2Status. Type fmi2Status is an enumeration and indicates the success of the function call.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.getUnit","page":"Functions in FMI Import/Core .jl","title":"FMIBase.getUnit","text":"getUnit(mv::fmi2ScalarVariable)\n\nReturns the unit entry (a string) of the corresponding model variable.\n\nArguments\n\nfmi2GetStartValue(mv::fmi2ScalarVariable): The ‚ÄúModelVariables‚Äù element consists of an ordered set of ‚ÄúScalarVariable‚Äù elements. A ‚ÄúScalarVariable‚Äù represents a variable of primitive type, like a real or integer variable.\n\nReturns\n\nmv.Real.unit: Returns the unit entry of the corresponding ScalarVariable representing a variable of the primitive type Real. Otherwise nothing is returned.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"fmi2GetSolutionDerivative fmi2GetSolutionState fmi2GetSolutionValue fmi2GetSolutionTime fmi2GetJacobian fmi2GetJacobian! fmi2GetFullJacobian fmi2GetFullJacobian!","category":"page"},{"location":"index_library/#All-library-elements-of-FMI,-Import,-Export,-Core-and-Build","page":"API Index","title":"All library elements of FMI, Import, Export, Core and Build","text":"","category":"section"},{"location":"index_library/","page":"API Index","title":"API Index","text":"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: FMI.jl Logo)","category":"page"},{"location":"#FMI.jl","page":"Introduction","title":"FMI.jl","text":"","category":"section"},{"location":"#What-is-FMI.jl?","page":"Introduction","title":"What is FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI.jl is a free-to-use software library for the Julia programming language which integrates the Functional Mock-Up Interface (fmi-standard.org): load or create, parameterize, differentiate, linearize, simulate and plot FMUs seamlessly inside the Julia programming language!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":" \nDocumentation (Image: Build Docs) (Image: Dev Docs)\nExamples (Image: Examples (latest))\nTests (Image: Test (latest)) (Image: Test (LTS)) (Image: Aqua QA)\nFMI cross checks (Image: FMI2 Cross Checks)\nPackage evaluation (Image: Run PkgEval)\nCode coverage (Image: Coverage)\nCollaboration (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)\nFormatting (Image: SciML Code Style)","category":"page"},{"location":"#Breaking-Changes-in-FMI.jl-(starting-from-v0.14.0-until-release-of-v1.0.0)","page":"Introduction","title":"Breaking Changes in FMI.jl (starting from v0.14.0 until release of v1.0.0)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you want to migrate your project from FMI.jl < v1.0.0 to >= v1.0.0, you will face some breaking changes - but they are worth it as you will see! We decided to do multiple smaller breaking changes starting with v0.14.0, instead of one big one. Some of them are already implemented (checked), some are still on the todo (unchecked) but will be implemented before releasing v1.0.0.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[x] Many functions, that are not part of the FMI-standard, had the prefix fmi2... or fmi3.... This was corrected. Now, only functions that are defined by the standard itself, like e.g. fmi2Instantiate are allowed to keep the prefix. Other methods, like fmi2ValueReferenceToString, that where added to make this library more comfortable, are now cleaned to be more the Julia way: valueReferenceToString. If your code errors, the corresponding function might have lost it's prefix, so try this first.\n[x] Wrapper functions where removed, because that is not the Julia way. In most cases, this will not affect your code.\n[x] FMICore.jl and FMIImport.jl were divided into FMICore.jl, FMIImport.jl and FMIBase.jl. FMICore.jl now holds the pure standard definition (C-types and -functions), while FMIBase.jl holds everything that is needed on top of that in FMIImport.jl as well as in FMIExport.jl.\n[ ] Updated all library examples.\n[ ] Updated all library tests for a better code coverage.\n[ ] We tried to document every function, if you find undocumented user-level functions, please open an issue or PR.\n[ ] Allocations, type stability and code format where optimized and are monitored by CI now.\n[ ] Dependencies are reduced a little, to make the libraries more light-weight.\n[ ] RAM for allocated FMUs, their instances and states, is now auto-released. For maximum performance/safety you can use FMUs in blocks (like file reading/writing).\n[ ] New low-level interfaces are introduced, that fit the SciML-ecosystem. For example, a FMU can still be simulated with simulate(fmu), but one can also decide to create a prob = FMUProblem(fmu) (like an ODEProblem) and use solve(prob) to obtain a solution. Keywords will be adapted to have a fully consistent interface with the remaining SciML-ecosystem.\n[ ] Optimization for new Julia LTS v1.10, removing code to keep downward compatibility with old LTS v1.6.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"üéâ After all listed features are implemented, v1.0.0 will be released! üéâ ","category":"page"},{"location":"#How-can-I-use-FMI.jl?","page":"Introduction","title":"How can I use FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"1. Open a Julia-REPL, switch to package mode using ], activate your preferred environment.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"2. Install FMI.jl:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(@v1) pkg> add FMI","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"3. If you want to check that everything works correctly, you can run the tests bundled with FMI.jl:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(@v1) pkg> test FMI","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"4. Have a look inside the examples folder in the examples branch or the examples section of the documentation. All examples are available as Julia-Script (.jl), Jupyter-Notebook (.ipynb) and Markdown (.md).","category":"page"},{"location":"#How-can-I-simulate-a-FMU-and-plot-values?","page":"Introduction","title":"How can I simulate a FMU and plot values?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using FMI, Plots\n\n# load and instantiate a FMU\nfmu = loadFMU(pathToFMU) \n\n# simulate from t=0.0s until t=10.0s and record the FMU variable named \"mass.s\"\nsimData = simulate(fmu, (0.0, 10.0); recordValues=[\"mass.s\"])\n\n# plot it!\nplot(simData)\n\n# free memory\nunloadFMU(myFMU)","category":"page"},{"location":"#What-is-currently-supported-in-FMI.jl?","page":"Introduction","title":"What is currently supported in FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"importing the full FMI 2.0.3 and FMI 3.0.0 command set, including optional specials like fmi2GetFMUstate, fmi2SetFMUstate and fmi2GetDirectionalDerivatives\nparameterization, simulation & plotting of CS- and ME-FMUs\nevent-handling for imported discontinuous ME-FMUs","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":" FMI2.0.3  FMI3.0  SSP1.0 \n Import Export Import Export Import Export\nCS ‚úîÔ∏è‚úîÔ∏è üöß ‚úîÔ∏è‚úîÔ∏è üìÖ üìÖ üìÖ\nME (continuous) ‚úîÔ∏è‚úîÔ∏è ‚úîÔ∏è‚úîÔ∏è ‚úîÔ∏è‚úîÔ∏è üìÖ üìÖ üìÖ\nME (discontinuous) ‚úîÔ∏è‚úîÔ∏è ‚úîÔ∏è‚úîÔ∏è ‚úîÔ∏è‚úîÔ∏è üìÖ üìÖ üìÖ\nSE üö´ üö´ üöß üìÖ üö´ üö´\nExplicit solvers ‚úîÔ∏è‚úîÔ∏è ‚úîÔ∏è‚úîÔ∏è ‚úîÔ∏è‚úîÔ∏è üìÖ üìÖ üìÖ\nImplicit solvers (autodiff=false) ‚úîÔ∏è‚úîÔ∏è ‚úîÔ∏è‚úîÔ∏è ‚úîÔ∏è‚úîÔ∏è üìÖ üìÖ üìÖ\nImplicit solvers (autodiff=true) ‚úîÔ∏è ‚úîÔ∏è‚úîÔ∏è ‚úîÔ∏è üìÖ üìÖ üìÖ\nget/setFMUstate ‚úîÔ∏è‚úîÔ∏è üìÖ ‚úîÔ∏è‚úîÔ∏è üìÖ üö´ üö´\ngetDirectionalDerivatives ‚úîÔ∏è‚úîÔ∏è üìÖ ‚úîÔ∏è‚úîÔ∏è üìÖ üö´ üö´\ngetAdjointDerivatives üö´ üö´ ‚úîÔ∏è‚úîÔ∏è üìÖ üö´ üö´\nFMI Cross Checks ‚úîÔ∏è‚úîÔ∏è üìÖ üìÖ üìÖ üö´ üö´\n64-bit binaries in FMUs ‚úîÔ∏è‚úîÔ∏è ‚úîÔ∏è‚úîÔ∏è ‚úîÔ∏è‚úîÔ∏è üìÖ üö´ üö´\n32-bit binaries in FMUs ‚úîÔ∏è üìÖ üìÖ üìÖ üö´ üö´","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"‚úîÔ∏è‚úîÔ∏è supported & CI-tested","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"‚úîÔ∏è  beta supported: implemented, but not CI-tested","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"üöß work in progress","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"üìÖ  planned","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"üö´  not supported by the corresponding FMI standard (not applicable)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"‚ùå  not planned","category":"page"},{"location":"#What-FMI.jl-Library-to-use?","page":"Introduction","title":"What FMI.jl-Library to use?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: FMI.jl Logo) To keep dependencies nice and clean, the original package FMI.jl had been split into new packages:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI.jl: High level loading, manipulating, saving or building entire FMUs from scratch\nFMIImport.jl: Importing FMUs into Julia\nFMIExport.jl: Exporting stand-alone FMUs from Julia Code\nFMIBase.jl: Common concepts for import and export of FMUs\nFMICore.jl: C-code wrapper for the FMI-standard\nFMISensitivity.jl: Static and dynamic sensitivities over FMUs\nFMIBuild.jl: Compiler/Compilation dependencies for FMIExport.jl\nFMIFlux.jl: Machine Learning with FMUs\nFMIZoo.jl: A collection of testing and example FMUs","category":"page"},{"location":"#What-Platforms-are-supported?","page":"Introduction","title":"What Platforms are supported?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI.jl is tested (and testing) under Julia Versions 1.6 LTS (64-bit) and latest (64-bit) on Windows latest (64-bit, 32-bit) and Ubuntu latest (64-bit). Mac (64-bit, 32-bit) and Ubuntu (32-bit) should work, but untested. For the best performance, we recommend using Julia >= 1.7, even if we support and test for the official LTS (1.6.7).","category":"page"},{"location":"#How-to-cite?","page":"Introduction","title":"How to cite?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Tobias Thummerer, Lars Mikelsons and Josef Kircher. 2021. NeuralFMU: towards structural integration of FMUs into neural networks. Martin Sj√∂lund, Lena Buffoni, Adrian Pop and Lennart Ochel (Ed.). Proceedings of 14th Modelica Conference 2021, Link√∂ping, Sweden, September 20-24, 2021. Link√∂ping University Electronic Press, Link√∂ping (Link√∂ping Electronic Conference Proceedings ; 181), 297-306. DOI: 10.3384/ecp21181297","category":"page"},{"location":"#Related-publications?","page":"Introduction","title":"Related publications?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Tobias Thummerer, Johannes Stoljar and Lars Mikelsons. 2022. NeuralFMU: presenting a workflow for integrating hybrid NeuralODEs into real-world applications. Electronics 11, 19, 3202. DOI: 10.3390/electronics11193202","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Tobias Thummerer, Johannes Tintenherr, Lars Mikelsons. 2021 Hybrid modeling of the human cardiovascular system using NeuralFMUs Journal of Physics: Conference Series 2090, 1, 012155. DOI: 10.1088/1742-6596/2090/1/012155","category":"page"},{"location":"#Notes-for-contributors","page":"Introduction","title":"Notes for contributors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Contributors are welcome. Before contributing, please read, understand and follow the Contributor's Guide on Collaborative Practices for Community Packages.  During development of new implementations or optimizations on existing code, one will have to make design decisions that influence the library performance and usability. The following prioritization should be the basis for decision-making:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"#1 Compliance with standard: It is the highest priority to be compliant with the FMI standard (fmi-standard.org). Identifiers described in the standard must be used. Topologies should follow the specification as far as the possibilities of the Julia programming language allows.\n#2 Performance: Because FMI.jl is a simulation tool, performance is very important. This applies to the efficient use of CPU and GPU, but also the conscientious use of RAM and disc space.\n#3 Usability: The library should be as usable as possible and feel \"the Julia way\" (e.g. by using multiple dispatch instead of the \"C coding style\"), as long as being fully compliant with the FMI standard.","category":"page"},{"location":"examples/modelica_conference_2021/#Example-from-the-Modelica-Conference-2021","page":"Modelica conference 2021","title":"Example from the Modelica Conference 2021","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Tutorial by Tobias Thummerer, Johannes Stoljar","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"This example was updated over time to keep track with developments and changes in FMI.jl.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"üöß This tutorial is under revision and will be replaced by an up-to-date version soon üöß","category":"page"},{"location":"examples/modelica_conference_2021/#License","page":"Modelica conference 2021","title":"License","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/modelica_conference_2021/#Introduction-to-the-example","page":"Modelica conference 2021","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"FMUs can be simulated in multiple ways using FMI.jl. You can use a very simple interface, that offers possibilities that satisfy almost any user requirement. However, if you need to build a custom simulation loop for your use case using the core FMI functions, we show that too.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"(Image: svg)  ","category":"page"},{"location":"examples/modelica_conference_2021/#Other-formats","page":"Modelica conference 2021","title":"Other formats","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/modelica_conference_2021/#Code-section","page":"Modelica conference 2021","title":"Code section","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots","category":"page"},{"location":"examples/modelica_conference_2021/#Simulation-setup","page":"Modelica conference 2021","title":"Simulation setup","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Next, the start time and end time of the simulation are set. Finally, a step size is specified to store the results of the simulation at these time steps.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"tStart = 0.0\ntStep = 0.1\ntStop = 8.0\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/modelica_conference_2021/#Simple-FMU-Simulation","page":"Modelica conference 2021","title":"Simple FMU Simulation","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Next, the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"# we use an FMU from the FMIZoo.jl\nfmu = fmiLoad(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\")\nfmiInfo(fmu)","category":"page"},{"location":"examples/modelica_conference_2021/#Easy-Simulation","page":"Modelica conference 2021","title":"Easy Simulation","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"In the next commands the FMU is simulated, for which the start and end time and recorded variables are declared. Afterwards the simulation result is plotted. In the plot for the FMU, it can be seen that the oscillation keeps decreasing due to the effect of friction. If one simulates long enough, the oscillation comes to a standstill after a certain time.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"simData = fmiSimulate(fmu, (tStart, tStop); recordValues=[\"mass.s\"], saveat=tSave)\nplot(simData)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"fmiUnload(fmu)","category":"page"},{"location":"examples/modelica_conference_2021/#Custom-Simulation","page":"Modelica conference 2021","title":"Custom Simulation","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"In the following type of simulation a more advanced variant is presented, which allows intervening more in the simulation process. Analogous to the simple variant, an FMU model must be loaded.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"fmu = fmiLoad(pathToFMU)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Next, it is necessary to create an instance of the FMU, this is achieved by the command fmi2Instantiate!().  ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"instanceFMU = fmi2Instantiate!(fmu)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"In the following code block, start and end time for the simulation is set by the fmi2SetupExperiment() command. Next, the FMU is initialized by the calls of fmi2EnterInitializationMode() and fmi2ExitInitializationMode(). It would also be possible to set initial states, parameters or inputs at this place in code.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"fmi2SetupExperiment(instanceFMU, tStart, tStop)\n# set initial model states\nfmi2EnterInitializationMode(instanceFMU)\n# get initial model states\nfmi2ExitInitializationMode(instanceFMU)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"The actual simulation loop is shown in the following block. Here a simulation step fmi2DoStep() with the fixed step size tStep is executed. As indicated in the code by the comments, the input values and output values of the FMU could be changed in the simulation loop as desired, whereby the higher possibility of adjustments arises.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"values = []\n\nfor t in tSave\n    # set model inputs if any\n    # ...\n\n    fmi2DoStep(instanceFMU, tStep)\n    \n    # get model outputs\n    value = fmi2GetReal(instanceFMU, \"mass.s\")\n    push!(values, value)\nend\n\nplot(tSave, values)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"The instantiated FMU must be terminated and then the memory area for the instance can also be deallocated. The last step is to unload the FMU to remove all unpacked data on disc. ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"fmi2Terminate(instanceFMU)\nfmi2FreeInstance!(instanceFMU)\nfmi2Unload(fmu)","category":"page"},{"location":"examples/modelica_conference_2021/#Summary","page":"Modelica conference 2021","title":"Summary","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"The tutorial has shown how to use the default simulation command and how to deploy a custom simulation loop.","category":"page"},{"location":"examples/parameterize/#Parameterize-a-FMU","page":"Parameterize","title":"Parameterize a FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Tutorial by Tobias Thummerer, Johannes Stoljar","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Last update: 09.08.2023","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"üöß This tutorial is under revision and will be replaced by an up-to-date version soon üöß","category":"page"},{"location":"examples/parameterize/#License","page":"Parameterize","title":"License","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/parameterize/#Introduction","page":"Parameterize","title":"Introduction","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"This example shows how to parameterize a FMU. We will show to possible ways to parameterize: The default option using the parameterization feature of fmiSimulate, fmiSimulateME or fmiSimulateCS. Second, a custom parameterization routine for advanced users. ","category":"page"},{"location":"examples/parameterize/#Other-formats","page":"Parameterize","title":"Other formats","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/parameterize/#Code-section","page":"Parameterize","title":"Code section","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"# imports\nusing FMI\nusing FMIZoo","category":"page"},{"location":"examples/parameterize/#Simulation-setup","page":"Parameterize","title":"Simulation setup","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Next, the start time and end time of the simulation are set.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"tStart = 0.0\ntStop = 1.0\ntSave = collect(tStart:tStop)","category":"page"},{"location":"examples/parameterize/#Import-FMU","page":"Parameterize","title":"Import FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"# we use an FMU from the FMIZoo.jl\n# just replace this line with a local path if you want to use your own FMU\npathToFMU = get_model_filename(\"IO\", \"Dymola\", \"2022x\")\n\nfmu = fmiLoad(pathToFMU)\nfmiInfo(fmu)","category":"page"},{"location":"examples/parameterize/#Option-A:-Integrated-parameterization-feature-of-*FMI.jl*","page":"Parameterize","title":"Option A: Integrated parameterization feature of FMI.jl","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"If you are using the commands for simulation integrated in FMI.jl, the parameters and initial conditions are set at the correct locations during the initialization process of your FMU. This is the recommended way of parameterizing your model, if you don't have very uncommon requirements regarding initialization.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"dict = Dict{String, Any}()\ndict","category":"page"},{"location":"examples/parameterize/#Option-B:-Custom-parameterization-routine","page":"Parameterize","title":"Option B: Custom parameterization routine","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"If you have special requirements for initialization and parameterization, you can write your very own parameterization routine.","category":"page"},{"location":"examples/parameterize/#Instantiate-and-Setup-FMU","page":"Parameterize","title":"Instantiate and Setup FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Next it is necessary to create an instance of the FMU. This is achieved by the command fmiInstantiate!().","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiInstantiate!(fmu; loggingOn=true)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the following code block, start and end time for the simulation is set by the fmiSetupExperiment() command.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiSetupExperiment(fmu, tStart, tStop)","category":"page"},{"location":"examples/parameterize/#Parameterize-FMU","page":"Parameterize","title":"Parameterize FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In this example, for each data type (real, boolean, integer and string) a corresponding input or parameter is selected. From here on, the inputs and parameters will be referred to as parameters for simplicity.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"params = [\"p_real\", \"p_boolean\", \"p_integer\", \"p_string\"]","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"At the beginning we want to display the initial state of these parameters, for which the FMU must be in initialization mode. The next function fmiEnterInitializationMode() informs the FMU to enter the initialization mode. Before calling this function, the variables can be set. Furthermore, fmiSetupExperiment() must be called at least once before calling fmiEnterInitializationMode(), in order that the start time is defined.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiEnterInitializationMode(fmu)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The initial state of these parameters are displayed with the function fmiGet().","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiGet(fmu, params)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The initialization mode is terminated with the function fmiExitInitializationMode(). (For the model exchange FMU type, this function switches off all initialization equations, and enters the event mode implicitly.)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiExitInitializationMode(fmu)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the next step, a function is defined that generates a random value for each parameter. For the parameter p_string a random number is inserted into the string. All parameters are combined to a tuple and output.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"function generateRandomNumbers()\n    rndReal = 100 * rand()\n    rndBoolean = rand() > 0.5\n    rndInteger = round(Integer, 100 * rand())\n    rndString = \"Random number $(100 * rand())!\"\n\n    return rndReal, rndBoolean, rndInteger, rndString\nend","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The previously defined function is called and the results are displayed in the console.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"paramsVal = generateRandomNumbers()","category":"page"},{"location":"examples/parameterize/#First-variant","page":"Parameterize","title":"First variant","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To show the first variant, it is necessary to terminate and reset the FMU instance. Then, as before, the setup command must be called for the FMU. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiTerminate(fmu)\nfmiReset(fmu)\nfmiSetupExperiment(fmu, tStart, tStop)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the next step it is possible to set the parameters for the FMU. With the first variant it is quickly possible to set all parameters at once. Even different data types can be set with only one command. The command fmiSet() selects itself which function is chosen for which data type.  As long as the output of the function gives the status code 0, setting the parameters has worked.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiSet(fmu, params, collect(paramsVal))","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"After setting the parameters, it can be checked whether the corresponding parameters were set correctly. For this the function fmiGet() can be used as above. To be able to call the function fmiGet() the FMU must be in initialization mode.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiEnterInitializationMode(fmu)\n# fmiGet(fmu, params)\nfmiExitInitializationMode(fmu)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Now the FMU has been initialized correctly, the FMU can be simulated. The fmiSimulate() command is used for this purpose. It must be pointed out that the keywords instantiate=false, setup=false must be set. The keyword instantiate=false prevents the simulation command from creating a new FMU instance, otherwise our parameterization will be lost. The keyword setup=false prevents the FMU from calling the initialization mode again. The additionally listed keyword freeInstance=false prevents that the instance is removed after the simulation. This is only needed in this example, because we want to continue working on the created instance. Another keyword is the recordValues=parmas[1:3], which saves: p_real, p_boolean and p_integer as output. It should be noted that the fmiSimulate() function is not capable of outputting string values, so p_string is omitted.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"simData = fmiSimulate(fmu, (tStart, tStop); recordValues=params[1:3], saveat=tSave, \n                        instantiate=false, setup=false, freeInstance=false, terminate=false, reset=false)","category":"page"},{"location":"examples/parameterize/#Second-variant","page":"Parameterize","title":"Second variant","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To show the second variant, it is necessary to terminate and reset the FMU instance. Then, as before, the setup command must be called for the FMU. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiTerminate(fmu)\nfmiReset(fmu)\nfmiSetupExperiment(fmu, tStart, tStop)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To make sure that the functions work it is necessary to generate random numbers again. As shown already, we call the defined function generateRandomNumbers() and output the values.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"rndReal, rndBoolean, rndInteger, rndString = generateRandomNumbers()","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the second variant, the value for each data type is set separately by the corresponding command. By this variant one has the maximum control and can be sure that also the correct data type is set. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiSetReal(fmu, \"p_real\", rndReal)\nfmiSetBoolean(fmu, \"p_boolean\", rndBoolean)\nfmiSetInteger(fmu, \"p_integer\", rndInteger)\nfmiSetString(fmu, \"p_string\", rndString)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To illustrate the functionality of the parameterization with the separate functions, the corresponding get function can be also called separately for each data type:","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiSetReal() &#8660; fmiGetReal()\nfmiSetBoolean() &#8660; fmiGetBoolean()\nfmiSetInteger() &#8660; fmiGetInteger()\nfmiSetString() &#8660; fmiGetString().","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"As before, the FMU must be in initialization mode.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiEnterInitializationMode(fmu)\n# fmiGetReal(fmu, \"u_real\")\n# fmiGetBoolean(fmu, \"u_boolean\")\n# fmiGetInteger(fmu, \"u_integer\")\n# fmiGetString(fmu, \"p_string\")\nfmiExitInitializationMode(fmu)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"From here on, you may want to simulate the FMU. Please note, that with the default executionConfig, it is necessary to prevent a new instantiation using the keyword instantiate=false. Otherwise, a new instance is allocated for the simulation-call and the parameters set for the previous instance are not transfered.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"simData = fmiSimulate(fmu, (tStart, tStop); recordValues=params[1:3], saveat=tSave, \n                        instantiate=false, setup=false)","category":"page"},{"location":"examples/parameterize/#Unload-FMU","page":"Parameterize","title":"Unload FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The FMU will be unloaded and all unpacked data on disc will be removed.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiUnload(fmu)","category":"page"},{"location":"examples/parameterize/#Summary","page":"Parameterize","title":"Summary","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Based on this tutorial it can be seen that there are two different variants to set and get parameters.These examples should make it clear to the user how parameters can also be set with different data types. As a small reminder, the sequence of commands for the manual parameterization of an FMU is summarized again. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiLoad() &#8594; fmiInstantiate!() &#8594; fmiSetupExperiment() &#8594; fmiSetXXX() &#8594; fmiEnterInitializationMode() &#8594; fmiGetXXX() &#8594; fmiExitInitializationMode() &#8594; fmiSimualte() &#8594; fmiUnload()","category":"page"}]
}
