var documenterSearchIndex = {"docs":
[{"location":"examples/multiprocessing/#Multiprocessing","page":"Multiprocessing","title":"Multiprocessing","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Tutorial by Jonas Wilfert, Tobias Thummerer","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"🚧 This tutorial is under revision and will be replaced by an up-to-date version soon 🚧","category":"page"},{"location":"examples/multiprocessing/#License","page":"Multiprocessing","title":"License","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar, Jonas Wilfert\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/multiprocessing/#Motivation","page":"Multiprocessing","title":"Motivation","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/multiprocessing/#Introduction-to-the-example","page":"Multiprocessing","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"This example shows how to parallelize the computation of an FMU in FMI.jl. We can compute a batch of FMU-evaluations in parallel with different initial settings. Parallelization can be achieved using multithreading or using multiprocessing. This example shows multiprocessing, check multithreading.ipynb for multithreading. Advantage of multithreading is a lower communication overhead as well as lower RAM usage. However in some cases multiprocessing can be faster as the garbage collector is not shared.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"The model used is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"(Image: svg)  ","category":"page"},{"location":"examples/multiprocessing/#Target-group","page":"Multiprocessing","title":"Target group","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/multiprocessing/#Other-formats","page":"Multiprocessing","title":"Other formats","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/multiprocessing/#Getting-started","page":"Multiprocessing","title":"Getting started","text":"","category":"section"},{"location":"examples/multiprocessing/#Installation-prerequisites","page":"Multiprocessing","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install FMICore via add FMICore add \" https://github.com/ThummeTo/FMICore.jl \"\n5. Install BenchmarkTools via add BenchmarkTools ","category":"page"},{"location":"examples/multiprocessing/#Code-section","page":"Multiprocessing","title":"Code section","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Adding your desired amount of processes:","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"using Distributed\nn_procs = 2\naddprocs(n_procs; exeflags=`--project=$(Base.active_project()) --threads=auto`, restrict=false)","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"2-element Vector{Int64}:\n 2\n 3","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"# imports\n@everywhere using FMI\n@everywhere using FMIZoo\n@everywhere using DifferentialEquations\n@everywhere using BenchmarkTools","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Checking that we workers have been correctly initialized:","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"workers()\n\n@everywhere println(\"Hello World!\")\n\n# The following lines can be uncommented for more advanced information about the subprocesses\n# @everywhere println(pwd())\n# @everywhere println(Base.active_project())\n# @everywhere println(gethostname())\n# @everywhere println(VERSION)\n# @everywhere println(Threads.nthreads())","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Hello World!\n\n\n      From worker 2:\tHello World!\n      From worker 3:\tHello World!","category":"page"},{"location":"examples/multiprocessing/#Simulation-setup","page":"Multiprocessing","title":"Simulation setup","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Next, the batch size and input values are defined.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"\n# Best if batchSize is a multiple of the threads/cores\nbatchSize = 16\n\n# Define an array of arrays randomly\ninput_values = collect(collect.(eachrow(rand(batchSize,2))))","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"16-element Vector{Vector{Float64}}:\n [0.9443174571759404, 0.65572342086848]\n [0.1137656078625836, 0.8773645291743096]\n [0.8037422338497207, 0.8445906086536761]\n [0.6575672292351882, 0.8502764869896652]\n [0.5487683237951159, 0.7597397472027577]\n [0.05013797465397163, 0.6089394067854427]\n [0.9573133407108624, 0.5150582674660105]\n [0.4455347277593501, 0.38595718407874446]\n [0.7097412195258421, 0.7891440618785742]\n [0.2785402656261162, 0.6786539748813666]\n [0.4405297225225221, 0.8892797655158791]\n [0.9767362460412371, 0.5291542416500202]\n [0.6525313577725259, 0.7405022701096706]\n [0.418407135333282, 0.1217930884849312]\n [0.32962258851375104, 0.702560871139169]\n [0.4105223903537458, 0.2709957526553505]","category":"page"},{"location":"examples/multiprocessing/#Shared-Module","page":"Multiprocessing","title":"Shared Module","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"For Distributed we need to embed the FMU into its own module. This prevents Distributed from trying to serialize and send the FMU over the network, as this can cause issues. This module needs to be made available on all processes using @everywhere.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@everywhere module SharedModule\n    using FMIZoo\n    using FMI\n\n    t_start = 0.0\n    t_step = 0.1\n    t_stop = 10.0\n    tspan = (t_start, t_stop)\n    tData = collect(t_start:t_step:t_stop)\n\n    model_fmu = loadFMU(\"SpringPendulum1D\", \"Dymola\", \"2022x\"; type=:ME)\nend","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"We define a helper function to calculate the FMU and combine it into an Matrix.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@everywhere function runCalcFormatted(fmu, x0, recordValues=[\"mass.s\", \"mass.v\"])\n    data = simulateME(fmu, SharedModule.tspan; recordValues=recordValues, saveat=SharedModule.tData, x0=x0, showProgress=false, dtmax=1e-4)\n    return reduce(hcat, data.states.u)\nend","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Running a single evaluation is pretty quick, therefore the speed can be better tested with BenchmarkTools.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@benchmark data = runCalcFormatted(SharedModule.model_fmu, rand(2))","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"BenchmarkTools.Trial: 2 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m3.103 s\u001b[22m\u001b[39m … \u001b[35m   3.432 s\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m0.72% … 7.38%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m3.267 s               \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m4.22%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m3.267 s\u001b[22m\u001b[39m ± \u001b[32m232.780 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m4.22% ± 4.71%\n\n  \u001b[34m█\u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \n  \u001b[34m█\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[32m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m \u001b[39m▁\n  3.1 s\u001b[90m          Histogram: frequency by time\u001b[39m         3.43 s \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m300.76 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m7603698\u001b[39m.","category":"page"},{"location":"examples/multiprocessing/#Single-Threaded-Batch-Execution","page":"Multiprocessing","title":"Single Threaded Batch Execution","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"To compute a batch we can collect multiple evaluations. In a single threaded context we can use the same FMU for every call.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"println(\"Single Threaded\")\n@benchmark collect(runCalcFormatted(SharedModule.model_fmu, i) for i in input_values)","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Single Threaded\n\n\n\n\n\n\n\nBenchmarkTools.Trial: 1 sample with 1 evaluation.\n Single result which took \u001b[34m49.859 s\u001b[39m (0.87% GC) to evaluate,\n with a memory estimate of \u001b[33m4.70 GiB\u001b[39m, over \u001b[33m121659156\u001b[39m allocations.","category":"page"},{"location":"examples/multiprocessing/#Multithreaded-Batch-Execution","page":"Multiprocessing","title":"Multithreaded Batch Execution","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"In a multithreaded context we have to provide each thread it's own fmu, as they are not thread safe. To spread the execution of a function to multiple processes, the function pmap can be used.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"println(\"Multi Threaded\")\n@benchmark pmap(i -> runCalcFormatted(SharedModule.model_fmu, i), input_values)","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Multi Threaded\n\n\n\n\n\nBenchmarkTools.Trial: 1 sample with 1 evaluation.\n Single result which took \u001b[34m29.316 s\u001b[39m (0.00% GC) to evaluate,\n with a memory estimate of \u001b[33m99.25 KiB\u001b[39m, over \u001b[33m1583\u001b[39m allocations.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"As you can see, there is a significant speed-up in the median execution time. But: The speed-up is often much smaller than n_procs (or the number of physical cores of your CPU), this has different reasons. For a rule of thumb, the speed-up should be around n/2 on a n-core-processor with n Julia processes.","category":"page"},{"location":"examples/multiprocessing/#Unload-FMU","page":"Multiprocessing","title":"Unload FMU","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"After calculating the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@everywhere unloadFMU(SharedModule.model_fmu)","category":"page"},{"location":"examples/multiprocessing/#Summary","page":"Multiprocessing","title":"Summary","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"In this tutorial it is shown how multi processing with Distributed.jl can be used to improve the performance for calculating a Batch of FMUs.","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#Working-with-the-FMI-model-description","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"The FMI model description provides all human readable information on the model. The following functions can be used to obtain all information provided by the model description, which in turn can be extracted from the fmu.","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#Loading/Parsing","page":"Working with the FMI model description","title":"Loading/Parsing","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2LoadModelDescription","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#general-information-about-the-FMU","page":"Working with the FMI model description","title":"general information about the FMU","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2GetGenerationTool fmi2GetGenerationDateAndTime","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#technical-information-about-the-FMU","page":"Working with the FMI model description","title":"technical information about the FMU","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2GetVersion\nfmi2GetTypesPlatform\n","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMICore.fmi2GetVersion","page":"Working with the FMI model description","title":"FMICore.fmi2GetVersion","text":"Source: FMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\n\nReturns the version of the “fmi2Functions.h” header file which was used to compile the functions of the FMU. The function returns “fmiVersion” which is defined in this header file. The standard header file as documented in this specification has version “2.0”\n\n\n\n\n\nfmi2GetVersion(fmu::FMU2)\n\nReturns the version of the “fmi2Functions.h” header file which was used to compile the functions of the FMU.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns a string from the address of a C-style (NUL-terminated) string. The string represents the version of the “fmi2Functions.h” header file which was used to compile the functions of the FMU. The function returns “fmiVersion” which is defined in this header file. The standard header file as documented in this specification has version “2.0”\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMICore.fmi2GetTypesPlatform","page":"Working with the FMI model description","title":"FMICore.fmi2GetTypesPlatform","text":"Source: FMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\n\nReturns the string to uniquely identify the “fmi2TypesPlatform.h” header file used for compilation of the functions of the FMU. The standard header file, as documented in this specification, has fmi2TypesPlatform set to “default” (so this function usually returns “default”).\n\n\n\n\n\nfmi2GetTypesPlatform(fmu::FMU2)\n\nReturns the string to uniquely identify the “fmi2TypesPlatform.h” header file used for compilation of the functions of the FMU. The standard header file, as documented in this specification, has fmi2TypesPlatform set to “default” (so this function usually returns “default”).\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns the string to uniquely identify the “fmi2TypesPlatform.h” header file used for compilation of the functions of the FMU.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMU-capabilities","page":"Working with the FMI model description","title":"FMU capabilities","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"canGetSetFMUState\nisModelStructureAvailable\nisModelStructureDerivativesAvailable","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMIBase.canGetSetFMUState","page":"Working with the FMI model description","title":"FMIBase.canGetSetFMUState","text":"canGetSetFMUState(md::fmi2ModelDescription)\n\nReturns true, if the FMU supports the getting/setting of states\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU supports the getting/setting of states.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMIImport.isModelStructureAvailable","page":"Working with the FMI model description","title":"FMIImport.isModelStructureAvailable","text":"isModelStructureAvailable(md::fmi2ModelDescription)\n\nReturns true if the FMU model description contains dependency information.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU model description contains dependency information.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMIImport.isModelStructureDerivativesAvailable","page":"Working with the FMI model description","title":"FMIImport.isModelStructureDerivativesAvailable","text":"isModelStructureDerivativesAvailable(md::fmi2ModelDescription)\n\nReturns if the FMU model description contains dependency information for derivatives.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU model description contains dependency information for derivatives.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2DependenciesSupported fmi2DerivativeDependenciesSupported fmi2CanSerializeFMUstate fmi2ProvidesDirectionalDerivative","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#value-references","page":"Working with the FMI model description","title":"value references","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getModelVariableIndices","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#FMIBase.getModelVariableIndices","page":"Working with the FMI model description","title":"FMIBase.getModelVariableIndices","text":"getModelVariableIndices(md::fmi2ModelDescription; vrs=md.valueReferences)\n\nReturns a array of indices corresponding to value references vrs\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.valueReferences: Additional attribute valueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\n\nReturns\n\nnames::Array{Integer}: Returns a array of indices corresponding to value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2GetValueReferencesAndNames fmi2GetNames","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/#In-/Outputs","page":"Working with the FMI model description","title":"In-/Outputs","text":"","category":"section"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi2_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2GetOutputValueReferencesAndNames","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"Depth = 2","category":"page"},{"location":"fmi3_lowlevel_SE_functions/#FMI-for-Scheduled-Execution","page":"FMI for Scheduled Execution","title":"FMI for Scheduled Execution","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/#Working-with-the-FMI-model-description","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"The FMI model description provides all human readable information on the model. The following functions can be used to obtain all information provided by the model description, which in turn can be extracted from the fmu.","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#Loading/Parsing","page":"Working with the FMI model description","title":"Loading/Parsing","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2LoadModelDescription","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#general-information-about-the-FMU","page":"Working with the FMI model description","title":"general information about the FMU","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getGUID\ngetInstantiationToken\ngetGenerationDateAndTime\ngetGenerationTool","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIImport.getGUID","page":"Working with the FMI model description","title":"FMIImport.getGUID","text":"getGUID(md::fmi2ModelDescription)\n\nReturns the tag 'guid' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nguid::String: Returns the tag 'guid' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getInstantiationToken","page":"Working with the FMI model description","title":"FMIBase.getInstantiationToken","text":"Returns the tag 'instantionToken' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getGenerationDateAndTime","page":"Working with the FMI model description","title":"FMIBase.getGenerationDateAndTime","text":"getGenerationDateAndTime(md::fmi2ModelDescription)\n\nReturns the tag 'generationdateandtime' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.generationDateAndTime::DateTime: Returns the tag 'generationdateandtime' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getGenerationTool","page":"Working with the FMI model description","title":"FMIBase.getGenerationTool","text":"getGenerationTool(md::fmi2ModelDescription)\n\nReturns the tag 'generationtool' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.generationTool::Union{String, Nothing}: Returns the tag 'generationtool' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#technical-information-about-the-FMU","page":"Working with the FMI model description","title":"technical information about the FMU","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getNumberOfEventIndicators\ngetModelIdentifier\ngetVariableNamingConvention","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getNumberOfEventIndicators","page":"Working with the FMI model description","title":"FMIBase.getNumberOfEventIndicators","text":"getNumberOfEventIndicators(md::fmi2ModelDescription)\n\nReturns the tag 'numberOfEventIndicators' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.numberOfEventIndicators::Union{UInt, Nothing}: Returns the tag 'numberOfEventIndicators' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getModelIdentifier","page":"Working with the FMI model description","title":"FMIBase.getModelIdentifier","text":"getModelIdentifier(md::fmiModelDescription; type=nothing)\n\nReturns the tag 'modelIdentifier' from CS or ME section.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\ntype=nothing: Defines whether a Co-Simulation or Model Exchange is present. (default = nothing)\n\nReturns\n\nmd.modelExchange.modelIdentifier::String: Returns the tag modelIdentifier from ModelExchange section.\nmd.coSimulation.modelIdentifier::String: Returns the tag modelIdentifier from CoSimulation section.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getVariableNamingConvention","page":"Working with the FMI model description","title":"FMIBase.getVariableNamingConvention","text":"getVariableNamingConvention(md::fmi2ModelDescription)\n\nReturns the tag 'varaiblenamingconvention' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.variableNamingConvention::Union{fmi2VariableNamingConvention, Nothing}: Returns the tag 'variableNamingConvention' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi2GetVersion fmi2GetTypesPlatform","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#default-experiment-settings","page":"Working with the FMI model description","title":"default experiment settings","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getDefaultStartTime\ngetDefaultStepSize\ngetDefaultStopTime\ngetDefaultTolerance","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getDefaultStartTime","page":"Working with the FMI model description","title":"FMIBase.getDefaultStartTime","text":"getDefaultStartTime(md::fmi2ModelDescription)\n\nReturns startTime from DefaultExperiment if defined else defaults to nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.defaultExperiment.startTime::Union{Real,Nothing}: Returns a real value startTime from the DefaultExperiment if defined else defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getDefaultStepSize","page":"Working with the FMI model description","title":"FMIBase.getDefaultStepSize","text":"getDefaultStepSize(md::fmi2ModelDescription)\n\nReturns stepSize from DefaultExperiment if defined else defaults to nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.defaultExperiment.stepSize::Union{Real,Nothing}: Returns a real value setpSize from the DefaultExperiment if defined else defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getDefaultStopTime","page":"Working with the FMI model description","title":"FMIBase.getDefaultStopTime","text":"getDefaultStopTime(md::fmi2ModelDescription)\n\nReturns stopTime from DefaultExperiment if defined else defaults to nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.defaultExperiment.stopTime::Union{Real,Nothing}: Returns a real value stopTime from the DefaultExperiment if defined else defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getDefaultTolerance","page":"Working with the FMI model description","title":"FMIBase.getDefaultTolerance","text":"getDefaultTolerance(md::fmi2ModelDescription)\n\nReturns tolerance from DefaultExperiment if defined else defaults to nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.defaultExperiment.tolerance::Union{Real,Nothing}: Returns a real value tolerance from the DefaultExperiment if defined else defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMU-capabilities","page":"Working with the FMI model description","title":"FMU capabilities","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"canSerializeFMUState\nprovidesDirectionalDerivatives\nprovidesAdjointDerivatives","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.canSerializeFMUState","page":"Working with the FMI model description","title":"FMIBase.canSerializeFMUState","text":"canSerializeFMUState(md::fmi2ModelDescription)\n\nReturns true, if the FMU state can be serialized\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU state can be serialized\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.providesDirectionalDerivatives","page":"Working with the FMI model description","title":"FMIBase.providesDirectionalDerivatives","text":"providesDirectionalDerivative(md::fmi2ModelDescription)\n\nReturns true, if the FMU provides directional derivatives\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU provides directional derivatives\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.providesAdjointDerivatives","page":"Working with the FMI model description","title":"FMIBase.providesAdjointDerivatives","text":"Returns true, if the FMU provides adjoint derivatives\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"canGetSetFMUState fmi2DependenciesSupported fmi2DerivativeDependenciesSupported fmi2ProvidesDirectionalDerivative","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#value-references","page":"Working with the FMI model description","title":"value references","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getValueReferencesAndNames\ngetNames\ndataTypeForValueReference\nprepareValueReference\nprepareValue","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getValueReferencesAndNames","page":"Working with the FMI model description","title":"FMIBase.getValueReferencesAndNames","text":"getValueReferencesAndNames(obj; vrs=md.valueReferences)\n\nwith:\n\nobj ∈ (fmi2ModelDescription, FMU2)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of value references and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.valueReferences: Additional attribute valueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getNames","page":"Working with the FMI model description","title":"FMIBase.getNames","text":"getNames(md::fmi2ModelDescription; vrs=md.valueReferences, mode=:first)\n\nReturns a array of names corresponding to value references vrs.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.valueReferences: Additional attribute valueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.dataTypeForValueReference","page":"Working with the FMI model description","title":"FMIBase.dataTypeForValueReference","text":"dataTypeForValueReference(obj, vr::fmi2ValueReference)\n\nwhere:\n\nobj ∈ (fmi2ModelDescription, FMU2)\n\nReturns the fmi2DataType (fmi2Real, fmi2Integer, fmi2Boolean, fmi2String) for a given value reference vr.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.prepareValueReference","page":"Working with the FMI model description","title":"FMIBase.prepareValueReference","text":"prepareValueReference(obj, vrs)\n\nwhere: \n\nobj ∈ (fmi2ModelDescription, fmi3ModelDescription, FMU2, FMU3, FMU2Component, FMU3Instance) vrs ∈ (fmi2ValueReference, AbstractVector{fmi2ValueReference},         fmi3ValueReference, AbstractVector{fmi3ValueReference},         String, AbstractVector{String},         Integer, AbstractVector{Integer},        :states, :derivatives, :inputs, :outputs, :all, :none,        Nothing)\n\nReceives one or an array of value references in an arbitrary format (see fmi2ValueReferenceFormat) and converts it into an Array{fmi2ValueReference} (if not already).\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.prepareValue","page":"Working with the FMI model description","title":"FMIBase.prepareValue","text":"prepareValue(value)\n\nPrepares a value for a FMI ccall (they only accept arrays). Technically, the value is packed into an array - if not already.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#In-/Outputs","page":"Working with the FMI model description","title":"In-/Outputs","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getInputNames\ngetInputValueReferencesAndNames\ngetInputNamesAndStarts\ngetOutputNames\ngetOutputValueReferencesAndNames","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getInputNames","page":"Working with the FMI model description","title":"FMIBase.getInputNames","text":"getInputNames(md::fmi2ModelDescription; vrs=md.inputvalueReferences, mode=:first)\n\nReturns names of inputs.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.inputvalueReferences: Additional attribute inputvalueReferences::Array{fmi2ValueReference} of the Model Description that is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getInputValueReferencesAndNames","page":"Working with the FMI model description","title":"FMIBase.getInputValueReferencesAndNames","text":"getInputValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dict with (vrs, names of inputs).\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of inputs)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getInputNamesAndStarts","page":"Working with the FMI model description","title":"FMIBase.getInputNamesAndStarts","text":"getInputNamesAndStarts(md::fmi2ModelDescription)\n\nReturns a dictionary of input variables with their starting values.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{String, Array{fmi2ValueReferenceFormat}}: Returns a dictionary that constructs a hash table with keys of type String and values of type fmi2ValueReferenceFormat. So returns a dict with ( md.modelVariables[i].name::String, starts:: Array{fmi2ValueReferenceFormat} ). (Creates a tuple (name, starts) for each i in inputIndices)\n\nSee also getStartValue.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getOutputNames","page":"Working with the FMI model description","title":"FMIBase.getOutputNames","text":"fmi2GetOutputNames(md::fmi2ModelDescription; vrs=md.outputvalueReferences, mode=:first)\n\nReturns names of outputs.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.outputvalueReferences: Additional attribute outputvalueReferences::Array{fmi2ValueReference} of the Model Description that is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.outputvalueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getOutputValueReferencesAndNames","page":"Working with the FMI model description","title":"FMIBase.getOutputValueReferencesAndNames","text":"getOutputValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of value references and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.outputvalueReferences: Additional attribute outputvalueReferences::Array{fmi2ValueReference} of the Model Description that is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.outputvalueReferences::Array{fmi2ValueReference})\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}.So returns a dict with (vrs, names of outputs)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#Parameters","page":"Working with the FMI model description","title":"Parameters","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getParameterValueReferencesAndNames\ngetParameterNames","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getParameterValueReferencesAndNames","page":"Working with the FMI model description","title":"FMIBase.getParameterValueReferencesAndNames","text":"getParameterValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of parameterValueReferences and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of parameters).\n\nSee also getValueReferencesAndNames.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getParameterNames","page":"Working with the FMI model description","title":"FMIBase.getParameterNames","text":"fmi2GetParameterNames(md::fmi2ModelDescription; vrs=md.parameterValueReferences, mode=:first)\n\nReturns names of parameters.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.parameterValueReferences: Additional attribute parameterValueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.parameterValueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to parameter value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#States","page":"Working with the FMI model description","title":"States","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getStateNames\ngetStateValueReferencesAndNames","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getStateNames","page":"Working with the FMI model description","title":"FMIBase.getStateNames","text":"fmi2GetStateNames(fmu::FMU2; vrs=md.stateValueReferences, mode=:first)\n\nReturns names of states.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.stateValueReferences: Additional attribute parameterValueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.stateValueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to parameter value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getStateValueReferencesAndNames","page":"Working with the FMI model description","title":"FMIBase.getStateValueReferencesAndNames","text":"fmi2GetStateValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of state value references and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of states)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#Derivatives","page":"Working with the FMI model description","title":"Derivatives","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getDerivateValueReferencesAndNames\ngetDerivativeNames","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getDerivateValueReferencesAndNames","page":"Working with the FMI model description","title":"FMIBase.getDerivateValueReferencesAndNames","text":"fmi2GetDerivateValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of derivative value references and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of derivatives)\n\nSee also getValueReferencesAndNames\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getDerivativeNames","page":"Working with the FMI model description","title":"FMIBase.getDerivativeNames","text":"fmi2GetDerivativeNames(md::fmi2ModelDescription; vrs=md.derivativeValueReferences, mode=:first)\n\nReturns names of derivatives.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.derivativeValueReferences: Additional attribute derivativeValueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.derivativeValueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to parameter value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#Variables","page":"Working with the FMI model description","title":"Variables","text":"","category":"section"},{"location":"fmi_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"getNamesAndInitials\ngetNamesAndDescriptions\ngetNamesAndUnits","category":"page"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getNamesAndInitials","page":"Working with the FMI model description","title":"FMIBase.getNamesAndInitials","text":"getNamesAndInitials(md::fmi2ModelDescription)\n\nReturns a dictionary of variables with their initials.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{String, Cuint}: Returns a dictionary that constructs a hash table with keys of type String and values of type Cuint. So returns a dict with ( md.modelVariables[i].name::String, md.modelVariables[i].inital::Union{fmi2Initial, Nothing}). (Creates a tuple (name,initial) for each i in 1:length(md.modelVariables))\n\nSee also getInitial.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getNamesAndDescriptions","page":"Working with the FMI model description","title":"FMIBase.getNamesAndDescriptions","text":"getNamesAndDescriptions(md::fmi2ModelDescription)\n\nReturns a dictionary of variables with their descriptions.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{String, String}: Returns a dictionary that constructs a hash table with keys of type String and values of type String. So returns a dict with ( md.modelVariables[i].name::String, md.modelVariables[i].description::Union{String, Nothing}). (Creates a tuple (name, description) for each i in 1:length(md.modelVariables))\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_modeldescription_functions/#FMIBase.getNamesAndUnits","page":"Working with the FMI model description","title":"FMIBase.getNamesAndUnits","text":"getNamesAndUnits(md::fmi2ModelDescription)\n\nReturns a dictionary of variables with their units.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{String, String}: Returns a dictionary that constructs a hash table with keys of type String and values of type String. So returns a dict with ( md.modelVariables[i].name::String, md.modelVariables[i]._Real.unit::Union{String, Nothing}). (Creates a tuple (name, unit) for each i in 1:length(md.modelVariables))\n\nSee also getUnit.\n\n\n\n\n\n","category":"function"},{"location":"examples/workshops/","page":"Pluto Workshops","title":"Pluto Workshops","text":"Pluto based notebooks, that can easyly be executed on your own Pluto-Setup.","category":"page"},{"location":"examples/workshops/","page":"Pluto Workshops","title":"Pluto Workshops","text":"<iframe src=\"../pluto-src/index.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"fmi_lowlevel_library_constants/#Types-in-FMI-Import/Core-.jl","page":"Types in FMI Import/Core .jl","title":"Types in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi_lowlevel_library_constants/","page":"Types in FMI Import/Core .jl","title":"Types in FMI Import/Core .jl","text":"FMU\nFMUInstance\nFMUSolution\nFMUEvent\nFMUSnapshot\nFMUExecutionConfiguration\nFMULogLevel\nFMUInputFunction","category":"page"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMU","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMU","text":"FMU\n\nThe abstract type for FMUs (FMI 2 & 3).\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMUInstance","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMUInstance","text":"FMUInstance\n\nAn instance of a FMU. This was called component in FMI2, but was corrected to instance in FMI3.\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMUSolution","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMUSolution","text":"The mutable struct representing a specific Solution of a FMI2 FMU.\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMUEvent","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMUEvent","text":"Container for event related information.\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMUSnapshot","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMUSnapshot","text":"ToDo \n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMUExecutionConfiguration","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMUExecutionConfiguration","text":"A mutable struct representing the excution configuration of a FMU. For FMUs that have issues with calls like fmi2Reset or fmi2FreeInstance, this is pretty useful.\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMULogLevel","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMULogLevel","text":"Log levels for non-standard printing of infos, warnings and errors.\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#FMIBase.FMUInputFunction","page":"Types in FMI Import/Core .jl","title":"FMIBase.FMUInputFunction","text":"FMUInputFunction(inputFunction, vrs)\n\nStruct container for inplace input functions for FMUs.\n\nArguments\n\ninputFunction: The input function (inplace) that gets called when new inputs are needed, must match one of the patterns described under Input function patterns.\nvrs::AbstractVector: A vector of value refernces to be set by the input function\n\nInput function patterns\n\nAvailable input patterns are [c: current component, u: current state ,t: current time, returning array of values to be passed to fmi2SetReal(..., inputValueReferences, inputFunction(...)) or fmi3SetFloat64]:\n\ninputFunction(t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, u::AbstractVector{<:Real})\ninputFunction(x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\n\n\n\n\n\n","category":"type"},{"location":"fmi_lowlevel_library_constants/#Constants-in-FMI-Import/Core-.jl","page":"Types in FMI Import/Core .jl","title":"Constants in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi_lowlevel_library_constants/","page":"Types in FMI Import/Core .jl","title":"Types in FMI Import/Core .jl","text":"","category":"page"},{"location":"fmi2_lowlevel_CS_functions/#FMI-for-Co-Simulation","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"","category":"section"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"This chapter defines the Functional Mock-up Interface (FMI) for the coupling of two or more simulation models in a Co-Simulation environment (FMI for Co-Simulation). Co-Simulation is a rather general approach to the simulation of coupled technical systems and coupled physical phenomena in engineering with focus on instationary (time-dependent) problems.","category":"page"},{"location":"fmi2_lowlevel_CS_functions/#Transfer-of-Input-/-Output-Values-and-Parameters","page":"FMI for Co-Simulation","title":"Transfer of Input / Output Values and Parameters","text":"","category":"section"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"In order to enable the slave to interpolate the continuous real inputs between communication steps, the derivatives of the inputs with respect to time can be provided. Also, higher derivatives can be set to allow higher order interpolation.","category":"page"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"fmi2GetRealOutputDerivatives","category":"page"},{"location":"fmi2_lowlevel_CS_functions/#FMIImport.fmi2GetRealOutputDerivatives","page":"FMI for Co-Simulation","title":"FMIImport.fmi2GetRealOutputDerivatives","text":"fmi2GetRealOutputDerivatives(c::FMU2Component, vr::fmi2ValueReferenceFormat, order::AbstractArray{fmi2Integer})\n\nSets the n-th time derivative of real input variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\norder::Array{fmi2Integer}: Argument order is an array of fmi2Integer values witch specifys the corresponding order of derivative of the real input variable.\n\nReturns\n\nvalue::AbstactArray{fmi2Integer}: Return value is an array which represents a vector with the values of the derivatives.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#Computation","page":"FMI for Co-Simulation","title":"Computation","text":"","category":"section"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"The computation of time steps is controlled by the following function.","category":"page"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"fmi2DoStep\nfmi2CancelStep","category":"page"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2DoStep","page":"FMI for Co-Simulation","title":"FMICore.fmi2DoStep","text":"Source: FMISpec2.0.2[p.104]: 4.2.2 Computation\n\nThe computation of a time step is started.\n\n\n\n\n\nfmi2DoStep(c::FMU2Component, \n                currentCommunicationPoint::fmi2Real, \n                communicationStepSize::fmi2Real, \n                noSetFMUStatePriorToCurrentPoint::fmi2Boolean)\n\nThe computation of a time step is started.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ncurrentCommunicationPoint::fmi2Real:  Argument currentCommunicationPoint contains a value of type fmi2Real which is a identifier for a variable value . currentCommunicationPoint defines the current communication point of the master.\ncommunicationStepSize::fmi2Real: Argument communicationStepSize contains a value of type fmi2Real which is a identifier for a variable value. communicationStepSize defines the communiction step size.\n\nnoSetFMUStatePriorToCurrentPoint::Bool = true: Argument noSetFMUStatePriorToCurrentPoint contains a value of type Boolean. If no argument is passed the default value true is used. noSetFMUStatePriorToCurrentPoint indicates whether fmi2SetFMUState is no longer called for times before the currentCommunicationPoint in this simulation run Simulation run.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.2 Computation\n\nSee also fmi2DoStep.\n\n\n\n\n\nfmi2DoStep(c::FMU2Component, \n                communicationStepSize::Union{Real, Nothing} = nothing; \n                currentCommunicationPoint::Union{Real, Nothing} = nothing,\n                noSetFMUStatePriorToCurrentPoint::Bool = true)\n\nDoes one step in the CoSimulation FMU\n\nArguments\n\nC::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ncommunicationStepSize::Union{Real, Nothing} = nothing: Argument communicationStepSize contains a value of type Real or Nothing , if no argument is passed the default value nothing is used. communicationStepSize defines the communiction step size.\n\nKeywords\n\ncurrentCommunicationPoint::Union{Real, Nothing} = nothing: Argument currentCommunicationPoint contains a value of type Real or type Nothing. If no argument is passed the default value nothing is used. currentCommunicationPoint defines the current communication point of the master.\nnoSetFMUStatePriorToCurrentPoint::Bool = true: Argument noSetFMUStatePriorToCurrentPoint contains a value of type Boolean. If no argument is passed the default value true is used. noSetFMUStatePriorToCurrentPoint indicates whether fmi2SetFMUState is no longer called for times before the currentCommunicationPoint in this simulation run Simulation run.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.2 Computation\n\nSee also fmi2DoStep.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2CancelStep","page":"FMI for Co-Simulation","title":"FMICore.fmi2CancelStep","text":"Source: FMISpec2.0.2[p.105]: 4.2.2 Computation\n\nCan be called if fmi2DoStep returned fmi2Pending in order to stop the current asynchronous execution.\n\n\n\n\n\nfmi2CancelStep(c::FMU2Component)\n\nCan be called if fmi2DoStep returned fmi2Pending in order to stop the current asynchronous execution.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.2 Computation\n\nSee also fmi2DoStep.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#Retrieving-Status-Information-from-the-Slave","page":"FMI for Co-Simulation","title":"Retrieving Status Information from the Slave","text":"","category":"section"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"Status information is retrieved from the slave by the following functions:","category":"page"},{"location":"fmi2_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"fmi2GetStatus\nfmi2GetStatus!\nfmi2GetRealStatus!\nfmi2GetIntegerStatus!\nfmi2GetBooleanStatus!\nfmi2GetStringStatus!","category":"page"},{"location":"fmi2_lowlevel_CS_functions/#FMIImport.fmi2GetStatus","page":"FMI for Co-Simulation","title":"FMIImport.fmi2GetStatus","text":"ToDo\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2GetStatus!","page":"FMI for Co-Simulation","title":"FMICore.fmi2GetStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetStatus!(c::FMU2Component, \n                    s::fmi2StatusKind, \n                    value::Ref{fmi2Status})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue::Ref{fmi2Status}: The value argument points to a status flag that was requested.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2GetRealStatus!","page":"FMI for Co-Simulation","title":"FMICore.fmi2GetRealStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetRealStatus!(c::FMU2Component, \n                        s::fmi2StatusKind, \n                        value::Ref{fmi2Real})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue::Ref{fmi2Real}: Argument value points to the return value (fmi2Real) which was requested. fmi2Real is a alias type for Real data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetRealStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2GetIntegerStatus!","page":"FMI for Co-Simulation","title":"FMICore.fmi2GetIntegerStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetIntegerStatus!(c::FMU2Component, \n                            s::fmi2StatusKind, \n                            value::Ref{fmi2Integer})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue::Ref{fmi2Integer}: Argument value points to the return value (fmi2Integer) which was requested. fmi2Integer is a alias type for Integer data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetIntegerStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2GetBooleanStatus!","page":"FMI for Co-Simulation","title":"FMICore.fmi2GetBooleanStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetBooleanStatus!(c::FMU2Component, \n                        s::fmi2StatusKind, \n                        value::Ref{fmi2Boolean})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue::Ref{fmi2Boolean}: Argument value points to the return value (fmi2Boolean) which was requested. fmi2Boolean is a alias type for Boolean data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetBooleanStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_CS_functions/#FMICore.fmi2GetStringStatus!","page":"FMI for Co-Simulation","title":"FMICore.fmi2GetStringStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetStringStatus!(c::FMU2Component, \n                        s::fmi2StatusKind, \n                        value::Ref{fmi2String})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue:Ref{fmi2String}: Argument value points to the return value (fmi2String) which was requested. fmi2String is a alias type for String data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetStringStatus!.\n\n\n\n\n\n","category":"function"},{"location":"examples/manipulation/#Manipulate-a-function","page":"Manipulation","title":"Manipulate a function","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Tutorial by Tobias Thummerer, Johannes Stoljar","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"🚧 This tutorial is under revision and will be replaced by an up-to-date version soon 🚧","category":"page"},{"location":"examples/manipulation/#License","page":"Manipulation","title":"License","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/manipulation/#Introduction-to-the-example","page":"Manipulation","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"This example shows how to overwrite a FMI function with a custom C-function. For this the FMU model is simulated first without changes. Then the function fmi2GetReal() is overwritten and simulated again. Both simulations are displayed in a graph to show the change caused by overwriting the function. The model used is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"(Image: svg)  ","category":"page"},{"location":"examples/manipulation/#Other-formats","page":"Manipulation","title":"Other formats","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/manipulation/#Code-section","page":"Manipulation","title":"Code section","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# imports\nusing FMI\nusing FMI: fmi2SetFctGetReal\nusing FMIZoo\nusing FMICore\nusing Plots\nusing DifferentialEquations # for auto solver detection","category":"page"},{"location":"examples/manipulation/#Simulation-setup","page":"Manipulation","title":"Simulation setup","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Next, the start time and end time of the simulation are set.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"tStart = 0.0\ntStop = 8.0","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"8.0","category":"page"},{"location":"examples/manipulation/#Import-FMU","page":"Manipulation","title":"Import FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Next, the FMU model from FMIZoo.jl is loaded.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# we use an FMU from the FMIZoo.jl\nfmu = loadFMU(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\"; type=:ME)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Model name:\tSpringFrictionPendulum1D\nType:\t\t0","category":"page"},{"location":"examples/manipulation/#Simulate-FMU","page":"Manipulation","title":"Simulate FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In the next steps the recorded value is defined. The recorded value is the position of the mass. In the function simulateME() the FMU is simulated in model-exchange mode (ME) with an adaptive step size. In addition, the start and end time and the recorded variables are specified.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# an array of value references... or just one\nvrs = [\"mass.s\"]\n\nsimData = simulate(fmu, (tStart, tStop); recordValues=vrs)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"\u001b[34mSimulating ME-FMU ...   0%|█                             |  ETA: N/A\u001b[39m\n\n\u001b[34mSimulating ME-FMU ... 100%|██████████████████████████████| Time: 0:00:15\u001b[39m\n\n\n\n\n\nModel name:\n\tSpringFrictionPendulum1D\nSuccess:\n\ttrue\nf(x)-Evaluations:\n\tIn-place: 687\n\tOut-of-place: 0\nJacobian-Evaluations:\n\t∂ẋ_∂p: 0\n\t∂ẋ_∂x: 0\n\t∂ẋ_∂u: 0\n\t∂y_∂p: 0\n\t∂y_∂x: 0\n\t∂y_∂u: 0\n\t∂e_∂p: 0\n\t∂e_∂x: 0\n\t∂e_∂u: 0\n\t∂xr_∂xl: 0\nGradient-Evaluations:\n\t∂ẋ_∂t: 0\n\t∂y_∂t: 0\n\t∂e_∂t: 0\nCallback-Evaluations:\n\tCondition (event-indicators): 1451\n\tTime-Choice (event-instances): 0\n\tAffect (event-handling): 6\n\tSave values: 108\n\tSteps completed: 108\nStates [108]:\n\t0.0\t[0.5, 0.0]\n\t2.352941176471972e-11\t[0.5, 1.0e-10]\n\t0.002306805098500577\t[0.50001131604032, 0.009814511243574901]\n\t0.017671223740348286\t[0.5006669891786611, 0.07566472543814211]\n\t0.05336453143679057\t[0.5061289100741069, 0.23069249960269952]\n\t0.1184474067147955\t[0.5303427360215145, 0.5120833994161043]\n\t0.18484539042135573\t[0.5734637065822751, 0.7826807485295294]\n\t0.26484539042135574\t[0.6477775947325276, 1.0656550745038857]\n\t0.34484539042135576\t[0.7421945365288517, 1.2822970458377356]\n\t...\n\t8.0\t[1.0668392065868253, -1.0000121313794676e-10]\nValues [108]:\n\t0.0\t(0.5,)\n\t2.352941176471972e-11\t(0.5,)\n\t0.002306805098500577\t(0.50001131604032,)\n\t0.017671223740348286\t(0.5006669891786611,)\n\t0.05336453143679057\t(0.5061289100741069,)\n\t0.1184474067147955\t(0.5303427360215145,)\n\t0.18484539042135573\t(0.5734637065822751,)\n\t0.26484539042135574\t(0.6477775947325276,)\n\t0.34484539042135576\t(0.7421945365288517,)\n\t...\n\t8.0\t(1.0668392065868253,)\nEvents [6]:\n\tState-Event #11 @ 2.352941176471972e-11s (state-change: false)\n\tState-Event #11 @ 0.9940420391302653s (state-change: false)\n\tState-Event #19 @ 1.9882755413358095s (state-change: false)\n\tState-Event #11 @ 2.9830393009345677s (state-change: false)\n\tState-Event #19 @ 3.978829658884447s (state-change: false)\n\tState-Event #11 @ 4.976975955926236s (state-change: false)","category":"page"},{"location":"examples/manipulation/#Plotting-FMU","page":"Manipulation","title":"Plotting FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"After the simulation is finished, the result of the FMU for the model-exchange mode can be plotted. In the plot for the FMU it can be seen that the oscillation continues to decrease due to the effect of the friction. If you simulate long enough, the oscillation comes to a standstill in a certain time.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"fig = plot(simData, states=false)","category":"page"},{"location":"examples/manipulation/#Override-Function","page":"Manipulation","title":"Override Function","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"After overwriting a function, the previous one is no longer accessible. The original function fmi2GetReal() is cached by storing the address of the pointer. The addresses of the pointers are kept in the FMU and are thus accessible.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# save, where the original `fmi2GetReal` function was stored, so we can access it in our new function\noriginalGetReal = fmu.cGetReal","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Ptr{Nothing} @0x000000018008da60","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"To overwrite the function fmi2GetReal!(), the function header of the new custom function must be identical to the previous one. The function header looks like fmi2GetReal!(cfunc::Ptr{Nothing}, c::fmi2Component, vr::Union{Array{fmi2ValueReference}, Ptr{fmi2ValueReference}}, nvr::Csize_t, value::Union{Array{fmi2Real}, Ptr{fmi2Real}})::fmi2Status. The information how the FMI2 function are structured can be seen from FMICore.jl, the api of fmi2GetReal! or the FMI2.0.3-specification.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In the new implementation the original function is called by the previously stored pointer. Next there is a special handling if value is a pointer to an array. In this case the pointer is treated as an array, so that the entries are accessible. Otherwise, each value in value is multiplied by two. Finally, the original state of the original function is output.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"function myGetReal!(c::fmi2Component, vr::Union{Array{fmi2ValueReference}, Ptr{fmi2ValueReference}}, \n                    nvr::Csize_t, value::Union{Array{fmi2Real}, Ptr{fmi2Real}})\n    # first, we do what the original function does\n    status = fmi2GetReal!(originalGetReal, c, vr, nvr, value)\n\n    # if we have a pointer to an array, we must interprete it as array to access elements\n    if isa(value, Ptr{fmi2Real})\n        value = unsafe_wrap(Array{fmi2Real}, value, nvr, own=false)\n    end\n\n    # now, we multiply every value by two (just for fun!)\n    for i in 1:nvr \n        value[i] *= 2.0 \n    end \n\n    # return the original status\n    return status\nend","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"myGetReal! (generic function with 1 method)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In the next command the original function is overwritten with the new defined function, for which the command fmiSetFctGetReal() is called.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# no we overwrite the original function\nfmi2SetFctGetReal(fmu, myGetReal!)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Ptr{Nothing} @0x0000017709f00fc0","category":"page"},{"location":"examples/manipulation/#Simulate-and-Plot-FMU-with-modified-function","page":"Manipulation","title":"Simulate and Plot FMU with modified function","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"As before, the identical command is called here for simulation. This is also a model exchange simulation. Immediately afterwards, the results are added to the previous graph as a dashed line.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"simData = simulate(fmu, (tStart, tStop); recordValues=vrs)\nplot!(fig, simData; states=false, style=:dash)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"As expected by overwriting the function, all values are doubled.","category":"page"},{"location":"examples/manipulation/#Unload-FMU","page":"Manipulation","title":"Unload FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"unloadFMU(fmu)","category":"page"},{"location":"examples/manipulation/#Summary","page":"Manipulation","title":"Summary","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In this tutorial it is shown how an existing function of the library can be replaced by an own implementation.","category":"page"},{"location":"library/#FMI.jl-Library-Functions","page":"User Level API - FMI.jl","title":"FMI.jl Library Functions","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"Many of the functions in this library are based on already defined functions of the FMIImport.jl library. ","category":"page"},{"location":"library/#Simulate-FMUs","page":"User Level API - FMI.jl","title":"Simulate FMUs","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"loadFMU\nsimulate\nsimulateCS\nsimulateSE\nsimulateME\nunloadFMU\nreload","category":"page"},{"location":"library/#FMIImport.loadFMU","page":"User Level API - FMI.jl","title":"FMIImport.loadFMU","text":"loadFMU(pathToFMU; unpackPath, cleanup, type)\n\nLoads an FMU, independent of the used FMI-version (the version is checked during unpacking the archive).\n\nArguments\n\npath::String the path pointing on the FMU file.\n\nKeywords\n\nunpackPath::Union{String, Nothing}=nothing the optional unpack path, if nothing a temporary directory depending on the OS is picked.\ncleanup::Bool=true a boolean indicating whether the temporary directory should be cleaned automatically.\ntype::Union{Symbol, Nothing}=nothing the type of FMU (:CS, :ME, :SE), if multiple types are available. If nothing one of the available types is chosen automatically with the priority CS > ME > SE.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.simulate","page":"User Level API - FMI.jl","title":"FMI.simulate","text":"simulate(fmu, instance=nothing, tspan=nothing; kwargs...)\nsimulate(fmu, tspan; kwargs...)\nsimulate(instance, tspan; kwargs...)\n\nStarts a simulation of the FMU2 for the instantiated type: CS, ME or SE (this is selected automatically or during loading of the FMU). You can force a specific simulation mode by calling simulateCS, simulateME or simulateSE directly.\n\nArguments\n\nfmu::FMU: The FMU to be simulated.\nc::Union{FMUInstance, Nothing}=nothing: The instance (FMI3) or component (FMI2) of the FMU, nothing if not available. \ntspan::Union{Tuple{Float64, Float64}, Nothing}=nothing: Simulation-time-span as tuple (default = nothing: use default value from FMU's model description or (0.0, 1.0) if not specified)\n\nKeyword arguments\n\nrecordValues::fmi2ValueReferenceFormat = nothing: Array of variables (Strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues\nsaveat = nothing: Time points to save (interpolated) values at (default = nothing: save at each solver timestep)\nsetup::Bool: call fmi2SetupExperiment, fmi2EnterInitializationMode and fmi2ExitInitializationMode before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nreset::Bool: call fmi2Reset before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\ninstantiate::Bool: call fmi2Instantiate! before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nfreeInstance::Bool: call fmi2FreeInstance after each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nterminate::Bool: call fmi2Terminate after each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\ninputValueReferences::fmi2ValueReferenceFormat = nothing: Input variables (Strings or variableIdentifiers) to set at each simulation step \ninputFunction = nothing: Function to get values for the input variables at each simulation step. \nparameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing: Dict of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization\nshowProgress::Bool = true: print simulation progress meter in REPL\n\nInput function pattern\n\n[c: current component, u: current state ,t: current time, returning array of values to be passed to fmi2SetReal(..., inputValueReferences, inputFunction(...)) or fmi3SetFloat64]:\n\ninputFunction(t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, u::AbstractVector{<:Real})\ninputFunction(x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\n\nReturns:\n\nA FMUSolution struct.\n\nSee also simulate, simulateME, simulateCS, simulateSE.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.simulateCS","page":"User Level API - FMI.jl","title":"FMI.simulateCS","text":"simulateCS(fmu, instance=nothing, tspan=nothing; kwargs...)\nsimulateCS(fmu, tspan; kwargs...)\nsimulateCS(instance, tspan; kwargs...)\n\nSimulate CS-FMU for the given simulation time interval. State- and Time-Events are handled internally by the FMU.\n\nArguments\n\nfmu::FMU: The FMU to be simulated.\nc::Union{FMUInstance, Nothing}=nothing: The instance (FMI3) or component (FMI2) of the FMU, nothing if not available. \ntspan::Union{Tuple{Float64, Float64}, Nothing}=nothing: Simulation-time-span as tuple (default = nothing: use default value from FMU's model description or (0.0, 1.0) if not specified)\n\nKeyword arguments\n\ntolerance::Union{Real, Nothing} = nothing: The tolerance for the internal FMU solver.\nrecordValues::fmi2ValueReferenceFormat = nothing: Array of variables (Strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues\nsaveat = nothing: Time points to save (interpolated) values at (default = nothing: save at each solver timestep)\nsetup::Bool: call fmi2SetupExperiment, fmi2EnterInitializationMode and fmi2ExitInitializationMode before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nreset::Bool: call fmi2Reset before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\ninstantiate::Bool: call fmi2Instantiate! before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nfreeInstance::Bool: call fmi2FreeInstance after each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nterminate::Bool: call fmi2Terminate after each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\ninputValueReferences::fmi2ValueReferenceFormat = nothing: Input variables (Strings or variableIdentifiers) to set at each simulation step \ninputFunction = nothing: Function to get values for the input variables at each simulation step. \nparameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing: Dict of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization\nshowProgress::Bool = true: print simulation progress meter in REPL\n\nInput function pattern\n\n[c: current component, u: current state ,t: current time, returning array of values to be passed to fmi2SetReal(..., inputValueReferences, inputFunction(...)) or fmi3SetFloat64]:\n\ninputFunction(t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, u::AbstractVector{<:Real})\ninputFunction(x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\n\nReturns:\n\nA FMUSolution struct.\n\nSee also simulate, simulateME, simulateSE.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.simulateSE","page":"User Level API - FMI.jl","title":"FMI.simulateSE","text":"simulateSE(fmu, instance=nothing, tspan=nothing; kwargs...)\nsimulateSE(fmu, tspan; kwargs...)\nsimulateSE(instance, tspan; kwargs...)\n\nTo be implemented ...\n\nArguments\n\nfmu::FMU3: The FMU to be simulated. Note: SE is only available in FMI3.\nc::Union{FMU3Instance, Nothing}=nothing: The instance (FMI3) of the FMU, nothing if not available. \ntspan::Union{Tuple{Float64, Float64}, Nothing}=nothing: Simulation-time-span as tuple (default = nothing: use default value from FMU's model description or (0.0, 1.0) if not specified)\n\nKeyword arguments\n\nTo be implemented ...\n\nReturns:\n\nA FMUSolution struct.\n\nSee also simulate, simulateME, simulateCS.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.simulateME","page":"User Level API - FMI.jl","title":"FMI.simulateME","text":"simulateME(fmu, instance=nothing, tspan=nothing; kwargs...)\nsimulateME(fmu, tspan; kwargs...)\nsimulateME(instance, tspan; kwargs...)\n\nSimulate ME-FMU for the given simulation time interval. State- and Time-Events are handled correctly.\n\nArguments\n\nfmu::FMU: The FMU to be simulated.\nc::Union{FMUInstance, Nothing}=nothing: The instance (FMI3) or component (FMI2) of the FMU, nothing if not available. \ntspan::Union{Tuple{Float64, Float64}, Nothing}=nothing: Simulation-time-span as tuple (default = nothing: use default value from FMU's model description or (0.0, 1.0) if not specified)\n\nKeyword arguments\n\nsolver = nothing: Any Julia-supported ODE-solver (default = nothing: use DifferentialEquations.jl default solver)\nrecordValues::fmi2ValueReferenceFormat = nothing: Array of variables (Strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues\nrecordEventIndicators::Union{AbstractArray{<:Integer, 1}, UnitRange{<:Integer}, Nothing} = nothing: Array or Range of event indicators to record\nrecordEigenvalues::Bool=false: compute and record eigenvalues\nsaveat = nothing: Time points to save (interpolated) values at (default = nothing: save at each solver timestep)\nx0::Union{AbstractArray{<:Real}, Nothing} = nothing: initial fmu State (default = nothing: use current or default-initial fmu state)\nsetup::Bool: call fmi2SetupExperiment, fmi2EnterInitializationMode and fmi2ExitInitializationMode before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nreset::Bool: call fmi2Reset before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\ninstantiate::Bool: call fmi2Instantiate! before each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nfreeInstance::Bool: call fmi2FreeInstance after each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\nterminate::Bool: call fmi2Terminate after each step (default = nothing: use value from fmu's FMUExecutionConfiguration)\ninputValueReferences::fmi2ValueReferenceFormat = nothing: Input variables (Strings or variableIdentifiers) to set at each simulation step \ninputFunction = nothing: Function to get values for the input variables at each simulation step. \nparameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing: Dict of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization\ncallbacksBefore = []: callbacks to call before the internal callbacks for state- and time-events are called\ncallbacksAfter = []: callbacks to call after the internal callbacks for state- and time-events are called\nshowProgress::Bool = true: print simulation progress meter in REPL\nsolveKwargs...: keyword arguments that get passed onto the solvers solve call\n\nInput function pattern\n\n[c: current component, u: current state ,t: current time, returning array of values to be passed to fmi2SetReal(..., inputValueReferences, inputFunction(...)) or fmi3SetFloat64]:\n\ninputFunction(t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, u::AbstractVector{<:Real})\ninputFunction(x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\ninputFunction(c::Union{FMUInstance, Nothing}, x::AbstractVector{<:Real}, t::Real, u::AbstractVector{<:Real})\n\nReturns:\n\nA FMUSolution struct.\n\nSee also simulate, simulateCS, simulateSE.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIImport.unloadFMU","page":"User Level API - FMI.jl","title":"FMIImport.unloadFMU","text":"unloadFMU(fmu::FMU2, cleanUp::Bool=true; secure_pointers::Bool=true)\n\nUnload a FMU. Free the allocated memory, close the binaries and remove temporary zip and unziped FMU model description.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\ncleanUp::Bool= true: Defines if the file and directory should be deleted.\n\nKeywords\n\nsecure_pointers=true whether pointers to C-functions should be overwritten with dummies with Julia assertions, instead of pointing to dead memory (slower, but more user safe)\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIImport.reload","page":"User Level API - FMI.jl","title":"FMIImport.reload","text":"reload(fmu::FMU2)\n\nReloads the FMU-binary. This is useful, if the FMU does not support a clean reset implementation.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\n\n\n\n\n","category":"function"},{"location":"library/#Handling-Value-References","page":"User Level API - FMI.jl","title":"Handling Value References","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"stringToValueReference","category":"page"},{"location":"library/#FMIBase.stringToValueReference","page":"User Level API - FMI.jl","title":"FMIBase.stringToValueReference","text":"stringToValueReference(obj, names)\n\nFinds the value reference for a given name.\n\nArguments\n\nobj ∈ (fmi2ModelDescription, fmi3ModelDescription, FMU2, FMU3) the FMI object\nnames ∈ (String, AbstractVector{String}) the value refernce name or multiple names\n\nReturn\n\nReturns a single or an array of fmi2ValueReferences (FMI2) or fmi3ValueReferences (FMI3) corresponding to the variable name(s).\n\n\n\n\n\n","category":"function"},{"location":"library/#External/additional-functions","page":"User Level API - FMI.jl","title":"External/additional functions","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"info\ngetModelName\ngetNumberOfStates\nisModelExchange\nisScheduledExecution\nisCoSimulation\ngetState\ngetTime\ngetStateDerivative","category":"page"},{"location":"library/#FMIImport.info","page":"User Level API - FMI.jl","title":"FMIImport.info","text":" info(fmu)\n\nPrint information about the FMU.\n\nArguments\n\nfmu::FMU: The FMU you are interessted in.\n\nFurther reading\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.getModelName","page":"User Level API - FMI.jl","title":"FMIBase.getModelName","text":"getModelName(md::fmi2ModelDescription)\n\nReturns the tag 'modelName' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmodelName::String: Returns the tag 'modelName' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.getNumberOfStates","page":"User Level API - FMI.jl","title":"FMIBase.getNumberOfStates","text":"getNumberOfStates(md::fmi2ModelDescription)\n\nReturns the number of states of the FMU.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nReturns the number of states of the FMU.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.isModelExchange","page":"User Level API - FMI.jl","title":"FMIBase.isModelExchange","text":"isModelExchange(md::fmi2ModelDescription)\n\nReturns true, if the FMU supports model exchange\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU supports model exchange\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.isScheduledExecution","page":"User Level API - FMI.jl","title":"FMIBase.isScheduledExecution","text":"Returns true, if the FMU supports scheduled execution\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.isCoSimulation","page":"User Level API - FMI.jl","title":"FMIBase.isCoSimulation","text":"isCoSimulation(md::fmi2ModelDescription)\n\nReturns true, if the FMU supports co simulation\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU supports co simulation\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.getState","page":"User Level API - FMI.jl","title":"FMIBase.getState","text":"getState(solution::FMUSolution, vr::fmi2ValueReferenceFormat; isIndex::Bool=false)\n\nReturns the solution state.\n\nArguments\n\nsolution::FMUSolution: Struct contains information about the solution value, success, state and  events of a specific FMU.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nisIndex::Bool=false: Argument isIndex exists to check if vr ist the specific solution element (\"index\") that equals the given fmi2ValueReferenceFormat\n\nReturn\n\nIf he length of the given references equals 1, each element u in the collection solution.states.u, it is selecting the element at the index represented by indices[1] and returns it.\n\nThus, the collect() function is taking the generator expression and returning an array of the selected elements. \n\nIf more than one reference is given, the same process takes place as before. The difference is that now more than one index is accessed.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.getTime","page":"User Level API - FMI.jl","title":"FMIBase.getTime","text":"getTime(solution::FMUSolution)\n\nReturns the Solution time.\n\nArguments\n\nsolution::FMUSolution: Struct contains information about the solution value, success, state and  events of a specific FMU.\n\nReturn\n\nsolution.states.t::tType: solution.state is a struct ODESolution with attribute t. t is the time points corresponding to the saved values of the ODE solution.\nsolution.values.t::tType: solution.value is a struct ODESolution with attribute t.t the time points corresponding to the saved values of the ODE solution.\nIf no solution time is  found nothing is returned.\n\n#Source\n\nusing OrdinaryDiffEq: ODESolution  (SciML/SciMLBase.jl)\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"library/#FMIBase.getStateDerivative","page":"User Level API - FMI.jl","title":"FMIBase.getStateDerivative","text":"getStateDerivative(solution::FMUSolution, vr::fmi2ValueReferenceFormat; isIndex::Bool=false)\n\nReturns the solution state derivative.\n\nArguments\n\nsolution::FMUSolution: Struct contains information about the solution value, success, state and  events of a specific FMU.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nisIndex::Bool=false: Argument isIndex exists to check if vr ist the specific solution element (\"index\") that equals the given fmi2ValueReferenceFormat\n\nReturn\n\nIf the length of the given references equals 1, each element myt in the collection solution.states.t is selecting the derivative of the solution states represented by indices[1] in respect to time, at time myt and returns its it.\n\nThus, the collect() function is taking the generator expression and returning an array of the selected derivatives. \n\nIf more than one reference is given, the same process takes place as before. The difference is that now more than one index is accessed.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"fmiSet fmiGet fmiGet! fmiCanGetSetState fmiSetState fmiFreeState! fmiGetDependencies fmiProvidesDirectionalDerivative","category":"page"},{"location":"library/#Visualize-simulation-results","page":"User Level API - FMI.jl","title":"Visualize simulation results","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"","category":"page"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"fmiPlot fmiPlot! Plots.plot","category":"page"},{"location":"library/#Save/load-simulation-results","page":"User Level API - FMI.jl","title":"Save/load simulation results","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"","category":"page"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"fmiSaveSolution fmiSaveSolutionJLD2 fmiSaveSolutionMAT fmiSaveSolutionCSV fmiLoadSolution fmiLoadSolutionJLD2","category":"page"},{"location":"library/#FMI2-specific","page":"User Level API - FMI.jl","title":"FMI2 specific","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"","category":"page"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"fmi2Info fmi2Simulate fmi2VariableDependsOnVariable fmi2GetDependencies fmi2PrintDependencies","category":"page"},{"location":"library/#FMI3-specific","page":"User Level API - FMI.jl","title":"FMI3 specific","text":"","category":"section"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"","category":"page"},{"location":"library/","page":"User Level API - FMI.jl","title":"User Level API - FMI.jl","text":"fmi3Info fmi3Simulate fmi3VariableDependsOnVariable fmi3GetDependencies fmi3PrintDependencies","category":"page"},{"location":"features/#Features","page":"Features","title":"Features","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Please note, that this guide focuses also on users, that are not familiar with FMI. The following feature explanations are written in an easy-to-read-fashion, so there might be some points that are scientifically only 95% correct. For further information on FMI and FMUs, see fmi-standard.org. The term fmiX... refers to a value or function that is available along different versions of FMI, for example fmiXValueReference is a wildcard for fmi2ValueReference and fmi3ValueReference.","category":"page"},{"location":"features/#Execution-Configuration","page":"Features","title":"Execution Configuration","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Not all FMUs support all features they should according to the FMI-standard, so FMI.jl provides a so called execution configuration.  This configuration is also respected by FMIFlux.jl. The content of the execution configuration may change in future (together with new or deprecated features of linked libraries), but the most important core features will be kept over time. Because not all users need the full potential of this configuration tool, there are three presets given: ","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"myFMU.executionConfig = FMU_EXECUTION_CONFIGURATION_NO_RESET is the default operation mode for FMUs. FMUs are not reset via fmi2Reset, but new instantiated for every simulation run (or training step). This is not the most efficient way, but many FMUs have problems with resetting.\nmyFMU.executionConfig = FMU_EXECUTION_CONFIGURATION_RESET is faster for well-implemented FMUs, but needs a fully working fmi2Reset-function. So if you know you have a fully working fmi2Reset, you may be faster with that option.\nmyFMU.executionConfig = FMU_EXECUTION_CONFIGURATION_NO_FREEING should only be the very last choice. If your FMU neither supports fmi2Reset nor a proper fmi2FreeInstance, you could use this configuration as a last way out. Keep in mind, that new FMU instances are allocated but not freed, as long as your Julia instance is running (memory leak). In general, the amount of leaked memory is small, but you need to know what you are doing, if you do thousands or ten-thousands of simulation runs with such a FMU.\nmyFMU.executionConfig = FMU_EXECUTION_CONFIGURATION_NOTHING should be used if you want maximum control over what is done and what not. This means you need to take care of instantiating, initialization, setting up and releasing FMU instances by yourself.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"For a more detailed overview, please see the ?FMUExecutionConfig.","category":"page"},{"location":"features/#Debugging-/-Logging","page":"Features","title":"Debugging / Logging","text":"","category":"section"},{"location":"features/#Logging-FMI-calls","page":"Features","title":"Logging FMI-calls","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"To log all FMI-calls that happen (including \"hidden\" calls e.g. if you are using simulate) you can enable debugging for FMICore.jl using ENV[\"JULIA_DEBUG\"] = \"FMICore\". This will log any fmi2xxx- and fmi3xxx-call, including the given parameters and return value. This can be a lot of calls, so you may want to redirect your REPL output to file.","category":"page"},{"location":"features/#Printing-internal-FMU-messages","page":"Features","title":"Printing internal FMU messages","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Many FMUs support for printing debugging messages. To force message printing, you can use the keyword loggingOn=true either ...","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"in the call fmiInstantiate, for example fmiInstantiate(myFMU; loggingOn=true) or\nas part of the executionConfig, for example myFMU.executionConfig.loggingOn=true","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"You can further control which message types - like OK, Warning, Discard, Error, Fatal, Pending - should be logged by using the keywords logStatus{TYPE}=true as part of fmiInstantiate or (soon) the execution configuration. By default, all are activated. If your FMU (for FMI2 only, FMI3 changed this) uses a variadic callback function for messages (this is not supported by Julia at this time), you may need to activate external callbacks with the keyword externalCallbacks=true either ...","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"in the call fmiInstantiate!, for example fmiInstantiate!(myFMU; loggingOn=true, externalCallbacks=true) or\nas part of the executionConfig, for example myFMU.executionConfig.loggingOn=true; myFMU.executionConfig.externalCallbacks=true","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"External callbacks are currently only supported on Windows and Linux.","category":"page"},{"location":"features/#Model-variable-identification","page":"Features","title":"Model variable identification","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"FMI.jl offers multiple ways to retrieve your model variables. Any function that accepts a variable identifier can handle the following argument types:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"UInt32 or fmiXValueReference for example 1610612742 or 0x16000001: This is the most performant way of passing a variable identifier, but you need to know the value reference (you can determine them by having a look in the modelDescription.xml).\nVector{UInt32} or Vector{fmiXValueReference} for example [1610612742, 1610612743] or [0x16000001, 0x16000002]: This is the most performant way of passing multiple variable identifiers, but you need to know the value references.\nString for example \"ball.s\": This is the most intuitive way, because you might already know the variable name from your modelling environment or model documentation.\nVector{String} for example [\"ball.s\", \"der(ball.s)\"]: This is the most intuitive way for multiple variable identifiers, because you might already know the variable names from your modelling environment or model documentation.\nSymbol for example :states: There are multiple symbol-wildcards for interesting variable groups like :all, :none, :states, :derivatives, :inputs and :outputs.\nnothing: If you don't want to record anything (same as :none)","category":"page"},{"location":"features/#Event-handling","page":"Features","title":"Event handling","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"In FMI, there are basically two types of events: state and time.  State events are triggered, as soon as one or more event indicators - scalar values that describe the \"distance\" in state space to the next state event - crossing zero.  Time events are triggered at known time points during the simulation.  If your model has state and/or time events is detected automatically by FMI.jl and the event handling happens automatically in the background.","category":"page"},{"location":"features/#Model-exchange,-co-simulation-and-scheduled-execution","page":"Features","title":"Model exchange, co-simulation and scheduled execution","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"There are two different model types for FMUs in FMI2: Model exchange (ME) and co-simulation (CS). FMI3 further adds the mode scheduled execution (SE). If you have a FMU and are only interested in getting it simulated, use simulate so FMI.jl will automatically pick CS if available and otherwise ME. If you want to force a specific simulation mode, you can use simulateME (for ME), simulateCS (for CS) or simulateSE (for SE).","category":"page"},{"location":"features/#Simulate-arbitrary-time-intervals","page":"Features","title":"Simulate arbitrary time intervals","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"You can simply simulate arbitrary time intervals by passing a startTime unequal zero to fmi2SetupExperiment or [ToDo: corresponding FMI3 function].  Because some FMUs don't support startTime != 0.0 and will throw an error or warning, a time shifting feature inside FMI.jl can be used, that performs all necessary steps in the background - corresponding commands like e.g. fmi2SetTime or fmi2NewDiscreteStates act like the desired time interval is simulated. This feature is disabled by default, but can be activated in the execution configuration using myFMU.executionConfig.autoTimeShift=true while providing a startTime != 0.0.","category":"page"},{"location":"features/#Performance","page":"Features","title":"Performance","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"In- and Out-of-Place: Many commands in FMI.jl are available in in-place and out-of-place semantics. Of course, in-place-calls are faster, because they don't need to allocate new memory at every call (for the return values). So if you have an eye on performance (or must have), a good starting point is to substitute out-of-place- with in-place-calls. Typical improvements are:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"valueArray = fmi2GetReal(args...) -> fmi2GetReal!(args..., valueArray)\nvalueArray = fmi2GetDerivatives(args...) -> fmi2GetDerivatives!(args..., valueArray)\nvalueArray = fmi2NewDiscreteStates(args...) -> fmi2NewDiscreteStates!(args..., valueArray)","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Of course, you have to use the same piece of memory (to write your return values in) for multiple calls - otherwise there will be no improvement because the number of allocations stays the same.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Views: You can use array-views instead of array-slices as input for in-place-functions, which further reduces memory allocations.","category":"page"},{"location":"features/#AD-Ecosystem-(differentiation-over-FMUs)","page":"Features","title":"AD-Ecosystem (differentiation over FMUs)","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Sensitivites over FMUs are fully integrated into FMI.jl, FMIImport.jl and FMIFlux.jl. Supported are ForwardDiff.jl together with all AD-frameworks, that use the interface of ChainRules.jl like e.g. Zygote.jl and ReverseDiff.jl. As a result, you can use implicit solvers or you can use FMUs as part of machine learning applications.","category":"page"},{"location":"features/#Watch-your-progress","page":"Features","title":"Watch your progress","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"When simulating FMUs with FMI.jl, a progress meter is shown per default. You can control the appearance via the keyword argument showProgress for simulate, simulateME, simulateCS and simulateSE.  Progress meters are also available for FMIFlux.jl, but deactivated by default (during training, this can be a bit too much). When evaluating a NeuralFMU, you can use the same keyword with showProgress=true to show a progress bar during training, too. The simulation trajectory (also called the solution of your FMU's ODE system) can be plotted using plot(solution), all axis will be labeled automatically.","category":"page"},{"location":"features/#Parallelization","page":"Features","title":"Parallelization","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"A native integrated support for multi-threaded and multi-process FMU-simulation (for example for Monte Carlo experiments) will be deployed soon. ","category":"page"},{"location":"related/#Related-Publications","page":"Related Publication","title":"Related Publications","text":"","category":"section"},{"location":"related/","page":"Related Publication","title":"Related Publication","text":"Tobias Thummerer, Josef Kircher, Lars Mikelsons 2021 NeuralFMU: Towards Structural Integration of FMUs into Neural Networks (14th Modelica Conference, Preprint, Accepted) arXiv:2109.04351","category":"page"},{"location":"related/","page":"Related Publication","title":"Related Publication","text":"Tobias Thummerer, Johannes Tintenherr, Lars Mikelsons 2021 Hybrid modeling of the human cardiovascular system using NeuralFMUs (10th International Conference on Mathematical Modeling in Physical Sciences, Preprint, Accepted) arXiv:2109.04880","category":"page"},{"location":"examples/multiple_instances/#Multiple-Instances-of-an-FMU","page":"Multiple instances","title":"Multiple Instances of an FMU","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"🚧 This tutorial is under revision and will be replaced by an up-to-date version soon 🚧","category":"page"},{"location":"examples/multiple_instances/#License","page":"Multiple instances","title":"License","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/multiple_instances/#Motivation","page":"Multiple instances","title":"Motivation","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/multiple_instances/#Introduction-to-the-example","page":"Multiple instances","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"In this example we want to show that it is possible to create different instances of an FMU. The different instances can then be used to run independent simulations. After the FMU has been simulated, the simulation results are displayed in a graph. The used model is a one-dimensional spring pendulum without friction. The object-orientated structure of the SpringPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"(Image: svg)  ","category":"page"},{"location":"examples/multiple_instances/#Target-group","page":"Multiple instances","title":"Target group","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/multiple_instances/#Other-formats","page":"Multiple instances","title":"Other formats","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/multiple_instances/#Getting-started","page":"Multiple instances","title":"Getting started","text":"","category":"section"},{"location":"examples/multiple_instances/#Installation-prerequisites","page":"Multiple instances","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install Plots via add Plots ","category":"page"},{"location":"examples/multiple_instances/#Code-section","page":"Multiple instances","title":"Code section","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots","category":"page"},{"location":"examples/multiple_instances/#Simulation-setup","page":"Multiple instances","title":"Simulation setup","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Next, the start time and end time of the simulation are set. Finally, the recorded values are specified to store the results of the simulation.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"tStart = 0.0\ntStop = 8.0\n\nvrs = [\"mass.s\"]","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"1-element Vector{String}:\n \"mass.s\"","category":"page"},{"location":"examples/multiple_instances/#Import-FMU","page":"Multiple instances","title":"Import FMU","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"SpringPendulum1D\", \"Dymola\", \"2022x\")\n\nmyFMU = loadFMU(pathToFMU)\ninfo(myFMU)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{fc15d8c4-758b-48e6-b00e-5bf47b8b14e5}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:23Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t0\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\n\n\tStates:\t\t\t\t2\n\t\t33554432 [\"mass.s\"]\n\t\t33554433 [\"mass.v\"]\n\tParameters:\t\t\t7\n\t\t16777216 [\"mass_s0\"]\n\t\t16777217 [\"mass_v0\"]\n\t\t16777218 [\"fixed.s0\"]\n\t\t16777219 [\"spring.c\"]\n\t\t16777220 [\"spring.s_rel0\"]\n\t\t16777221 [\"mass.m\"]\n\t\t16777222 [\"mass.L\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/multiple_instances/#First-Instance","page":"Multiple instances","title":"First Instance","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"To create an instance of the FMU it is necessary to call the command fmi2Instantiate!(). With the component address you now have a unique instance of the FMU.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"c1 = fmi2Instantiate!(myFMU; loggingOn=true)\ncomp1Address = c1.addr\nprintln(c1)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"FMU:            SpringPendulum1D\n    InstanceName:   SpringPendulum1D\n    Address:        Ptr{Nothing} @0x0000021b7a1a5ca0\n    State:          0\n    Logging:        true\n    FMU time:       -Inf\n    FMU states:     nothing","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Next, a dictionary for the parameters is created. With this dictionary you can set the initial states of the variables of the FMU. For the spring constant spring.c a value of 100 fracNm and for the position of the mass mass.s a value of 10 m is set. The created dictionary with the specified variables for recording are passed to the command for simulation. In addition, other keywords are set. On the one hand the keyword instantiate=false is set, which prevents that in the simulation command a new instance is created. On the other hand the keyword freeInstance=false is set, this prevents that after the simulation command the instance is released. ","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"param1 = Dict(\"spring.c\"=>10.0, \"mass_s0\"=>1.0)\ndata1 = simulate(c1, (tStart, tStop); parameters=param1, recordValues=vrs, instantiate=false, freeInstance=false)\nfig = plot(data1)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"For control, you can compare again the address of the instance to the previous address, and it should be the same address. As soon as this is not the case an error would be thrown by the macro @assert.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"@assert c1.addr === comp1Address","category":"page"},{"location":"examples/multiple_instances/#Second-Instance","page":"Multiple instances","title":"Second Instance","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"To create a second instance of the FMU it is necessary to call the command fmi2Instantiate!(). With the component address you now have a unique instance of the FMU.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"c2 = fmi2Instantiate!(myFMU; loggingOn=true)\ncomp2Address = c2.addr\nprintln(c2)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"FMU:            SpringPendulum1D\n    InstanceName:   SpringPendulum1D\n    Address:        Ptr{Nothing} @0x0000021b7a1a73d0\n    State:          0\n    Logging:        true\n    FMU time:       -Inf\n    FMU states:     nothing","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"The addresses of the instantiated FMUs must differ, and you can see that in the comparison below.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"@assert comp1Address !== comp2Address","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Again, a dictionary for the parameters is created. With this dictionary you can set the initial states of the variables of the FMU. For the spring constant spring.c a value of 10 fracNm and for the position of the mass mass.s a value of 20 m is set. The created dictionary with the specified variables for recording are passed to the command for simulation. As before, the two keywords instantiate=false and freeInstance=false are set.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"param2 = Dict(\"spring.c\"=>1.0, \"mass.s\"=>2.0)\ndata2 = simulateCS(c2, (tStart, tStop);  parameters=param2, recordValues=vrs, instantiate=false, freeInstance=false)\nplot!(fig, data2)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"For control, you can compare again the address of the instance comp2 to the previous address comp2Address and it should be the same address.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"@assert c2.addr === comp2Address","category":"page"},{"location":"examples/multiple_instances/#Unload-FMU","page":"Multiple instances","title":"Unload FMU","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"unloadFMU(myFMU)","category":"page"},{"location":"examples/multiple_instances/#Summary","page":"Multiple instances","title":"Summary","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Based on the example it can be seen that it is possible to create different instances of an FMU. The different instances can then be used to perform different simulations.","category":"page"},{"location":"examples/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"This section discusses the included examples of the FMI.jl library. If you require further information about the function calls, see the function sections of the library.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Examples are subdevided into Basics, Advanced, Pluto workshops and Publication appendices.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Basic examples:","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Simulate: Showing how you can simulate a CS-FMU and a ME-FMU.\nParameterize: A short example explaining how to parameterize a FMU before simulation.\nInputs: A short example explaining how to simulate a FMU with inputs.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Advanced examples:","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Parameter Optimization: An introduction on how FMU parameters can be optimized to fit a specific behaviour.\nMultiple instances: Showing the use of multiple FMU instances.\nManipulation: Showing how to redefine a linked C-library function of FMU.\nMultithreading: Shows how to use multithreading to simulate multiple FMUs.\nMultiprocessing: Shows how to use multiprocessing to simulate multiple FMUs.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Pluto workshops:","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Pluto workshops: Pluto based notebooks, that can easyly be executed on your own Pluto-Setup.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Publication appendices:","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Modelica conference 2021: Showing the different variants of simulating an FMU.","category":"page"},{"location":"fmi-tool-info/#FMU-Import-Compatibility-information-(*FMIImport.jl*)","page":"FMI Tool Information","title":"FMU Import Compatibility information (FMIImport.jl)","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"This section contains information about how import and simulation of FMI.jl and FMIInmport.jl where tested.","category":"page"},{"location":"fmi-tool-info/#FMI-3.0","page":"FMI Tool Information","title":"FMI-3.0","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"FMI3 is for now only beta supported and information will be deployed together with the full support release.","category":"page"},{"location":"fmi-tool-info/#FMI-2.0","page":"FMI Tool Information","title":"FMI-2.0","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"FMI.jl and FMIImport.jl are validated by simulating all valid FMI2-FMUs from the official FMI-Cross-Check in ME- as well as in CS-Mode, excluding the tools AMESim, Test-FMUs, SimulationX and Silver. For more information see our automated GitHub-Action. The results files - as defined by the FMI Cross Check - can be found in the forked repository inside of the corresponding sub folders.  There are different branches for different OS-configurations available.","category":"page"},{"location":"fmi-tool-info/#FMU-Export-Compatibility-information-(*FMIExport.jl*)","page":"FMI Tool Information","title":"FMU Export Compatibility information (FMIExport.jl)","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"Detailed export information and automatically generated FMUs will be deployed soon in the repository.","category":"page"},{"location":"fmi-tool-info/#FMI-3.0-2","page":"FMI Tool Information","title":"FMI-3.0","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"File name x86_64-windows x86_64-linux\nBouncingBall coming soon coming soon\nManipulation coming soon coming soon\nNeuralFMU coming soon coming soon","category":"page"},{"location":"fmi-tool-info/#FMI-2.0-2","page":"FMI Tool Information","title":"FMI-2.0","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"File name x86_64-windows x86_64-linux\nBouncingBall ME coming soon\nManipulation ME coming soon\nNeuralFMU ME coming soon","category":"page"},{"location":"fmi-tool-info/#Validation-tools","page":"FMI Tool Information","title":"Validation tools","text":"","category":"section"},{"location":"fmi-tool-info/","page":"FMI Tool Information","title":"FMI Tool Information","text":"Dassault Dymola 2022X\nFMU Check","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This list some common - often numerical - errors, that can be fixed by better understanding the ODE-Problem inside your FMU.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"faq/#Solving-non-linear-system-fails","page":"FAQ","title":"Solving non-linear system fails","text":"","category":"section"},{"location":"faq/#Description","page":"FAQ","title":"Description","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Error message or warning, that solving of a non-linear system failed, close to the simulation start time.","category":"page"},{"location":"faq/#Example","page":"FAQ","title":"Example","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Solving non-linear system 101 failed at time=3e-05.","category":"page"},{"location":"faq/#Reason","page":"FAQ","title":"Reason","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This could be, because the first step of the integration is accepted by the solver's error estimation, but shouldn't. This is usually, if the first step is picked to large by the solver's start step size heuristics.","category":"page"},{"location":"faq/#Fix","page":"FAQ","title":"Fix","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Try a small start value for the integration with keyword dt.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"faq/#Access-denied","page":"FAQ","title":"Access denied","text":"","category":"section"},{"location":"faq/#Description-2","page":"FAQ","title":"Description","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Error message, that the binary for callback functions can't be accessed/opened.","category":"page"},{"location":"faq/#Example-2","page":"FAQ","title":"Example","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"ERROR:\ncould not load library \"...\\src\\FMI2\\callbackFunctions\\binaries\\win64\\callbackFunctions.dll\"\nAccess denied","category":"page"},{"location":"faq/#Reason-2","page":"FAQ","title":"Reason","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This is because your OS doesn't allow to interact with the binaries shipped with FMI.jl. ","category":"page"},{"location":"faq/#Fix-2","page":"FAQ","title":"Fix","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This can easily be solved by fixing the binary's permission options or is automatically fixed if Julia runs with admin privileges.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"faq/#Double-Callback-Crossing","page":"FAQ","title":"Double Callback Crossing","text":"","category":"section"},{"location":"faq/#Description-3","page":"FAQ","title":"Description","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Error message, that solving failed because of double callback crossing.","category":"page"},{"location":"faq/#Example-3","page":"FAQ","title":"Example","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"ERROR:\nDouble callback crossing floating pointer reducer errored. Report this issue.","category":"page"},{"location":"faq/#Reason-3","page":"FAQ","title":"Reason","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This is because the event instant (time point) of an FMU event indicator can't be found precisely.","category":"page"},{"location":"faq/#Fix-3","page":"FAQ","title":"Fix","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This can be solved by allowing for more interpolation points during searching of the zero crossing:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"fmu.executionConfig.rootSearchInterpolationPoints = 1000 # default value is 10","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This will have negative performance impact on systems with extreme amount of events (thousands per second).  For systems with only a few events there won't be a noticeable slow down.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/#Working-with-the-FMI-model-description","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"section"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"The FMI model description provides all human readable information on the model. The following functions can be used to obtain all information provided by the model description, which in turn can be extracted from the fmu.","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/#Loading/Parsing","page":"Working with the FMI model description","title":"Loading/Parsing","text":"","category":"section"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi3LoadModelDescription","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/#general-information-about-the-FMU","page":"Working with the FMI model description","title":"general information about the FMU","text":"","category":"section"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi3GetGenerationTool fmi3GetGenerationDateAndTime","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/#technical-information-about-the-FMU","page":"Working with the FMI model description","title":"technical information about the FMU","text":"","category":"section"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi3GetVersion\n\nfmi3GetNumberOfEventIndicators\nfmi3GetNumberOfEventIndicators!","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/#FMICore.fmi3GetVersion","page":"Working with the FMI model description","title":"FMICore.fmi3GetVersion","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.4. Inquire Version Number of Header Files\n\nThis function returns fmi3Version of the fmi3Functions.h header file which was used to compile the functions of the FMU. This function call is allowed always and in all interface types.\n\nThe standard header file as documented in this specification has version \"3.0-beta.2\", so this function returns \"3.0-beta.2\".\n\n\n\n\n\nfmi3GetVersion(fmu::FMU3)\n\nArguments\n\nfmu::FMU3: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.\n\nReturns\n\nReturns a string from the address of a C-style (NUL-terminated) string. The string represents the version of the “fmi3Functions.h” header file which was used to compile the functions of the FMU. The function returns “fmiVersion” which is defined in this header file. The standard header file as documented in this specification has version “3.0”\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4. Inquire Version Number of Header Files\n\n\n\n\n\nfunction fmi3GetVersion(fmu::FMU3)\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nReturns a string from the address of a C-style (NUL-terminated) string. The string represents the version of the “fmi3Functions.h” header file which was used to compile the functions of the FMU. The function returns “fmiVersion” which is defined in this header file. The standard header file as documented in this specification has version “3.0”\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4. Inquire Version Number of Header Files\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_modeldescription_functions/#FMIImport.fmi3GetNumberOfEventIndicators","page":"Working with the FMI model description","title":"FMIImport.fmi3GetNumberOfEventIndicators","text":"fmi3GetNumberOfEventIndicators(c::FMU3Instance)\n\nThis function returns the number of event indicators. This function can only be called in Model Exchange. \n\nfmi3GetNumberOfEventIndicators must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nsize::Integer: Return size is the number of event indicators of this instance \n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3GetNumberOfEventIndicators.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_modeldescription_functions/#FMICore.fmi3GetNumberOfEventIndicators!","page":"Working with the FMI model description","title":"FMICore.fmi3GetNumberOfEventIndicators!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.2. State: Instantiated\n\nThis function returns the number of event indicators. This function can only be called in Model Exchange. \n\nfmi3GetNumberOfEventIndicators must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.\n\n\n\n\n\nfmi3GetNumberOfEventIndicators!(c::FMU3Instance, nEventIndicators::Ref{Csize_t})\n\nThis function returns the number of event indicators. This function can only be called in Model Exchange. \n\nfmi3GetNumberOfEventIndicators must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nnEventIndicators::Ref{Csize_t}: Stores the number of continuous states returned by the function\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3GetNumberOfEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_modeldescription_functions/#FMU-capabilities","page":"Working with the FMI model description","title":"FMU capabilities","text":"","category":"section"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"","category":"page"},{"location":"fmi3_lowlevel_modeldescription_functions/","page":"Working with the FMI model description","title":"Working with the FMI model description","text":"fmi3CanGetSetState fmi3CanSerializeFMUState","category":"page"},{"location":"fmi3_lowlevel_ME_functions/#FMI-for-Model-Exchange","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"","category":"section"},{"location":"fmi3_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"This chapter contains the interface description to access the equations of a dynamic system from a C program.","category":"page"},{"location":"fmi3_lowlevel_ME_functions/#Providing-Independent-Variables-and-Re-initialization-of-Caching","page":"FMI for Model Exchange","title":"Providing Independent Variables and Re-initialization of Caching","text":"","category":"section"},{"location":"fmi3_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"Depending on the situation, different variables need to be computed. In order to be efficient, it is important that the interface requires only the computation of variables that are needed in the present context. The state derivatives shall be reused from the previous call. This feature is called “caching of variables” in the sequel. Caching requires that the model evaluation can detect when the input arguments, like time or states, have changed.","category":"page"},{"location":"fmi3_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"fmi3SetTime\nfmi3SetContinuousStates\nfmi3GetEventIndicators\nfmi3GetEventIndicators!","category":"page"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3SetTime","page":"FMI for Model Exchange","title":"FMICore.fmi3SetTime","text":"Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode\n\nSet a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).\n\n\n\n\n\nfmi3SetTime(c::FMU3Instance, time::fmi3Float64)\n\nSet a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\ntime::fmi3Float64: Argument time contains a value of type fmi3Float64 which is a alias type for Real data type. time sets the independent variable time t.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3SetTime.\n\n\n\n\n\nfmi3SetTime(c::FMU3Instance, time::Real)\n\nSet a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nt::Real: Argument t contains a value of type Real which is a alias type for Real data type. time sets the independent variable time t.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3SetTime.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3SetContinuousStates","page":"FMI for Model Exchange","title":"FMICore.fmi3SetContinuousStates","text":"Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode\n\nSet a new (continuous) state vector and re-initialize caching of variables that depend on the states. Argument nx is the length of vector x and is provided for checking purposes\n\n\n\n\n\nfmi3SetContinuousStates(c::FMU3Instance,\n    x::AbstractArray{fmi3Float64},\n    nx::Csize_t)\n\nSet a new (continuous) state vector and re-initialize caching of variables that depend on the states. Argument nx is the length of vector x and is provided for checking purposes\n\nIf fmi3UpdateDiscreteStates returned with nominalsOfContinuousStatesChanged == fmi3True, then at least one nominal value of the states has changed and can be inquired with fmi3GetNominalsOfContinuousStates. Not allowed in Co-Simulation and Scheduled Execution.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx::AbstractArray{fmi3Float64}: Argument x contains values of type fmi3Float64 which is a alias type for Real data type. x is the AbstractArray which contains the Real values of the vector that represent the nominal values of the continuous states.\nnx::Csize_t: Argument nx defines the length of vector x and is provided for checking purposes\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3SetContinuousStates.\n\n\n\n\n\nfmi3SetContinuousStates(c::FMU3Instance, x::Union{AbstractArray{Float32}, AbstractArray{Float64}})\n\nSet a new (continuous) state vector and re-initialize caching of variables that depend on the states. Argument nx is the length of vector x and is provided for checking purposes\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx::Union{AbstractArray{Float32},AbstractArray{Float64}}:Argument x is the AbstractArray of the vector values of Float64 or Float32.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3SetContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMIImport.fmi3GetEventIndicators","page":"FMI for Model Exchange","title":"FMIImport.fmi3GetEventIndicators","text":"fmi3GetEventIndicators(c::FMU3Instance)\n\nReturns the event indicators of the FMU\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\neventIndicators::Array{fmi3Float64}:The event indicators are returned as a vector represented by an array of \"fmi3Float64\" values.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3GetEventIndicators.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3GetEventIndicators!","page":"FMI for Model Exchange","title":"FMICore.fmi3GetEventIndicators!","text":"Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode\n\nCompute event indicators at the current time instant and for the current states. EventIndicators signal Events by their sign change.\n\n\n\n\n\nfmi3GetEventIndicators!(c::FMU3Instance, eventIndicators::AbstractArray{fmi3Float64}, ni::Csize_t)\n\nCompute event indicators at the current time instant and for the current states. EventIndicators signal Events by their sign change.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\neventIndicators::AbstractArray{fmi3Float64}: Argument eventIndicators contains values of type fmi3Float64 which is a alias type for Real data type.eventIndicators is the AbstractArray which contains the Real values of the vector that represent the event indicators.\nni::Csize_t: Argument ni defines the length of vector eventIndicators and is provided for checking purposes\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3GetEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#Evaluation-of-Model-Equations","page":"FMI for Model Exchange","title":"Evaluation of Model Equations","text":"","category":"section"},{"location":"fmi3_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"fmi3EnterEventMode\nfmi3EnterContinuousTimeMode\nfmi3CompletedIntegratorStep!\nfmi3GetContinuousStates\nfmi3GetContinuousStates!\nfmi3GetNominalsOfContinuousStates!\nfmi3GetNumberOfContinuousStates\nfmi3GetNumberOfContinuousStates!","category":"page"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3EnterEventMode","page":"FMI for Model Exchange","title":"FMICore.fmi3EnterEventMode","text":"Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode\n\nThe model enters Event Mode from the Continuous-Time Mode in ModelExchange oder Step Mode in CoSimulation and discrete-time equations may become active (and relations are not “frozen”).\n\n\n\n\n\nfmi3EnterEventMode(c::FMU3Instance, stepEvent::fmi3Boolean, stateEvent::fmi3Boolean, rootsFound::AbstractArray{fmi3Int32}, nEventIndicators::Csize_t, timeEvent::fmi3Boolean; soft::Bool=false)\n\nThe model enters Event Mode from the Continuous-Time Mode in ModelExchange oder Step Mode in CoSimulation and discrete-time equations may become active (and relations are not “frozen”).\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nstepEvent::fmi3Boolean: \nstateEvent::fmi3Boolean: \nrootsFound::AbstractArray{fmi3Int32}: \nnEventIndicators::Csize_t: \ntimeEvent::fmi3Boolean: \nsoft::Bool=false: \n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state  fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3EnterEventMode.\n\n\n\n\n\nfmi3EnterEventMode(c::FMU3Instance, stepEvent::Bool, stateEvent::Bool, rootsFound::AbstractArray{fmi3Int32}, nEventIndicators::Csize_t, timeEvent::Bool)\n\nThe model enters Event Mode from the Continuous-Time Mode in ModelExchange oder Step Mode in CoSimulation and discrete-time equations may become active (and relations are not “frozen”).\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nstepEvent::Bool:  \nstateEvent::Bool: \nrootsFound::AbstractArray{fmi3Int32}: \nnEventIndicators::Csize_t: \ntimeEvent::Bool: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3EnterEventMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3EnterContinuousTimeMode","page":"FMI for Model Exchange","title":"FMICore.fmi3EnterContinuousTimeMode","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.5. State: Event Mode\n\nThe model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are “frozen”. This function has to be called when changing from Event Mode (after the global event iteration in Event Mode over all involved FMUs and other models has converged) into Continuous-Time Mode.\n\n\n\n\n\nfmi3EnterContinuousTimeMode(c::FMU3Instance; soft::Bool=false)\n\nThe model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are “frozen”. This function has to be called when changing from Event Mode (after the global event iteration in Event Mode over all involved FMUs and other models has converged) into Continuous-Time Mode.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state  fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.5. State: Event Mode\n\nSee also fmi3EnterContinuousTimeMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3CompletedIntegratorStep!","page":"FMI for Model Exchange","title":"FMICore.fmi3CompletedIntegratorStep!","text":"Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode\n\nThis function must be called by the environment after every completed step of the integrator provided the capability flag needsCompletedIntegratorStep = true. If enterEventMode == fmi3True, the event mode must be entered If terminateSimulation == fmi3True, the simulation shall be terminated\n\n\n\n\n\nfmi3CompletedIntegratorStep!(c::FMU3Instance,\n                                  noSetFMUStatePriorToCurrentPoint::fmi3Boolean,\n                                  enterEventMode::Ref{fmi3Boolean},\n                                  terminateSimulation::Ref{fmi3Boolean})\n\nThis function must be called by the environment after every completed step of the integrator provided the capability flag needsCompletedIntegratorStep == true. If enterEventMode == fmi3True, the event mode must be entered If terminateSimulation == fmi3True, the simulation shall be terminated\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nnoSetFMUStatePriorToCurrentPoint::fmi3Boolean: Argument noSetFMUStatePriorToCurrentPoint = fmi3True if fmi3SetFMUState  will no longer be called for time instants prior to current time in this simulation run.\nenterEventMode::Ref{fmi3Boolean}: Argument enterEventMode points to the return value (fmi3Boolean) which signals to the environment if the FMU shall call fmi3EnterEventMode. fmi3Boolean is an alias type for Boolean data type.\nterminateSimulation::Ref{fmi3Boolean}: Argument terminateSimulation points to the return value (fmi3Boolean) which signals signal if the simulation shall be terminated. fmi3Boolean is an alias type for Boolean data type.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3CompletedIntegratorStep!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMIImport.fmi3GetContinuousStates","page":"FMI for Model Exchange","title":"FMIImport.fmi3GetContinuousStates","text":"fmi3GetContinuousStates(c::FMU3Instance)\n\nReturn the new (continuous) state vector x\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nx::Array{fmi3Float64}: Returns an array of fmi3Float64 values representing the new continuous state vector x.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.3.3. State: Initialization Mode\n\nSee also fmi3GetContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3GetContinuousStates!","page":"FMI for Model Exchange","title":"FMICore.fmi3GetContinuousStates!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.3. State: Initialization Mode\n\nReturn the states at the current time instant.\n\nThis function must be called if fmi3UpdateDiscreteStates returned with valuesOfContinuousStatesChanged == fmi3True. Not allowed in Co-Simulation and Scheduled Execution.\n\n\n\n\n\nfmi3GetContinuousStates!(c::FMU3Instance, nominals::AbstractArray{fmi3Float64}, nContinuousStates::Csize_t)\n\nReturn the states at the current time instant.\n\nThis function must be called if fmi3UpdateDiscreteStates returned with valuesOfContinuousStatesChanged == fmi3True. Not allowed in Co-Simulation and Scheduled Execution.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nnominals::AbstractArray{fmi3Float64}: Argument nominals contains values of type fmi3Float64 which is a alias type for Real data type. nominals is the AbstractArray which contains the Real values of the vector that represent the new state vector.\nnContinuousStates::Csize_t: Argument nContinuousStates defines the length of vector nominals and is provided for checking purposes\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.3. State: Initialization Mode\n\nSee also fmi3GetContinuousStates!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3GetNominalsOfContinuousStates!","page":"FMI for Model Exchange","title":"FMICore.fmi3GetNominalsOfContinuousStates!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.3. State: Initialization Mode\n\nReturn the nominal values of the continuous states.\n\nIf fmi3UpdateDiscreteStates returned with nominalsOfContinuousStatesChanged == fmi3True, then at least one nominal value of the states has changed and can be inquired with fmi3GetNominalsOfContinuousStates. Not allowed in Co-Simulation and Scheduled Execution.\n\n\n\n\n\nfmi3GetNominalsOfContinuousStates!(c::FMU3Instance, x_nominal::AbstractArray{fmi3Float64}, nx::Csize_t)\n\nReturn the nominal values of the continuous states.\n\nIf fmi3UpdateDiscreteStates returned with nominalsOfContinuousStatesChanged == fmi3True, then at least one nominal value of the states has changed and can be inquired with fmi3GetNominalsOfContinuousStates. Not allowed in Co-Simulation and Scheduled Execution.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx_nominal::AbstractArray{fmi3Float64}: Argument x_nominal contains values of type fmi3Float64 which is a alias type for Real data type. x_nominal is the AbstractArray which contains the Real values of the vector that represent the nominal values of the continuous states.\nnx::Csize_t: Argument nx defines the length of vector x_nominal and is provided for checking purposes\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.3. State: Initialization Mode\n\nSee also fmi3GetNominalsOfContinuousStates!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMIImport.fmi3GetNumberOfContinuousStates","page":"FMI for Model Exchange","title":"FMIImport.fmi3GetNumberOfContinuousStates","text":"fmi3GetNumberOfContinuousStates(c::FMU3Instance)\n\nThis function returns the number of continuous states. This function can only be called in Model Exchange. \n\nfmi3GetNumberOfContinuousStates must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nsize::Integer: Return size is the number of continuous states of this instance \n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3GetNumberOfContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/#FMICore.fmi3GetNumberOfContinuousStates!","page":"FMI for Model Exchange","title":"FMICore.fmi3GetNumberOfContinuousStates!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.2. State: Instantiated\n\nThis function returns the number of continuous states. This function can only be called in Model Exchange. \n\nfmi3GetNumberOfContinuousStates must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.\n\n\n\n\n\nfmi3GetNumberOfContinuousStates!(c::FMU3Instance, nContinuousStates::Ref{Csize_t})\n\nThis function returns the number of continuous states. This function can only be called in Model Exchange. \n\nfmi3GetNumberOfContinuousStates must be called after a structural parameter is changed. As long as no structural parameters changed, the number of states is given in the modelDescription.xml, alleviating the need to call this function.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nnContinuousStates::Ref{Csize_t}: Stores the number of continuous states returned by the function\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3GetNumberOfContinuousStates!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"fmi3CompletedIntegratorStep","category":"page"},{"location":"examples/inputs/#Simulate-an-FMU-with-inputs","page":"Inputs","title":"Simulate an FMU with inputs","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"Tutorial by Tobias Thummerer","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"🚧 This tutorial is under revision and will be replaced by an up-to-date version soon 🚧","category":"page"},{"location":"examples/inputs/#License","page":"Inputs","title":"License","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/inputs/#Introduction-to-the-example","page":"Inputs","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"This example shows how to add custom inputs to a FMU, that are used during simulation.","category":"page"},{"location":"examples/inputs/#Other-formats","page":"Inputs","title":"Other formats","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/inputs/#Code-section","page":"Inputs","title":"Code section","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots\nusing DifferentialEquations","category":"page"},{"location":"examples/inputs/#Simulation-setup","page":"Inputs","title":"Simulation setup","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"Next, the start time and end time of the simulation are set. Finally, a step size is specified to store the results of the simulation at these time steps.","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"tStart = 0.0\ntStep = 0.01\ntStop = 8.0\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"0.0:0.01:8.0","category":"page"},{"location":"examples/inputs/#Import-FMU","page":"Inputs","title":"Import FMU","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"Next, the FMU model from FMIZoo.jl is loaded.","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"# we use an FMU from the FMIZoo.jl\nfmu = loadFMU(\"SpringPendulumExtForce1D\", \"Dymola\", \"2022x\"; type=:ME) # load FMU in ME-Mode (\"Model Exchange\")","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"Model name:\tSpringPendulumExtForce1D\nType:\t\t0","category":"page"},{"location":"examples/inputs/#Simulate-as-Model-Exchange","page":"Inputs","title":"Simulate as Model-Exchange","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"In the function simulate() the FMU is simulated with an adaptive step size but with fixed save points tSave. In addition, the start and end time are specified. Note, that the dynamics of the input variables are not considered by the steps ize control of the solver, so it is highly recommended to limit the solver step size with the keyword argument dtmax if the input is more dynamic than the system.","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"# input function format \"t\", dependent on `t` (time)\nfunction extForce_t(t::Real, u::AbstractArray{<:Real})\n    u[1] = sin(t)\nend \n\n# simulate while setting inputs\ndata_extForce_t = simulate(fmu, (tStart, tStop);                 # FMU, start and stop time\n                          solver = Tsit5(),\n                          saveat=tSave,                         # timepoints for the ODE solution to be saved\n                          inputValueReferences=[\"extForce\"],    # the value references that should be set (inputs)\n                          inputFunction=extForce_t,             # the input function to be used\n                          dtmax=1e-2,                           # limit max step size to capture inputs\n                          showProgress=false)                   # disable progress bar\nplot(data_extForce_t)","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"# input function format \"cxt\", dependent on `c` (component), `x` (state) and `t` (time)\nfunction extForce_cxt(c::Union{FMU2Component, Nothing}, x::Union{AbstractArray{<:Real}, Nothing}, t::Real, u::AbstractArray{<:Real})\n    x1 = 0.0\n    if x != nothing # this check is important, because inputs may be needed before the system state is known\n        x1 = x[1] \n    end\n    u[1] = sin(t) * x1\n    nothing\nend \n\n# simulate while setting inputs\ndata_extForce_cxt = simulate(fmu, (tStart, tStop); saveat=tSave, inputValueReferences=[\"extForce\"], inputFunction=extForce_cxt, dtmax=1e-2, showProgress=false)\nplot(data_extForce_cxt)","category":"page"},{"location":"examples/inputs/#Unload-FMU","page":"Inputs","title":"Unload FMU","text":"","category":"section"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/inputs/","page":"Inputs","title":"Inputs","text":"unloadFMU(fmu)","category":"page"},{"location":"deprecated/#deprecated-Functions","page":"Deprecated","title":"deprecated Functions","text":"","category":"section"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"this doc page is necessary as all exported functions must be documented in the manual with documenter configured to check for missing documentation, therefor this hidden page exists","category":"page"},{"location":"deprecated/#internal-functions:-remove-export?","page":"Deprecated","title":"internal functions: remove export?","text":"","category":"section"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"fmi2CallbackFunctions","category":"page"},{"location":"deprecated/#FMICore.fmi2CallbackFunctions","page":"Deprecated","title":"FMICore.fmi2CallbackFunctions","text":"Source: FMISpec2.0.2[p.19-22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nThe struct contains pointers to functions provided by the environment to be used by the FMU. It is not allowed to change these functions between fmi2Instantiate(..) and fmi2Terminate(..) calls. Additionally, a pointer to the environment is provided (componentEnvironment) that needs to be passed to the “logger” function, in order that the logger function can utilize data from the environment, such as mapping a valueReference to a string. In the unlikely case that fmi2Component is also needed in the logger, it has to be passed via argument componentEnvironment. Argument componentEnvironment may be a null pointer. The componentEnvironment pointer is also passed to the stepFinished(..) function in order that the environment can provide an efficient way to identify the slave that called stepFinished(..).\n\n\n\n\n\n","category":"type"},{"location":"deprecated/#deprecated","page":"Deprecated","title":"deprecated","text":"","category":"section"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"Mostly wrappers that are not supposed to be used (call specific wrapped functions instead)","category":"page"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"all gone since 0.14.0 (nice)","category":"page"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"","category":"page"},{"location":"examples/multithreading/#Multithreading","page":"Multithreading","title":"Multithreading","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Tutorial by Jonas Wilfert, Tobias Thummerer","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"🚧 This tutorial is under revision and will be replaced by an up-to-date version soon 🚧","category":"page"},{"location":"examples/multithreading/#License","page":"Multithreading","title":"License","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar, Jonas Wilfert\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/multithreading/#Motivation","page":"Multithreading","title":"Motivation","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/multithreading/#Introduction-to-the-example","page":"Multithreading","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"This example shows how to parallelize the computation of an FMU in FMI.jl. We can compute a batch of FMU-evaluations in parallel with different initial settings. Parallelization can be achieved using multithreading or using multiprocessing. This example shows multithreading, check multiprocessing.ipynb for multiprocessing. Advantage of multithreading is a lower communication overhead as well as lower RAM usage. However in some cases multiprocessing can be faster as the garbage collector is not shared.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"The model used is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"(Image: svg)  ","category":"page"},{"location":"examples/multithreading/#Target-group","page":"Multithreading","title":"Target group","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/multithreading/#Other-formats","page":"Multithreading","title":"Other formats","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/multithreading/#Getting-started","page":"Multithreading","title":"Getting started","text":"","category":"section"},{"location":"examples/multithreading/#Installation-prerequisites","page":"Multithreading","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install FMICore via add FMICore add \" https://github.com/ThummeTo/FMICore.jl \"\n5. Install Folds via add Folds \n6. Install BenchmarkTools via add BenchmarkTools ","category":"page"},{"location":"examples/multithreading/#Code-section","page":"Multithreading","title":"Code section","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"# imports\nusing FMI\nusing FMIZoo\nusing Folds\nusing BenchmarkTools\nusing DifferentialEquations","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"First, check the amount of available threads:","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Threads.nthreads()","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"1","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"If the number of available threads doesn't match your expections, you can increase the number of threads available to the Julia process like described here.","category":"page"},{"location":"examples/multithreading/#Simulation-setup","page":"Multithreading","title":"Simulation setup","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Next, the start time and end time of the simulation are set. Here we also decide the size of the batch.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"t_start = 0.0\nt_step = 0.1\nt_stop = 10.0\ntspan = (t_start, t_stop)\ntData = collect(t_start:t_step:t_stop)\n\n# Best if batchSize is a multiple of the threads/cores\nbatchSize = Threads.nthreads()\n\n# Define an array of arrays randomly\ninput_values = collect(collect.(eachrow(rand(batchSize,2))))\n","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"1-element Vector{Vector{Float64}}:\n [0.8900690631855165, 0.634523640860326]","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"We need to instantiate one FMU for each parallel execution, as they cannot be easily shared among different threads.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"# a single FMU to compare the performance\nrealFMU = loadFMU(\"SpringPendulum1D\", \"Dymola\", \"2022x\")\n\n# the FMU batch\nrealFMUBatch = [loadFMU(\"SpringPendulum1D\", \"Dymola\", \"2022x\") for _ in 1:batchSize]","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"1-element Vector{FMU2}:\n Model name:\tSpringPendulum1D\nType:\t\t1","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"We define a helper function to calculate the FMU solution and combine it into an Matrix.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"function runCalcFormatted(fmu::FMU2, x0::Vector{Float64}, recordValues::Vector{String}=[\"mass.s\", \"mass.v\"])\n    data = simulateME(fmu, tspan; recordValues=recordValues, saveat=tData, x0=x0, showProgress=false, dtmax=1e-4)\n    return reduce(hcat, data.states.u)\nend","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"runCalcFormatted (generic function with 2 methods)","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Running a single evaluation is pretty quick, therefore the speed can be better tested with BenchmarkTools.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"@benchmark data = runCalcFormatted(realFMU, rand(2))","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"BenchmarkTools.Trial: 2 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m3.142 s\u001b[22m\u001b[39m … \u001b[35m   3.465 s\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m0.75% … 7.66%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m3.304 s               \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m4.37%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m3.304 s\u001b[22m\u001b[39m ± \u001b[32m227.901 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m4.37% ± 4.89%\n\n  \u001b[34m█\u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \n  \u001b[34m█\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[32m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m \u001b[39m▁\n  3.14 s\u001b[90m         Histogram: frequency by time\u001b[39m         3.46 s \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m300.76 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m7603698\u001b[39m.","category":"page"},{"location":"examples/multithreading/#Single-Threaded-Batch-Execution","page":"Multithreading","title":"Single Threaded Batch Execution","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"To compute a batch we can collect multiple evaluations. In a single threaded context we can use the same FMU for every call.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"println(\"Single Threaded\")\n@benchmark collect(runCalcFormatted(realFMU, i) for i in input_values)","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Single Threaded\n\n\n\n\n\nBenchmarkTools.Trial: 2 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m3.137 s\u001b[22m\u001b[39m … \u001b[35m   3.496 s\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m0.54% … 8.34%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m3.316 s               \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m4.65%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m3.316 s\u001b[22m\u001b[39m ± \u001b[32m253.404 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m4.65% ± 5.52%\n\n  \u001b[34m█\u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \n  \u001b[34m█\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[32m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m \u001b[39m▁\n  3.14 s\u001b[90m         Histogram: frequency by time\u001b[39m          3.5 s \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m300.76 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m7603701\u001b[39m.","category":"page"},{"location":"examples/multithreading/#Multithreaded-Batch-Execution","page":"Multithreading","title":"Multithreaded Batch Execution","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"In a multithreaded context we have to provide each thread it's own fmu, as they are not thread safe. To spread the execution of a function to multiple threads, the library Folds can be used.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"println(\"Multi Threaded\")\n@benchmark Folds.collect(runCalcFormatted(fmu, i) for (fmu, i) in zip(realFMUBatch, input_values))","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Multi Threaded\n\n\n\n\n\nBenchmarkTools.Trial: 2 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m3.087 s\u001b[22m\u001b[39m … \u001b[35m   3.475 s\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m0.54% … 9.04%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m3.281 s               \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m5.04%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m3.281 s\u001b[22m\u001b[39m ± \u001b[32m274.575 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m5.04% ± 6.01%\n\n  \u001b[34m█\u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \n  \u001b[34m█\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[32m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m \u001b[39m▁\n  3.09 s\u001b[90m         Histogram: frequency by time\u001b[39m         3.48 s \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m300.76 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m7603716\u001b[39m.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"As you can see, there is a significant speed-up in the median execution time. But: The speed-up is often much smaller than Threads.nthreads(), this has different reasons. For a rule of thumb, the speed-up should be around n/2 on a n-core-processor with n threads for the Julia process.","category":"page"},{"location":"examples/multithreading/#Unload-FMU","page":"Multithreading","title":"Unload FMU","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"After calculating the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"unloadFMU(realFMU)\nunloadFMU.(realFMUBatch)","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"1-element Vector{Nothing}:\n nothing","category":"page"},{"location":"examples/multithreading/#Summary","page":"Multithreading","title":"Summary","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"In this tutorial it is shown how multi threading with Folds.jl can be used to improve the performance for calculating a Batch of FMUs.","category":"page"},{"location":"fmi2_lowlevel_library_constants/#FMI2-Types-in-FMI-Import/Core-.jl","page":"FMI2 Types in FMI Import/Core .jl","title":"FMI2 Types in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi2_lowlevel_library_constants/","page":"FMI2 Types in FMI Import/Core .jl","title":"FMI2 Types in FMI Import/Core .jl","text":"FMU2\nFMU2Component\nFMU2ComponentEnvironment\nFMI2Struct\nfmi2Initial\nfmi2ScalarVariable\nfmi2SimpleType\nfmi2Type\nfmi2BaseUnit\nfmi2Unit\nfmi2DisplayUnit\nfmi2Char\nfmi2Variability\nfmi2VariableDependency\nfmi2DependencyKind\nfmi2EventInfo\nfmi2Status\nfmi2Annotation\nfmi2ModelDescription\nfmi2FMUstate\nfmi2StatusKind\nfmi2VariableNamingConvention\nfmi2Causality\nfmi2ComponentState","category":"page"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.FMU2","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.FMU2","text":"The mutable struct representing a FMU (and a container for all its instances) in the FMI 2.0.2 Standard. Also contains the paths to the FMU and ZIP folder as well als all the FMI 2.0.2 function pointers.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.FMU2Component","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.FMU2Component","text":"The mutable struct represents an allocated instance of an FMU in the FMI 2.0.2 Standard.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.FMU2ComponentEnvironment","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.FMU2ComponentEnvironment","text":"Source: FMISpec 2.0.3 [p.16f]\n\nThis is a pointer to a data structure in the simulation environment that calls the FMU. Using this pointer, data from the modelDescription.xml file [(for example, mapping of valueReferences to variable names)] can be transferred between the simulation environment and the logger function (see [FMISpec 2.0.3] section 2.1.5).\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.FMI2Struct","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.FMI2Struct","text":"FMI2Struct\n\nA wildcard for FMI2 related structs, namely Union{FMU2, fmi2ModelDescription, FMU2Component}.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Initial","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Initial","text":"Source: FMISpec2.0.2[p.48]: 2.2.7 Definition of Model Variables (ModelVariables)\n\nEnumeration that defines how the variable is initialized. It is not allowed to provide a value for initial if causality = \"input\" or \"independent\":\n\n\"exact\": The variable is initialized with the start value (provided under Real, Integer, Boolean, String or Enumeration). \"approx\": The variable is an iteration variable of an algebraic loop and the iteration at initialization starts with the start value. \"calculated\": The variable is calculated from other variables during initialization. It is not allowed to provide a “start” value. If initial is not present, it is defined by the table below based on causality and variability. If initial = exact or approx, or causality = ″input″, a start value must be provided. If initial = calculated, or causality = ″independent″, it is not allowed to provide a start value. If fmiSetXXX is not called on a variable with causality = ″input″, then the FMU must use the start value as value of this input. Added prefix \"fmi2\" to help with redefinition of constans in enums.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2ScalarVariable","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2ScalarVariable","text":"Source: FMISpec2.0.2[p.46]: 2.2.7 Definition of Model Variables (ModelVariables)\n\nThe fmi2ScalarVariable specifies the type and argument of every exposed variable in the fmu\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2SimpleType","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2SimpleType","text":"Source: FMISpec2.0.3[p.40]: 2.2.3 Definition of Types (TypeDefinitions)\n\nThe fmi2SimpleType describes the attributes of a type definition.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Type","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Type","text":"Source: FMISpec2.0.2[p.19]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nArgument fmuType defines the type of the FMU:\n\nfmi2ModelExchange: FMU with initialization and events; between events simulation of continuous systems is performed with external integrators from the environment.\nfmi2CoSimulation: Black box interface for co-simulation.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2BaseUnit","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2BaseUnit","text":"Source: FMISpec2.0.3[p.35]: 2.2.2 Definition of Units (UnitDefinitions)\n\nfmi2BaseUnit(\n    kg=0, m=0, s=0, A=0, K=0, mol=0, cd=0, rad=0, factor=1.0, offset=0.0)\n\nType for the optional “BaseUnit” field of an fmi2Unit.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Unit","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Unit","text":"Source: FMISpec2.0.3[p.35]: 2.2.2 Definition of Units (UnitDefinitions)\n\nElement “UnitDefinitions ” of fmiModelDescription.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2DisplayUnit","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2DisplayUnit","text":"Source: FMISpec2.0.3[p.35]: 2.2.2 Definition of Units (UnitDefinitions)\n\nfmi2DisplayUnit(name, factor=1.0, offset=0.0)\n\nType for the optional “DisplayUnit” field(s) of an fmi2Unit.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Char","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Char","text":"Source: FMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nFMI2 Data Types To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section. All definitions in this section are provided in the header file “fmi2TypesPlatform.h”.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Variability","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Variability","text":"Source: FMISpec2.0.2[p.49]: 2.2.7 Definition of Model Variables (ModelVariables)\n\nEnumeration that defines the time dependency of the variable, in other words, it defines the time instants when a variable can change its value.\n\n\"constant\": The value of the variable never changes. \"fixed\": The value of the variable is fixed after initialization, in other words, after fmi2ExitInitializationMode was called the variable value does not change anymore. \"tunable\": The value of the variable is constant between external events (ModelExchange) and between Communication Points (Co-Simulation) due to changing variables with causality = \"parameter\" or \"input\" and variability = \"tunable\". Whenever a parameter or input signal with variability = \"tunable\" changes, an event is triggered externally (ModelExchange), or the change is performed at the next Communication Point (Co-Simulation) and the variables with variability = \"tunable\" and causality = \"calculatedParameter\" or \"output\" must be newly computed. \"discrete\": ModelExchange: The value of the variable is constant between external and internal events (= time, state, step events defined implicitly in the FMU). Co-Simulation: By convention, the variable is from a “real” sampled data system and its value is only changed at Communication Points (also inside the slave). \"continuous\": Only a variable of type = “Real” can be “continuous”. ModelExchange: No restrictions on value changes. Co-Simulation: By convention, the variable is from a differential The default is “continuous”. Added prefix \"fmi2\" to help with redefinition of constans in enums.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2VariableDependency","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2VariableDependency","text":"Mutable Struct representing existance and kind of dependencies of an Unknown on Known Variables in Continuous-Time and Event Mode (ME) and at Communication Points (CS)\n\nSee also FMI2.0.3 Spec fmi2VariableDependency [p.60]\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2DependencyKind","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2DependencyKind","text":"Types of dependency:\n\nfmi2DependencyKindDependent: no particular structure, f(v)\nfmi2DependencyKindConstant: constant factor, c*v (for Real valued variables only)\nfmi2DependencyKindFixed: tunable factor, p*v (for Real valued variables only)\nfmi2DependencyKindTunable [ToDo]\nfmi2DependencyKindDiscrete [ToDo]\n\nSource: FMI2.0.3 Spec for fmi2VariableDependency [p.60] \n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2EventInfo","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2EventInfo","text":"Source: FMISpec2.0.2[p.84]: 3.2.2 Evaluation of Model Equations\n\nIf return argument fmi2eventInfo.newDiscreteStatesNeeded = fmi2True, the FMU should stay in Event Mode, and the FMU requires to set new inputs to the FMU (fmi2SetXXX on inputs) to compute and get the outputs (fmi2GetXXX on outputs) and to call fmi2NewDiscreteStates again. Depending on the connection with other FMUs, the environment shall\n\ncall fmi2Terminate, if terminateSimulation = fmi2True is returned by at least one FMU.\ncall fmi2EnterContinuousTimeMode if all FMUs return newDiscreteStatesNeeded = fmi2False.\nstay in Event Mode otherwise.\n\nWhen the FMU is terminated, it is assumed that an appropriate message is printed by the logger function (see section 2.1.5) to explain the reason for the termination. If nominalsOfContinuousStatesChanged = fmi2True, then the nominal values of the states have changed due to the function call and can be inquired with fmi2GetNominalsOfContinuousStates. If valuesOfContinuousStatesChanged = fmi2True. then at least one element of the continuous state vector has changed its value due to the function call. The new values of the states can be retrieved with fmi2GetContinuousStates or individually for each state for which reinit = \"true\" by calling getReal. If no element of the continuous state vector has changed its value, valuesOfContinuousStatesChanged must return fmi2False. [If fmi2True would be returned in this case, an infinite event loop may occur.] If nextEventTimeDefined = fmi2True, then the simulation shall integrate at most until time = nextEventTime, and shall call fmi2EnterEventMode at this time instant. If integration is stopped before nextEventTime, for example, due to a state event, the definition of nextEventTime becomes obsolete.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Status","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Status","text":"Source: FMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nStatus returned by functions. The status has the following meaning:\n\nfmi2OK – all well\nfmi2Warning – things are not quite right, but the computation can continue. Function “logger” was called in the model (see below), and it is expected that this function has shown the prepared information message to the user.\nfmi2Discard – this return status is only possible if explicitly defined for the corresponding function\n\n(ModelExchange: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2SetContinuousStates, fmi2GetReal, fmi2GetDerivatives, fmi2GetContinuousStates, fmi2GetEventIndicators; CoSimulation: fmi2SetReal, fmi2SetInteger, fmi2SetBoolean, fmi2SetString, fmi2DoStep, fmiGetXXXStatus): For “model exchange”: It is recommended to perform a smaller step size and evaluate the model equations again, for example because an iterative solver in the model did not converge or because a function is outside of its domain (for example sqrt(<negative number>)). If this is not possible, the simulation has to be terminated. For “co-simulation”: fmi2Discard is returned also if the slave is not able to return the required status information. The master has to decide if the simulation run can be continued. In both cases, function “logger” was called in the FMU (see below) and it is expected that this function has shown the prepared information message to the user if the FMU was called in debug mode (loggingOn = fmi2True). Otherwise, “logger” should not show a message.\n\nfmi2Error – the FMU encountered an error. The simulation cannot be continued with this FMU instance. If one of the functions returns fmi2Error, it can be tried to restart the simulation from a formerly stored FMU state by calling fmi2SetFMUstate.\n\nThis can be done if the capability flag canGetAndSetFMUstate is true and fmi2GetFMUstate was called before in non-erroneous state. If not, the simulation cannot be continued and fmi2FreeInstance or fmi2Reset must be called afterwards.4 Further processing is possible after this call; especially other FMU instances are not affected. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user.\n\nfmi2Fatal – the model computations are irreparably corrupted for all FMU instances. [For example, due to a run-time exception such as access violation or integer division by zero during the execution of an fmi function]. Function “logger” was called in the FMU (see below), and it is expected that this function has shown the prepared information message to the user. It is not possible to call any other function for any of the FMU instances.\nfmi2Pending – this status is returned only from the co-simulation interface, if the slave executes the function in an asynchronous way. That means the slave starts to compute but returns immediately. The master has to call fmi2GetStatus(..., fmi2DoStepStatus) to determine if the slave has finished the computation. Can be returned only by fmi2DoStep and by fmi2GetStatus (see section 4.2.3).\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Annotation","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Annotation","text":"A not further specified annotation struct.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2ModelDescription","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2ModelDescription","text":"Source: FMISpec2.0.2[p.34]: 2.2.1 Definition of an FMU (fmiModelDescription)\n\nThe “ModelVariables” element of fmiModelDescription is the central part of the model description. It provides the static information of all exposed variables.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2FMUstate","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2FMUstate","text":"fmi2FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant. This allows to restart a simulation from a previous FMU state.\n\nSource: FMI2.0.3 Spec [p.17]; See also section 2.1.8\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2StatusKind","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2StatusKind","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nCoSimulation specific Enum representing state of FMU after fmi2DoStep returned fmi2Pending.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2VariableNamingConvention","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2VariableNamingConvention","text":"ToDo \n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2Causality","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2Causality","text":"Source: FMISpec2.0.2[p.48]: 2.2.7 Definition of Model Variables (ModelVariables)\n\nEnumeration that defines the causality of the variable. Allowed values of this enumeration:\n\n\"parameter\": Independent parameter (a data value that is constant during the simulation and is provided by the environment and cannot be used in connections). variability must be \"fixed\" or \"tunable\". initial must be exact or not present (meaning exact). \"calculatedParameter\": A data value that is constant during the simulation and is computed during initialization or when tunable parameters change. variability must be \"fixed\" or \"tunable\". initial must be \"approx\", \"calculated\" or not present (meaning calculated). \"input\": The variable value can be provided from another model or slave. It is not allowed to define initial. \"output\": The variable value can be used by another model or slave. The algebraic relationship to the inputs is defined via the dependencies attribute of <fmiModelDescription><ModelStructure><Outputs><Unknown>. \"local\": Local variable that is calculated from other variables or is a continuous-time state (see section 2.2.8). It is not allowed to use the variable value in another model or slave. \"independent\": The independent variable (usually “time”). All variables are a function of this independent variable. variability must be \"continuous\". At most one ScalarVariable of an FMU can be defined as \"independent\". If no variable is defined as \"independent\", it is implicitly present with name = \"time\" and unit = \"s\". If one variable is defined as \"independent\", it must be defined as \"Real\" without a \"start\" attribute. It is not allowed to call function fmi2SetReal on an \"independent\" variable. Instead, its value is initialized with fmi2SetupExperiment and after initialization set by fmi2SetTime for ModelExchange and by arguments currentCommunicationPoint and communicationStepSize of fmi2DoStep for CoSimulation. [The actual value can be inquired with fmi2GetReal.] The default of causality is “local”. A continuous-time state must have causality = \"local\" or \"output\", see also section 2.2.8. [causality = \"calculatedParameter\" and causality = \"local\" with variability = \"fixed\" or \"tunable\" are similar. The difference is that a calculatedParameter can be used in another model or slave, whereas a local variable cannot. For example, when importing an FMU in a Modelica environment, a \"calculatedParameter\" should be imported in a public section as final parameter, whereas a \"local\" variable should be imported in a protected section of the model.] Added prefix \"fmi2\" to help with redefinition of constans in enums.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentState","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentState","text":"ToDo \n\n\n\n\n\n","category":"type"},{"location":"fmi2_lowlevel_library_constants/","page":"FMI2 Types in FMI Import/Core .jl","title":"FMI2 Types in FMI Import/Core .jl","text":"fmi2StructMD FMU2Solution FMIImport.fmi2ValueReferenceFormat FMU2Event FMU2ExecutionConfiguration","category":"page"},{"location":"fmi2_lowlevel_library_constants/#FMI2-Constants-in-FMI-Import/Core-.jl","page":"FMI2 Types in FMI Import/Core .jl","title":"FMI2 Constants in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi2_lowlevel_library_constants/","page":"FMI2 Types in FMI Import/Core .jl","title":"FMI2 Types in FMI Import/Core .jl","text":"fmi2True\nfmi2ComponentStateInstantiated\nfmi2ComponentStateInitializationMode\nfmi2ComponentStateEventMode\nfmi2ComponentStateContinuousTimeMode\nfmi2ComponentStateTerminated\nfmi2ComponentStateError\nfmi2ComponentStateFatal","category":"page"},{"location":"fmi2_lowlevel_library_constants/#FMICore.fmi2True","page":"FMI2 Types in FMI Import/Core .jl","title":"FMICore.fmi2True","text":"Source: FMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nTo simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section. All definitions in this section are provided in the header file “fmi2TypesPlatform.h”.\n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateInstantiated","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateInstantiated","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateInitializationMode","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateInitializationMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateEventMode","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateEventMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateContinuousTimeMode","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateContinuousTimeMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateTerminated","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateTerminated","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateError","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateError","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/#FMIBase.fmi2ComponentStateFatal","page":"FMI2 Types in FMI Import/Core .jl","title":"FMIBase.fmi2ComponentStateFatal","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi2_lowlevel_library_constants/","page":"FMI2 Types in FMI Import/Core .jl","title":"FMI2 Types in FMI Import/Core .jl","text":"fmi2False fmi2StatusOK fmi2StatusWarning fmi2StatusPending fmi2StatusError fmi2StatusDiscard fmi2StatusFatal","category":"page"},{"location":"fmi2_lowlevel_ME_functions/#FMI-for-Model-Exchange","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"","category":"section"},{"location":"fmi2_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"This chapter contains the interface description to access the equations of a dynamic system from a C program.","category":"page"},{"location":"fmi2_lowlevel_ME_functions/#Providing-Independent-Variables-and-Re-initialization-of-Caching","page":"FMI for Model Exchange","title":"Providing Independent Variables and Re-initialization of Caching","text":"","category":"section"},{"location":"fmi2_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"Depending on the situation, different variables need to be computed. In order to be efficient, it is important that the interface requires only the computation of variables that are needed in the present context. The state derivatives shall be reused from the previous call. This feature is called “caching of variables” in the sequel. Caching requires that the model evaluation can detect when the input arguments, like time or states, have changed.","category":"page"},{"location":"fmi2_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"fmi2SetTime\nfmi2SetContinuousStates","category":"page"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2SetTime","page":"FMI for Model Exchange","title":"FMICore.fmi2SetTime","text":"Source: FMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSet a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).\n\n\n\n\n\nfmi2SetTime(c::FMU2Component, \n                time::fmi2Real; \n                soft::Bool=false,\n                track::Bool=true,\n                force::Bool=c.fmu.executionConfig.force,\n                time_shift::Bool=c.fmu.executionConfig.autoTimeShift)\n\nSet a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ntime::fmi2Real: Argument time contains a value of type fmi2Real which is a alias type for Real data type. time sets the independent variable time t.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\n-track::Bool=true: If the Keyword track = true\n\ntime_shift::Bool=c.fmu.executionConfig.autoTimeShift:\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSee also fmi2SetTime.\n\n\n\n\n\nfmiSetTime(c::FMU2Component, t::Real)\n\nSet a new time instant and re-initialize caching of variables that depend on time.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nt::Real: Argument t contains a value of type Real. t sets the independent variable time t.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSee also fmi2SetTime\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2SetContinuousStates","page":"FMI for Model Exchange","title":"FMICore.fmi2SetContinuousStates","text":"Source: FMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSet a new (continuous) state vector and re-initialize caching of variables that depend on the states. Argument nx is the length of vector x and is provided for checking purposes\n\n\n\n\n\nfmiSetContinuousStates(c::FMU2Component,\n                             x::Union{AbstractArray{Float32},AbstractArray{Float64}})\n\nSet a new (continuous) state vector and reinitialize chaching of variables that depend on states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx::Union{AbstractArray{Float32},AbstractArray{Float64}}:Argument x is the AbstractArray of the vector values of Float64 or Float32.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSee also fmi2SetContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#Evaluation-of-Model-Equations","page":"FMI for Model Exchange","title":"Evaluation of Model Equations","text":"","category":"section"},{"location":"fmi2_lowlevel_ME_functions/","page":"FMI for Model Exchange","title":"FMI for Model Exchange","text":"fmi2EnterEventMode\nfmi2NewDiscreteStates\nfmi2NewDiscreteStates!\nfmi2EnterContinuousTimeMode\nfmi2CompletedIntegratorStep\nfmi2CompletedIntegratorStep!\nfmi2GetDerivatives\nfmi2GetDerivatives!\nfmi2GetEventIndicators\nfmi2GetEventIndicators!\nfmi2GetContinuousStates\nfmi2GetContinuousStates!\nfmi2GetNominalsOfContinuousStates\nfmi2GetNominalsOfContinuousStates!","category":"page"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2EnterEventMode","page":"FMI for Model Exchange","title":"FMICore.fmi2EnterEventMode","text":"Source: FMISpec2.0.2[p.84]: 3.2.2 Evaluation of Model Equations\n\nThe model enters Event Mode from the Continuous-Time Mode and discrete-time equations may become active (and relations are not “frozen”).\n\n\n\n\n\nfmi2EnterEventMode(c::FMU2Component; soft::Bool=false)\n\nThe model enters Event Mode from the Continuous-Time Mode and discrete-time equations may become active (and relations are not “frozen”).\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2EnterEventMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMIImport.fmi2NewDiscreteStates","page":"FMI for Model Exchange","title":"FMIImport.fmi2NewDiscreteStates","text":"fmi2NewDiscreteStates(c::FMU2Component)\n\nReturns the next discrete states\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\neventInfo::fmi2EventInfo*: Strut with fmi2Boolean Variables\n\nMore detailed:\n\nnewDiscreteStatesNeeded::fmi2Boolean: If newDiscreteStatesNeeded = fmi2True the FMU should stay in Event Mode, and the FMU requires to set new inputs to the FMU to compute and get the outputs and to call\n\nfmi2NewDiscreteStates again. If all FMUs return newDiscreteStatesNeeded = fmi2False call fmi2EnterContinuousTimeMode.\n\nterminateSimulation::fmi2Boolean: If terminateSimulation = fmi2True call fmi2Terminate\nnominalsOfContinuousStatesChanged::fmi2Boolean: If nominalsOfContinuousStatesChanged = fmi2True then the nominal values of the states have changed due to the function call and can be inquired with fmi2GetNominalsOfContinuousStates.\nvaluesOfContinuousStatesChanged::fmi2Boolean: If valuesOfContinuousStatesChanged = fmi2True, then at least one element of the continuous state vector has changed its value due to the function call. The new values of the states can be retrieved with fmi2GetContinuousStates. If no element of the continuous state vector has changed its value, valuesOfContinuousStatesChanged must return fmi2False.\nnextEventTimeDefined::fmi2Boolean: If nextEventTimeDefined = fmi2True, then the simulation shall integrate at most until time = nextEventTime, and shall call fmi2EnterEventMode at this time instant. If integration is stopped before nextEventTime, the definition of nextEventTime becomes obsolete.\nnextEventTime::fmi2Real: next event if nextEventTimeDefined=fmi2True\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2NewDiscreteStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2NewDiscreteStates!","page":"FMI for Model Exchange","title":"FMICore.fmi2NewDiscreteStates!","text":"Source: FMISpec2.0.2[p.84]: 3.2.2 Evaluation of Model Equations\n\nThe FMU is in Event Mode and the super dense time is incremented by this call.\n\n\n\n\n\nfmi2NewDiscreteStates!(c::FMU2Component, eventInfo::fmi2EventInfo)\n\nThe FMU is in Event Mode and the super dense time is incremented by this call.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\neventInfo::fmi2EventInfo*: Strut with fmi2Boolean Variables that\n\nMore detailed:\n\nnewDiscreteStatesNeeded::fmi2Boolean: If newDiscreteStatesNeeded = fmi2True the FMU should stay in Event Mode, and the FMU requires to set new inputs to the FMU to compute and get the outputs and to call\n\nfmi2NewDiscreteStates again. If all FMUs return newDiscreteStatesNeeded = fmi2False call fmi2EnterContinuousTimeMode.\n\nterminateSimulation::fmi2Boolean: If terminateSimulation = fmi2True call fmi2Terminate\nnominalsOfContinuousStatesChanged::fmi2Boolean: If nominalsOfContinuousStatesChanged = fmi2True then the nominal values of the states have changed due to the function call and can be inquired with fmi2GetNominalsOfContinuousStates.\nvaluesOfContinuousStatesChanged::fmi2Boolean: If valuesOfContinuousStatesChanged = fmi2True, then at least one element of the continuous state vector has changed its value due to the function call. The new values of the states can be retrieved with fmi2GetContinuousStates. If no element of the continuous state vector has changed its value, valuesOfContinuousStatesChanged must return fmi2False.\nnextEventTimeDefined::fmi2Boolean: If nextEventTimeDefined = fmi2True, then the simulation shall integrate at most until time = nextEventTime, and shall call fmi2EnterEventMode at this time instant. If integration is stopped before nextEventTime, the definition of nextEventTime becomes obsolete.\nnextEventTime::fmi2Real: next event if nextEventTimeDefined=fmi2True\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2NewDiscreteStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2EnterContinuousTimeMode","page":"FMI for Model Exchange","title":"FMICore.fmi2EnterContinuousTimeMode","text":"Source: FMISpec2.0.2[p.85]: 3.2.2 Evaluation of Model Equations\n\nThe model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are “frozen”. This function has to be called when changing from Event Mode (after the global event iteration in Event Mode over all involved FMUs and other models has converged) into Continuous-Time Mode.\n\n\n\n\n\nfmi2EnterContinuousTimeMode(c::FMU2Component; soft::Bool=false)\n\nThe model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are “frozen”. This function has to be called when changing from Event Mode (after the global event iteration in Event Mode over all involved FMUs and other models has converged) into Continuous-Time Mode.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2EnterContinuousTimeMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMIImport.fmi2CompletedIntegratorStep","page":"FMI for Model Exchange","title":"FMIImport.fmi2CompletedIntegratorStep","text":"fmiCompletedIntegratorStep(c::FMU2Component, noSetFMUStatePriorToCurrentPoint::fmi2Boolean)\n\nThis function must be called by the environment after every completed step\n\nArguments\n\nC::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nnoSetFMUStatePriorToCurrentPoint::fmi2Boolean: Argument noSetFMUStatePriorToCurrentPoint = fmi2True if fmi2SetFMUState  will no longer be called for time instants prior to current time in this simulation run.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\nenterEventMode::Array{fmi2Boolean, 1}: Returns enterEventMode[1] to signal to the environment if the FMU shall call fmi2EnterEventMode\nterminateSimulation::Array{fmi2Boolean, 1}: Returns terminateSimulation[1] to signal if the simulation shall be terminated.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2CompletedIntegratorStep.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2CompletedIntegratorStep!","page":"FMI for Model Exchange","title":"FMICore.fmi2CompletedIntegratorStep!","text":"Source: FMISpec2.0.2[p.85]: 3.2.2 Evaluation of Model Equations\n\nThis function must be called by the environment after every completed step of the integrator provided the capability flag completedIntegratorStepNotNeeded = false. If enterEventMode == fmi2True, the event mode must be entered If terminateSimulation == fmi2True, the simulation shall be terminated\n\n\n\n\n\nfmi2CompletedIntegratorStep!(c::FMU2Component,\n                                noSetFMUStatePriorToCurrentPoint::fmi2Boolean,\n                                enterEventMode::Ptr{fmi2Boolean},\n                                terminateSimulation::Ptr{fmi2Boolean})\n\nThis function must be called by the environment after every completed step of the integrator provided the capability flag completedIntegratorStepNotNeeded = false.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nnoSetFMUStatePriorToCurrentPoint::fmi2Boolean: Argument noSetFMUStatePriorToCurrentPoint = fmi2True if fmi2SetFMUState  will no longer be called for time instants prior to current time in this simulation run.\nenterEventMode::Ref{fmi2Boolean}: Argument enterEventMode points to the return value (fmi2Boolean) which signals to the environment if the FMU shall call fmi2EnterEventMode. fmi2Boolean is an alias type for Boolean data type.\nterminateSimulation::Ref{fmi2Boolean}: Argument terminateSimulation points to the return value (fmi2Boolean) which signals signal if the simulation shall be terminated. fmi2Boolean is an alias type for Boolean data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2CompletedIntegratorStep!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMIImport.fmi2GetDerivatives","page":"FMI for Model Exchange","title":"FMIImport.fmi2GetDerivatives","text":"fmi2GetDerivatives(c::FMU2Component)\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nderivatives::Array{fmi2Real}: Returns an array of fmi2Real values representing the derivatives for the current states. The ordering of the elements of the derivatives vector is identical to the ordering of the state\n\nvector.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetDerivatives!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2GetDerivatives!","page":"FMI for Model Exchange","title":"FMICore.fmi2GetDerivatives!","text":"Source: FMISpec2.0.2[p.86]: 3.2.2 Evaluation of Model Equations\n\nCompute state derivatives at the current time instant and for the current states.\n\n\n\n\n\nfmi2GetDerivatives!(c::FMU2Component,\n                   derivatives::AbstractArray{fmi2Real},\n                   nx::Csize_t)\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nderivatives::AbstractArray{fmi2Real}: Argument derivatives contains values of type fmi2Real which is a alias type for Real data type.derivatives is the AbstractArray which contains the Real values of the vector that represent the derivatives. The ordering of the elements of the derivatives vector is identical to the ordering of the state vector.\nnx::Csize_t: Argument nx defines the length of vector derivatives and is provided for checking purposes\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetDerivatives!.\n\n\n\n\n\nfmi2GetDerivatives!(c::FMU2Component, derivatives::AbstractArray{fmi2Real})\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nderivatives::Array{fmi2Real}: Stores fmi2Real values representing the derivatives for the current states. The ordering of the elements of the derivatives vector is identical to the ordering of the state vector.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetDerivatives!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMIImport.fmi2GetEventIndicators","page":"FMI for Model Exchange","title":"FMIImport.fmi2GetEventIndicators","text":"fmi2GetEventIndicators(c::FMU2Component)\n\nReturns the event indicators of the FMU\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\neventIndicators::Array{fmi2Real}:The event indicators are returned as a vector represented by an array of \"fmi2Real\" values.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2GetEventIndicators!","page":"FMI for Model Exchange","title":"FMICore.fmi2GetEventIndicators!","text":"Source: FMISpec2.0.2[p.86]: 3.2.2 Evaluation of Model Equations\n\nCompute event indicators at the current time instant and for the current states.\n\n\n\n\n\nfmi2GetEventIndicators!(c::FMU2Component, eventIndicators::AbstractArray{fmi2Real}, ni::Csize_t)\n\nCompute event indicators at the current time instant and for the current states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\neventIndicators::AbstractArray{fmi2Real}: Argument eventIndicators contains values of type fmi2Real which is a alias type for Real data type.eventIndicators is the AbstractArray which contains the Real values of the vector that represent the event indicators.\nni::Csize_t: Argument ni defines the length of vector eventIndicators and is provided for checking purposes\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\nfmi2GetEventIndicators!(c::FMU2Component, eventIndicators::AbstractArray{fmi2Real})\n\nReturns the event indicators of the FMU.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\neventIndicators::AbstractArray{fmi2Real}:The event indicators are in an AbstractArray represented by an array of \"fmi2Real\" values.\n\nReturns\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMIImport.fmi2GetContinuousStates","page":"FMI for Model Exchange","title":"FMIImport.fmi2GetContinuousStates","text":"fmi2GetContinuousStates(c::FMU2Component)\n\nReturn the new (continuous) state vector x\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nx::Array{fmi2Real}: Returns an array of fmi2Real values representing the new continuous state vector x.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2GetContinuousStates!","page":"FMI for Model Exchange","title":"FMICore.fmi2GetContinuousStates!","text":"Source: FMISpec2.0.2[p.86]: 3.2.2 Evaluation of Model Equations\n\nReturn the new (continuous) state vector x.\n\n\n\n\n\nfmi2GetContinuousStates!(c::FMU2Component,\n                            x::AbstractArray{fmi2Real},\n                            nx::Csize_t)\n\nStores the new (continuous) state vector in x.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx::AbstractArray{fmi2Real}: Argument x contains values of type fmi2Real which is a alias type for Real data type.x is the AbstractArray which contains the Real values of the vector that represent the new state vector.\nnx::Csize_t: Argument nx defines the length of vector x and is provided for checking purposes\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMIImport.fmi2GetNominalsOfContinuousStates","page":"FMI for Model Exchange","title":"FMIImport.fmi2GetNominalsOfContinuousStates","text":"fmi2GetNominalsOfContinuousStates(c::FMU2Component)\n\nReturn the new (continuous) state vector x\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nx::Array{fmi2Real}: Returns an array of fmi2Real values representing the new continuous state vector x.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetNominalsOfContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_ME_functions/#FMICore.fmi2GetNominalsOfContinuousStates!","page":"FMI for Model Exchange","title":"FMICore.fmi2GetNominalsOfContinuousStates!","text":"Source: FMISpec2.0.2[p.86]: 3.2.2 Evaluation of Model Equations\n\nReturn the nominal values of the continuous states.\n\n\n\n\n\nfmi2GetNominalsOfContinuousStates!(c::FMU2Component, x_nominal::AbstractArray{fmi2Real}, nx::Csize_t)\n\nStores the nominal values of the continuous states in x_nominal.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx_nominal::AbstractArray{fmi2Real}: Argument x_nominal contains values of type fmi2Real which is a alias type for Real data type.x_nominal is the AbstractArray which contains the Real values of the vector that represent the nominal values of the continuous states.\nnx::Csize_t: Argument nx defines the length of vector x and is provided for checking purposes\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"examples/simulate/#Simulate-an-FMU-in-different-modes","page":"Simulate","title":"Simulate an FMU in different modes","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"🚧 This tutorial is under revision and will be replaced by an up-to-date version soon 🚧","category":"page"},{"location":"examples/simulate/#License","page":"Simulate","title":"License","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/simulate/#Motivation","page":"Simulate","title":"Motivation","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/simulate/#Introduction-to-the-example","page":"Simulate","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In this example we want to show how fast and easy the simulation for an FMU is. For this purpose, the FMU is simulated in co-simulation mode and in model-exchange mode. After the FMU has been simulated, the simulation results are displayed in a graph. The graphs of the different modes are compared with each other. The used model is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"(Image: svg)  ","category":"page"},{"location":"examples/simulate/#Target-group","page":"Simulate","title":"Target group","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/simulate/#Other-formats","page":"Simulate","title":"Other formats","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/simulate/#Getting-started","page":"Simulate","title":"Getting started","text":"","category":"section"},{"location":"examples/simulate/#Installation-prerequisites","page":"Simulate","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install Plots via add Plots ","category":"page"},{"location":"examples/simulate/#Code-section","page":"Simulate","title":"Code section","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots\nusing DifferentialEquations","category":"page"},{"location":"examples/simulate/#Simulation-setup","page":"Simulate","title":"Simulation setup","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Next, the start time and end time of the simulation are set. Finally, a step size is specified to store the results of the simulation at these time steps.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"tStart = 0.0\ntStep = 0.01\ntStop = 8.0\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"0.0:0.01:8.0","category":"page"},{"location":"examples/simulate/#Import-FMU","page":"Simulate","title":"Import FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\")\n\nmyFMU = loadFMU(pathToFMU)\n# loadFMU(\"path/to/myFMU.fmu\"; unpackPath = \"path/to/unpacked/fmu/\")\n\ninfo(myFMU)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringFrictionPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{2e178ad3-5e9b-48ec-a7b2-baa5669efc0c}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:12Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t24\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\tStates:\t\t\t\t2\n\t\t33554432 [\"mass.s\"]\n\n\n\t\t33554433 [\"mass.v\", \"mass.v_relfric\"]\n\tParameters:\t\t\t12\n\t\t16777216 [\"fricScale\"]\n\t\t16777217 [\"s0\"]\n\t\t16777218 [\"v0\"]\n\t\t16777219 [\"fixed.s0\"]\n\t\t...\n\t\t16777223 [\"mass.smin\"]\n\t\t16777224 [\"mass.v_small\"]\n\t\t16777225 [\"mass.L\"]\n\t\t16777226 [\"mass.m\"]\n\t\t16777227 [\"mass.fexp\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/simulate/#Simulate-FMU","page":"Simulate","title":"Simulate FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In the following, the FMU is simulated in the two different simulation modes.","category":"page"},{"location":"examples/simulate/#Simulate-as-Co-Simulation","page":"Simulate","title":"Simulate as Co-Simulation","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In the next steps the recorded values are defined. The first state is the position of the mass and the second state is the velocity. In the function simulateCS() the FMU is simulated in co-simulation mode (CS) with an adaptive step size but with fixed save points tSave. In addition, the start and end time and the recorded variables are specified.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"vrs = [\"mass.s\", \"mass.v\"]\n\ndataCS = simulateCS(myFMU, (tStart, tStop); recordValues=vrs, saveat=tSave)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Model name:\n\tSpringFrictionPendulum1D\nSuccess:\n\ttrue\nf(x)-Evaluations:\n\tIn-place: 0\n\tOut-of-place: 0\nJacobian-Evaluations:\n\t∂ẋ_∂p: 0\n\t∂ẋ_∂x: 0\n\t∂ẋ_∂u: 0\n\t∂y_∂p: 0\n\t∂y_∂x: 0\n\t∂y_∂u: 0\n\t∂e_∂p: 0\n\t∂e_∂x: 0\n\t∂e_∂u: 0\n\t∂xr_∂xl: 0\nGradient-Evaluations:\n\t∂ẋ_∂t: 0\n\t∂y_∂t: 0\n\t∂e_∂t: 0\nCallback-Evaluations:\n\tCondition (event-indicators): 0\n\tTime-Choice (event-instances): 0\n\tAffect (event-handling): 0\n\tSave values: 0\n\tSteps completed: 0\nValues [801]:\n\t0.0\t(0.5, 0.0)\n\t0.01\t(0.5002235448486548, 0.042692491939260585)\n\t0.02\t(0.5008715291319449, 0.08568000508550636)\n\t0.03\t(0.5019478597521578, 0.12892136998736314)\n\t0.04\t(0.5034570452098334, 0.17232325681284336)\n\t0.05\t(0.5053993458877354, 0.2158440857658765)\n\t0.06\t(0.5077764240578201, 0.259420181133082)\n\t0.07\t(0.5105886522837868, 0.30295578207463486)\n\t0.08\t(0.5138351439717114, 0.3464184707972189)\n\t...\n\t8.0\t(1.0713672543616686, -1.0008145180651074e-10)\nEvents [0]:","category":"page"},{"location":"examples/simulate/#Simulate-as-Model-Exchange","page":"Simulate","title":"Simulate as Model-Exchange","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In the function simulateME() the FMU is simulated in model-exchange mode (ME) with an adaptive step size but with fixed save points tSave. In addition, the start and end time are specified. In contrast to the co-simulation, the values to be stored are not specified here, since the states and events of the FMU are always output as well. The identifiers given above just correspond to the states of the FMU.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"dataME = simulateME(myFMU, (tStart, tStop); saveat=tSave)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"\u001b[34mSimulating ME-FMU ...   0%|█                             |  ETA: N/A\u001b[39m\n\n\u001b[34mSimulating ME-FMU ... 100%|██████████████████████████████| Time: 0:00:14\u001b[39m\n\n\n\n\n\nModel name:\n\tSpringFrictionPendulum1D\nSuccess:\n\ttrue\nf(x)-Evaluations:\n\tIn-place: 687\n\tOut-of-place: 0\nJacobian-Evaluations:\n\t∂ẋ_∂p: 0\n\t∂ẋ_∂x: 0\n\t∂ẋ_∂u: 0\n\t∂y_∂p: 0\n\t∂y_∂x: 0\n\t∂y_∂u: 0\n\t∂e_∂p: 0\n\t∂e_∂x: 0\n\t∂e_∂u: 0\n\t∂xr_∂xl: 0\nGradient-Evaluations:\n\t∂ẋ_∂t: 0\n\t∂y_∂t: 0\n\t∂e_∂t: 0\nCallback-Evaluations:\n\tCondition (event-indicators): 1451\n\tTime-Choice (event-instances): 0\n\tAffect (event-handling): 6\n\tSave values: 0\n\tSteps completed: 108\nStates [801]:\n\t0.0\t[0.5, 0.0]\n\t0.01\t[0.5002131418271644, 0.042689450728413444]\n\t0.02\t[0.500854887495059, 0.08570846016824428]\n\t0.03\t[0.5019281657516876, 0.1289839014807958]\n\t0.04\t[0.5034351795370763, 0.17244393614729067]\n\t0.05\t[0.50537742474533, 0.21601821086566914]\n\t0.06\t[0.5077556992635467, 0.25963791323182245]\n\t0.07\t[0.5105701152466664, 0.3032358520639911]\n\t0.08\t[0.5138201143130452, 0.34674645493266393]\n\t...\n\t8.0\t[1.0668392065868253, -1.0000121313794676e-10]\nEvents [6]:\n\tState-Event #11 @ 2.352941176471972e-11s (state-change: false)\n\tState-Event #11 @ 0.9940420391302653s (state-change: false)\n\tState-Event #19 @ 1.9882755413358095s (state-change: false)\n\tState-Event #11 @ 2.9830393009345677s (state-change: false)\n\tState-Event #19 @ 3.978829658884447s (state-change: false)\n\tState-Event #11 @ 4.976975955926236s (state-change: false)","category":"page"},{"location":"examples/simulate/#Plotting-FMU","page":"Simulate","title":"Plotting FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"After the simulation is finished the results of the FMU for the co-simulation and model-exchange mode can be plotted. In the plot for the FMU it can be seen that the oscillation continues to decrease due to the effect of the friction. If you simulate long enough, the oscillation comes to a standstill in a certain time.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"plot(dataCS)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"plot(dataME)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"From both graphs it can be seen that the simulation calculates exactly the same results.","category":"page"},{"location":"examples/simulate/#Unload-FMU","page":"Simulate","title":"Unload FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"unloadFMU(myFMU)","category":"page"},{"location":"examples/simulate/#Summary","page":"Simulate","title":"Summary","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Based on this tutorial it can be seen that simulating in the different mode is very easy, and it only takes a few commands to simulate the FMU. ","category":"page"},{"location":"fmi3_lowlevel_library_constants/#FMI3-Types-in-FMI-Import/Core-.jl","page":"FMI3 Types in FMI Import/Core .jl","title":"FMI3 Types in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi3_lowlevel_library_constants/","page":"FMI3 Types in FMI Import/Core .jl","title":"FMI3 Types in FMI Import/Core .jl","text":"FMU3\nFMU3Instance\nFMU3InstanceEnvironment\nFMI3Struct\nfmi3Instance\nfmi3InstanceEnvironment\nfmi3InstanceState\nfmi3FMUState\nfmi3Initial\nfmi3ValueReference\nfmi3Variable\nfmi3VariableDependency\nfmi3Binary\nfmi3SimpleType\nfmi3Type\nfmi3Unit\nfmi3Boolean\nfmi3Byte\nfmi3Char\nfmi3Float32\nfmi3Float64\nfmi3Int8\nfmi3Int16\nfmi3Int32\nfmi3Int64\nfmi3UInt8\nfmi3UInt16\nfmi3UInt32\nfmi3UInt64\nfmi3String\nfmi3Clock\nfmi3IntervalQualifier\nfmi3Variability\nfmi3DependencyKind\nfmi3Status\nfmi3Annotation\nfmi3ModelDescription\nfmi3VariableNamingConvention\nfmi3Causality","category":"page"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.FMU3","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.FMU3","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.1. Header Files and Naming of Functions\n\nThe mutable struct representing an FMU in the FMI 3.0 Standard. Also contains the paths to the FMU and ZIP folder as well als all the FMI 3.0 function pointers\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.FMU3Instance","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.FMU3Instance","text":"Source: FMISpec3.0, Version D5ef1c1:: 2.2.1. Header Files and Naming of Functions\n\nThe mutable struct represents a pointer to an FMU specific data structure that contains the information needed to process the model equations or to process the co-simulation of the model/subsystem represented by the FMU.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.FMU3InstanceEnvironment","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.FMU3InstanceEnvironment","text":"This is a pointer to a data structure in the importer. Using this pointer, data may be transferred between the importer and callback functions the importer provides with the instantiation functions.\n\nSource: FMISpec 3.0.1 [2.2.3. Platform Dependent Definitions]\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.FMI3Struct","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.FMI3Struct","text":"FMI3Struct\n\nA wildcard for FMI3 related structs, namely Union{FMU3, fmi3ModelDescription, FMU3Instance}.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Instance","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Instance","text":"fmi3Instance (alias for Ptr{Cvoid})\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3InstanceEnvironment","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3InstanceEnvironment","text":"fmi3InstanceEnvironment (alias for Ptr{Cvoid})\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceState","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceState","text":"ToDo \n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3FMUState","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3FMUState","text":"fmi3FMUState (alias for Ptr{Cvoid})\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Initial","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Initial","text":"Source: FMISpec3.0, Version D5ef1c1:2.4.7.5. Type specific properties Enumeration that defines how the variable is initialized, i.e. if a fmi3Set{VariableType} is allowed and how the FMU internally treats this value in Instantiated and Initialization Mode. For the variable with causality = independent, the attribute initial must not be provided, because its start value is set with the startTime parameter of fmi3EnterInitializationMode.\n\nThe attribute initial for other variables can have the following values and meanings:\n\nexact - The variable is initialized with the start value (provided under the variable type element).\n\napprox - The start value provides an approximation that may be modified during initialization, e.g., if the FMU is part of an algebraic loop where the variable might be an iteration variable and start value is taken as initial value for an iterative solution process.\n\ncalculated - The variable is calculated from other variables during initialization. It is not allowed to provide a start value.\n\nIf initial is not present, it is defined by Table 22 based on causality and variability. If initial = exact or approx, or causality = input, a start value must be provided. If initial = calculated, or causality = independent, it is not allowed to provide a start value.\n\n[The environment decides when to use the start value of a variable with causality = input. Examples: * Automatic tests of FMUs are performed, and the FMU is tested by providing the start value as constant input. * For a Model Exchange FMU, the FMU might be part of an algebraic loop. If the input variable is iteration variable of this algebraic loop, then initialization starts with its start value.]\n\nIf fmi3Set{VariableType} is not called on a variable with causality = input, then the FMU must use the start value as value of this input.\n\nAdded prefix \"fmi3\" to help with redefinition of constans in enums.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3ValueReference","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3ValueReference","text":"fmi3ValueReference (alias for Cuint)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Variable","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Variable","text":"Source: FMISpec3.0, Version D5ef1c1: 2.4.7. Definition of Model Variables\n\nA fmi3Variable describes the the type, name, valueRefence and optional information for every variable in the Modeldescription.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3VariableDependency","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3VariableDependency","text":"Mutable Struct representing existance and kind of dependencies of an Unknown on Known Variables.\n\nSee also FMI3.0.1 Spec [fig 30]\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Binary","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Binary","text":"fmi3Binary (alias for Ptr{fmi3Byte})\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3SimpleType","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3SimpleType","text":"ToDo: Not implemented\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Type","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Type","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable\n\nArgument fmuType defines the type of the FMU:\n\nfmi3ModelExchange: FMU with initialization and events; between events simulation of continuous systems is performed with external integrators from the environment.\nfmi3CoSimulation: Black box interface for co-simulation.\nfmi3ScheduledExecution: Concurrent computation of model partitions on a single computational resource (e.g. CPU-core)\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Unit","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Unit","text":"ToDo: Not implemented\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Boolean","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Boolean","text":"fmi3Boolean (alias for Cuchar)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Byte","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Byte","text":"fmi3Byte (alias for Cuchar)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Char","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Char","text":"fmi3Char (alias for Cuchar)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Float32","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Float32","text":"fmi3Float32 (alias for Cfloat)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Float64","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Float64","text":"fmi3Float64 (alias for Cdouble)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Int8","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Int8","text":"fmi3Int8 (alias for Cchar)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Int16","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Int16","text":"fmi3Int16 (alias for Cshort)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Int32","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Int32","text":"fmi3Int32 (alias for Cint)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Int64","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Int64","text":"fmi3Int64 (alias for Clonglong)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3UInt8","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3UInt8","text":"fmi3UInt8 (alias for Cuchar)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3UInt16","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3UInt16","text":"fmi3UInt16 (alias for Cushort)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3UInt32","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3UInt32","text":"fmi3UInt32 (alias for Cuint)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3UInt64","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3UInt64","text":"fmi3UInt64 (alias for Culonglong)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3String","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3String","text":"fmi3String (alias for Ptr{fmi3Char})\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Clock","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Clock","text":"fmi3Clock (alias for Cint)\n\nSource: FMISpec3.0-dev, Version D5ef1c1:2.2.2. Platform Dependent Definitions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3IntervalQualifier","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3IntervalQualifier","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.9.4. Scheduled Execution Enumeration that defines the IntervalQualifiers which describe how to treat the intervals and intervalCounters arguments. They have the following meaning: fmi3IntervalNotYetKnown -  is returned for a countdown aperiodic Clock for which the next interval is not yet known. This qualifier value can only be returned directly after the Clock was active and previous calls to fmi3GetInterval never returned fmi3IntervalChanged (nor fmi3IntervalUnchanged). In Scheduled Execution this return value means that the corresponding model partition cannot be scheduled yet.\n\nfmi3IntervalUnchanged - is returned if a previous call to fmi3GetInterval already returned a value qualified with fmi3IntervalChanged which has not changed since. In Scheduled Execution this means the corresponding model partition has already been scheduled.\n\nfmi3IntervalChanged - is returned to indicate that the value for the interval has changed for this Clock. Any previously returned intervals (if any) are overwritten with the current value. The new Clock interval is relative to the time of the current Event Mode or Clock Update Mode in contrast to the interval of a periodic Clock, where the interval is defined as the time between consecutive Clock ticks. In Scheduled Execution this means that the corresponding model partition has to be scheduled or re-scheduled (if a previous call to fmi3GetInterval returned fmi3IntervalChanged).\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Variability","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Variability","text":"Source: FMISpec3.0, Version D5ef1c1: 2.4.7.4. Variable Attributes Enumeration that defines the time dependency of the variable, in other words, it defines the time instants when a variable can change its value. [The purpose of this attribute is to define when a result value needs to be inquired and to be stored. For example, discrete variables change their values only at event instants (ME) or at a communication point (CS and SE) and it is therefore only necessary to inquire them with fmi3Get{VariableType} and store them at event times.] Allowed values of this enumeration: constant - The value of the variable never changes.\n\nfixed - The value of the variable is fixed after initialization, in other words, after fmi3ExitInitializationMode was called the variable value does not change anymore.\n\ntunable - The value of the variable is constant between events (ME) and between communication points (CS and SE) due to changing variables with causality = parameter and variability = tunable. Whenever a parameter with variability = tunable changes, an event is triggered externally (ME or CS if events are supported), or the change is performed at the next communication point (CS and SE) and the variables with variability = tunable and causality = calculatedParameter or output must be newly computed. [tunable inputs are not allowed, see Table 18.]\n\ndiscrete - Model Exchange: The value of the variable is constant between external and internal events (= time, state, step events defined implicitly in the FMU). Co-Simulation: By convention, the variable is from a real sampled data system and its value is only changed at communication points (including event handling). During intermediateUpdate, discrete variables are not allowed to change. [If the simulation algorithm notices a change in a discrete variable during intermediateUpdate, the simulation algorithm will delay the change, raise an event with earlyReturnRequested == fmi3True and during the communication point it can change the discrete variable, followed by event handling.]\n\ncontinuous - Only a variable of type == fmi3GetFloat32 or type == fmi3GetFloat64 can be continuous. Model Exchange: No restrictions on value changes (see Section 4.1.1).\n\nThe default is continuous for variables of type <Float32> and <Float64>, and discrete for all other types.\n\nFor variables of type Clock and clocked variables the variability is always discrete or tunable.\n\n[Note that the information about continuous states is defined with elements <ContinuousStateDerivative> in <ModelStructure>.]\n\nAdded prefix \"fmi3\" to help with redefinition of constans in enums.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3DependencyKind","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3DependencyKind","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.10. Dependencies of Variables\n\nEnumeration that defines the dependencies a single unknown variable vunknown can have in relation to a known variable vknown. They have the following meaning: dependent - no particular structure, f(.., v_{known,i}, ..)\n\nOnly for floating point type unknowns v_{unknown}:\n\nconstant - constant factor, c ⋅ v_{known,i} where c is an expression that is evaluated before fmi3EnterInitializationMode is called.\n\nOnly for floating point type unknowns v_{unknown} in Event and Continuous-Time Mode (ME) and at communication points (CS and SE), and not for <InitialUnknown> for Initialization Mode:\n\nfixed - fixed factor, p⋅v_{known,i} where p is an expression that is evaluated before fmi3ExitInitializationMode is called.\n\ntunable - tunable factor, p⋅v_{known,i} where p is an expression that is evaluated before fmi3ExitInitializationMode is called and in Event Mode due to event handling (ME) or at a communication point (CS and SE)\n\ndiscrete - discrete factor, d⋅v_{known,i} where d is an expression that is evaluated before fmi3ExitInitializationMode is called and in Event Mode due to an external or internal event or at a communication point (CS and SE).\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Status","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Status","text":"Defines the status flag (an enumeration of type fmi3Status defined in file fmi3FunctionTypes.h) that is returned by functions to indicate the success of the function call: The status has the following meaning:\n\nfmi3OK: The call was successful. The output argument values are defined.\nfmi3Warning: A non-critical problem was detected, but the computation can continue. The output argument values are defined. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings.\n\n[In certain applications, e.g. in a prototyping environment, warnings may be acceptable. For production environments warnings should be treated like errors unless they can be safely ignored.]\n\nfmi3Discard: The call was not successful and the FMU is in the same state as before the call. The output argument values are not defined, but the computation can continue. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. Advanced simulation algorithms can try alternative approaches to drive the simulation by calling the function with different arguments or calling another function. Otherwise the simulation algorithm has to treat this return code like fmi3Error and has to terminate the simulation.\n\n[Examples for usage of fmi3Discard are handling of min/max violation, or signal numerical problems during model evaluation forcing smaller step sizes.]\n\nfmi3Error: The call failed. The output argument values are undefined and the simulation cannot be continued. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. If a function returns fmi3Error, it is possible to restore a previously retrieved FMU state by calling fmi3SetFMUState. Otherwise fmi3FreeInstance or fmi3Reset must be called. When detecting illegal arguments or a function call not allowed in the current state according to the respective state machine, the FMU must return fmi3Error. Other instances of this FMU are not affected by the error.\nfmi3Fatal: The state of all instances of the model is irreparably corrupted. [For example, due to a runtime exception such as access violation or integer division by zero during the execution of an FMI function.] Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings, if still possible. It is not allowed to call any other function for any instance of the FMU.\n\nSource: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Annotation","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Annotation","text":"A not further specified annotation struct.\n\nSource: [ToDo]\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3ModelDescription","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3ModelDescription","text":"Source: FMISpec3.0, Version D5ef1c1: 2.4.1. Definition of an FMU\n\nThe central FMU data structure defining all variables of the FMU that are visible/accessible via the FMU functions.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3VariableNamingConvention","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3VariableNamingConvention","text":"[TODO]\n\nSource: FMISpec3.0, Version D5ef1c1: 2.4.7.5.1. Variable Naming Conventions\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3Causality","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3Causality","text":"Source: FMISpec3.0, Version D5ef1c1: 2.4.7.4. Variable Attributes Enumeration that defines the causality of the variable. Allowed values of this enumeration:\n\nparameter - A data value that is constant during the simulation (except for tunable parameters, see there) and is provided by the environment and cannot be used in connections, except for parameter propagation in terminals as described in Section 2.4.9.2.6. variability must be fixed or tunable. These parameters can be changed independently, unlike calculated parameters. initial must be exact or not present (meaning exact).\n\ncalculatedParameter - A data value that is constant during the simulation and is computed during initialization or when tunable parameters change. variability must be fixed or tunable. initial must be approx, calculated or not present (meaning calculated).\n\ninput - The variable value can be provided by the importer. [For example, the importer could forward the output of another FMU into this input.]\n\noutput -  The variable value can be used by the importer. [For example, this value can be forwarded to an input of another FMU.] The algebraic relationship to the inputs can be defined via the dependencies attribute of <fmiModelDescription><ModelStructure><Output>.\n\nlocal -  Local variables are:\n\ncontinuous states and their ContinuousStateDerivatives, ClockedStates, EventIndicators or InitialUnknowns. These variables are listed in the <fmiModelDescription><ModelStructure>.\ninternal, intermediate variables or local clocks which can be read for debugging purposes and are not listed in the <fmiModelDescription><ModelStructure>.\n\nSetting of local variables:\n\nIn Initialization Mode and before, local variables need to be set if they do have start values or are listed as <InitialUnknown>.\nIn super state Initialized, fmi3Set{VariableType} must not be called on any of the local variables. Only in Model Exchange, continuous states can be set with fmi3SetContinuousStates. Local variable values must not be used as input to another model or FMU.\n\nindependent - The independent variable (usually time [but could also be, for example, angle]). All variables are a function of this independent variable. variability must be continuous. Exactly one variable of an FMU must be defined as independent.  For Model Exchange the value is the last value set by fmi3SetTime. For Co-Simulation the value of the independent variable is lastSuccessfulTime return by the last call to fmi3DoStep or the value of argument intermediateUpdateTime of fmi3CallbackIntermediateUpdate. For Scheduled Execution the value of the independent variable is not defined. [The main purpose of this variable in Scheduled Execution is to define a quantity and unit for the independent variable.] The initial value of the independent variable is the value of the argument startTime of fmi3EnterInitializationMode for both Co-Simulation and Model Exchange.  If the unit for the independent variable is not defined, it is implicitly s (seconds). If one variable is defined as independent, it must be defined with a floating point type without a start attribute. It is not allowed to call function fmi3Set{VariableType} on an independent variable. Instead, its value is initialized with fmi3EnterInitializationMode and after initialization set by fmi3SetTime for Model Exchange and by arguments currentCommunicationPoint and communicationStepSize of fmi3DoStep for Co-Simulation FMUs. [The actual value can be inquired with fmi3Get{VariableType}.]\n\nstructuralParameter - The variable value can only be changed in Configuration Mode or Reconfiguration Mode. The variability attribute must be fixed or tunable. The initial attribute must be exact or not present (meaning exact). The start attribute is mandatory. A structural parameter must not have a <Dimension> element. A structural parameter may be referenced in <Dimension> elements. If a structural parameters is referenced in <Dimension> elements, it must be of type <UInt64> and its start attribute must be larger than 0. The min attribute might still be 0.\n\nThe default of causality is local. A continuous-time state or an event indicator must have causality = local or output, see also Section 2.4.8.\n\n[causality = calculatedParameter and causality = local with variability = fixed or tunable are similar. The difference is that a calculatedParameter can be used in another model or FMU, whereas a local variable cannot. For example, when importing an FMU in a Modelica environment, a calculatedParameter should be imported in a public section as final parameter, whereas a local variable should be imported in a protected section of the model.]\n\nThe causality of variables of type Clock must be either input or output.\n\nAdded prefix \"fmi3\" to help with redefinition of constans in enums.\n\n\n\n\n\n","category":"type"},{"location":"fmi3_lowlevel_library_constants/#FMI3-Constants-in-FMI-Import/Core-.jl","page":"FMI3 Types in FMI Import/Core .jl","title":"FMI3 Constants in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi3_lowlevel_library_constants/","page":"FMI3 Types in FMI Import/Core .jl","title":"FMI3 Types in FMI Import/Core .jl","text":"fmi3True\nfmi3False\nfmi3StatusOK\nfmi3StatusWarning\nfmi3StatusDiscard\nfmi3StatusError\nfmi3StatusFatal\nfmi3InstanceStateInstantiated\nfmi3InstanceStateInitializationMode\nfmi3InstanceStateEventMode\nfmi3InstanceStateStepMode\nfmi3InstanceStateClockActivationMode\nfmi3InstanceStateContinuousTimeMode\nfmi3InstanceStateConfigurationMode\nfmi3InstanceStateReconfigurationMode\nfmi3InstanceStateTerminated\nfmi3InstanceStateError\nfmi3InstanceStateFatal\nfmi3VariableNamingConventionFlat\nfmi3VariableNamingConventionStructured\nfmi3CausalityParameter\nfmi3CausalityCalculatedParameter\nfmi3CausalityInput\nfmi3CausalityOutput\nfmi3CausalityLocal\nfmi3CausalityIndependent\nfmi3CausalityStructuralParameter","category":"page"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3True","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3True","text":"fmi2True\n\nEquals a binary true in FMI3.\n\nSource: [TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3False","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3False","text":"fmi2False\n\nEquals a binary false in FMI3.\n\nSource: [TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3StatusOK","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3StatusOK","text":"fmi3OK: The call was successful. The output argument values are defined.\n\nSource: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3StatusWarning","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3StatusWarning","text":"fmi3Warning: A non-critical problem was detected, but the computation can continue. The output argument values are defined. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. [In certain applications, e.g. in a prototyping environment, warnings may be acceptable. For production environments warnings should be treated like errors unless they can be safely ignored.]\n\nSource: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3StatusDiscard","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3StatusDiscard","text":"fmi3Discard: The call was not successful and the FMU is in the same state as before the call. The output argument values are not defined, but the computation can continue. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. Advanced simulation algorithms can try alternative approaches to drive the simulation by calling the function with different arguments or calling another function. Otherwise the simulation algorithm has to treat this return code like fmi3Error and has to terminate the simulation. [Examples for usage of fmi3Discard are handling of min/max violation, or signal numerical problems during model evaluation forcing smaller step sizes.]\n\nSource: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3StatusError","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3StatusError","text":"fmi3Error: The call failed. The output argument values are undefined and the simulation cannot be continued. Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings. If a function returns fmi3Error, it is possible to restore a previously retrieved FMU state by calling fmi3SetFMUState. Otherwise fmi3FreeInstance or fmi3Reset must be called. When detecting illegal arguments or a function call not allowed in the current state according to the respective state machine, the FMU must return fmi3Error. Other instances of this FMU are not affected by the error.\n\nSource: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3StatusFatal","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3StatusFatal","text":"fmi3Fatal: The state of all instances of the model is irreparably corrupted. [For example, due to a runtime exception such as access violation or integer division by zero during the execution of an FMI function.] Function logMessage should be called by the FMU with further information before returning this status, respecting the current logging settings, if still possible. It is not allowed to call any other function for any instance of the FMU.\n\nSource: FMISpec3.0, Version D5ef1c1: 2.2.3. Status Returned by Functions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateInstantiated","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateInstantiated","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateInitializationMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateInitializationMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateEventMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateEventMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateStepMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateStepMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateClockActivationMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateClockActivationMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateContinuousTimeMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateContinuousTimeMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateConfigurationMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateConfigurationMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateReconfigurationMode","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateReconfigurationMode","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateTerminated","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateTerminated","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateError","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateError","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMIBase.fmi3InstanceStateFatal","page":"FMI3 Types in FMI Import/Core .jl","title":"FMIBase.fmi3InstanceStateFatal","text":"ToDo \n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3VariableNamingConventionFlat","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3VariableNamingConventionFlat","text":"[TODO]\n\nSource: FMISpec3.0, Version D5ef1c1: 2.4.7.5.1. Variable Naming Conventions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3VariableNamingConventionStructured","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3VariableNamingConventionStructured","text":"[TODO]\n\nSource: FMISpec3.0, Version D5ef1c1: 2.4.7.5.1. Variable Naming Conventions\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityParameter","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityParameter","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityCalculatedParameter","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityCalculatedParameter","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityInput","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityInput","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityOutput","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityOutput","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityLocal","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityLocal","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityIndependent","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityIndependent","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_constants/#FMICore.fmi3CausalityStructuralParameter","page":"FMI3 Types in FMI Import/Core .jl","title":"FMICore.fmi3CausalityStructuralParameter","text":"[TODO]\n\n\n\n\n\n","category":"constant"},{"location":"fmi3_lowlevel_library_functions/#FMI-Common-Concepts-for-Model-Exchange-and-Co-Simulation","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"In both cases, FMI defines an input/output block of a dynamic model where the distribution of the block, the platform dependent header file, several access functions, as well as the schema files are identical.","category":"page"},{"location":"fmi3_lowlevel_library_functions/#Creation,-Destruction-and-Logging-of-FMU-Instances","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Creation, Destruction and Logging of FMU Instances","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3InstantiateCoSimulation\nfmi3InstantiateCoSimulation!\nfmi3InstantiateModelExchange\nfmi3InstantiateModelExchange!\nfmi3InstantiateScheduledExecution\nfmi3InstantiateScheduledExecution!\nfmi3FreeInstance\nfmi3FreeInstance!\nfmi3SetDebugLogging","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3InstantiateCoSimulation","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3InstantiateCoSimulation","text":"Source: FMISpec3.0, Version D5ef1c1:: 2.3.1. Super State: FMU State Setable\n\nThis function instantiates a Co-Simulation FMU (see Section 4). It is allowed to call this function only if modelDescription.xml includes a <CoSimulation> element.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3InstantiateCoSimulation!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3InstantiateCoSimulation!","text":"fmi3InstantiateCoSimulation!(fmu::FMU3; instanceName::String=fmu.modelName, type::fmi3Type=fmu.type, pushInstances::Bool = true, visible::Bool = false, loggingOn::Bool = fmu.executionConfig.loggingOn, externalCallbacks::Bool = fmu.executionConfig.externalCallbacks, \n    eventModeUsed::Bool = false, ptrIntermediateUpdate=nothing, logStatusOK::Bool=true, logStatusWarning::Bool=true, logStatusDiscard::Bool=true, logStatusError::Bool=true, logStatusFatal::Bool=true)\n\nCreate a new coSimulation instance of the given fmu, adds a logger if logginOn == true.\n\nArguments\n\nfmu::FMU3: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.\n\nKeywords\n\ninstanceName::String=fmu.modelName: Name of the instance\ntype::fmi3Type=fmu.type: Defines whether a Co-Simulation or Model Exchange is present\npushInstances::Bool = true: Defines if the fmu instances should be pushed in the application.\nvisible::Bool = false if the FMU should be started with graphic interface, if supported (default=false)\nloggingOn::Bool = fmu.executionConfig.loggingOn if the FMU should log and display function calls (default=false)\nexternalCallbacks::Bool = fmu.executionConfig.externalCallbacks if an external shared library should be used for the fmi3CallbackFunctions, this may improve readability of logging messages (default=false)\neventModeUsed::Bool = false: Defines if the FMU instance can use the event mode. (default=false)\nptrIntermediateUpdate=nothing: Points to a function handling intermediate Updates (defalut=nothing) \nlogStatusOK::Bool=true whether to log status of kind fmi3OK (default=true)\nlogStatusWarning::Bool=true whether to log status of kind fmi3Warning (default=true)\nlogStatusDiscard::Bool=true whether to log status of kind fmi3Discard (default=true)\nlogStatusError::Bool=true whether to log status of kind fmi3Error (default=true)\nlogStatusFatal::Bool=true whether to log status of kind fmi3Fatal (default=true)\n\nReturns\n\nReturns the instance of a new FMU coSimulation instance.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.4.7  Model variables\nFMISpec3.0: 2.3.1. Super State: FMU State Setable\n\nSee also fmi3InstantiateCoSimulation.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3InstantiateModelExchange","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3InstantiateModelExchange","text":"Source: FMISpec3.0, Version D5ef1c1:: 2.3.1. Super State: FMU State Setable\n\nThis function instantiates a Model Exchange FMU (see Section 3). It is allowed to call this function only if modelDescription.xml includes a <ModelExchange> element.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3InstantiateModelExchange!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3InstantiateModelExchange!","text":"fmi3InstantiateModelExchange!(fmu::FMU3; instanceName::String=fmu.modelName, type::fmi3Type=fmu.type, pushInstances::Bool = true, visible::Bool = false, loggingOn::Bool = fmu.executionConfig.loggingOn, externalCallbacks::Bool = fmu.executionConfig.externalCallbacks,\n    logStatusOK::Bool=true, logStatusWarning::Bool=true, logStatusDiscard::Bool=true, logStatusError::Bool=true, logStatusFatal::Bool=true)\n\nCreate a new modelExchange instance of the given fmu, adds a logger if logginOn == true.\n\nArguments\n\nfmu::FMU3: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.\n\nKeywords\n\ninstanceName::String=fmu.modelName: Name of the instance\ntype::fmi3Type=fmu.type: Defines whether a Co-Simulation or Model Exchange is present\npushInstances::Bool = true: Defines if the fmu instances should be pushed in the application.\nvisible::Bool = false if the FMU should be started with graphic interface, if supported (default=false)\nloggingOn::Bool = fmu.executionConfig.loggingOn if the FMU should log and display function calls (default=false)\nexternalCallbacks::Bool = fmu.executionConfig.externalCallbacks if an external shared library should be used for the fmi3CallbackFunctions, this may improve readability of logging messages (default=false)\nlogStatusOK::Bool=true whether to log status of kind fmi3OK (default=true)\nlogStatusWarning::Bool=true whether to log status of kind fmi3Warning (default=true)\nlogStatusDiscard::Bool=true whether to log status of kind fmi3Discard (default=true)\nlogStatusError::Bool=true whether to log status of kind fmi3Error (default=true)\nlogStatusFatal::Bool=true whether to log status of kind fmi3Fatal (default=true)\n\nReturns\n\nReturns the instance of a new FMU modelExchange instance.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.4.7  Model variables\nFMISpec3.0: 2.3.1. Super State: FMU State Setable\n\nSee also fmi3InstantiateModelExchange.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3InstantiateScheduledExecution","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3InstantiateScheduledExecution","text":"Source: FMISpec3.0, Version D5ef1c1:: 2.3.1. Super State: FMU State Setable\n\nThis function instantiates a Scheduled Execution FMU (see Section 4). It is allowed to call this function only if modelDescription.xml includes a <ScheduledExecution> element.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3InstantiateScheduledExecution!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3InstantiateScheduledExecution!","text":"fmi3InstantiateScheduledExecution!(fmu::FMU3; ptrlockPreemption::Ptr{Cvoid}, ptrunlockPreemption::Ptr{Cvoid}, instanceName::String=fmu.modelName, type::fmi3Type=fmu.type, pushInstances::Bool = true, visible::Bool = false, loggingOn::Bool = fmu.executionConfig.loggingOn, externalCallbacks::Bool = fmu.executionConfig.externalCallbacks, \n    logStatusOK::Bool=true, logStatusWarning::Bool=true, logStatusDiscard::Bool=true, logStatusError::Bool=true, logStatusFatal::Bool=true)\n\nCreate a new ScheduledExecution instance of the given fmu, adds a logger if logginOn == true.\n\nArguments\n\nfmu::FMU3: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.\n\nKeywords\n\nptrlockPreemption::Ptr{Cvoid}: Points to a function handling locking Preemption\nptrunlockPreemption::Ptr{Cvoid}: Points to a function handling unlocking Preemption\ninstanceName::String=fmu.modelName: Name of the instance\ntype::fmi3Type=fmu.type: Defines whether a Co-Simulation or Model Exchange is present\npushInstances::Bool = true: Defines if the fmu instances should be pushed in the application.\nvisible::Bool = false if the FMU should be started with graphic interface, if supported (default=false)\nloggingOn::Bool = fmu.executionConfig.loggingOn if the FMU should log and display function calls (default=false)\nexternalCallbacks::Bool = fmu.executionConfig.externalCallbacks if an external shared library should be used for the fmi3CallbackFunctions, this may improve readability of logging messages (default=false)\nlogStatusOK::Bool=true whether to log status of kind fmi3OK (default=true)\nlogStatusWarning::Bool=true whether to log status of kind fmi3Warning (default=true)\nlogStatusDiscard::Bool=true whether to log status of kind fmi3Discard (default=true)\nlogStatusError::Bool=true whether to log status of kind fmi3Error (default=true)\nlogStatusFatal::Bool=true whether to log status of kind fmi3Fatal (default=true)\n\nReturns\n\nReturns the instance of a new FMU ScheduledExecution instance.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.4.7  Model variables\nFMISpec3.0: 2.3.1. Super State: FMU State Setable\n\nSee also fmi3InstantiateScheduledExecution.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3FreeInstance","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3FreeInstance","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable\n\nDisposes the given instance, unloads the loaded model, and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface. If a NULL pointer is provided for argument instance, the function call is ignored (does not have an effect).\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3FreeInstance!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3FreeInstance!","text":"fmi3FreeInstance!(c::FMU3Instance; popInstance::Bool = true)\n\nDisposes the given instance, unloads the loaded model, and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface. If a null pointer is provided for “c”, the function call is ignored (does not have an effect).\n\nRemoves the component from the FMUs component list.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\npopInstance::Bool=true: If the Keyword popInstance = true the freed instance is deleted\n\nReturns\n\nnothing\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetDebugLogging","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetDebugLogging","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable\n\nThe function controls debug logging that is output via the logger function callback. If loggingOn = fmi3True, debug logging is enabled, otherwise it is switched off.\n\n\n\n\n\nfmi3SetDebugLogging(c::FMU3Instance, logginOn::fmi3Boolean, nCategories::UInt, categories::Ptr{Nothing})\n\nControl the use of the logging callback function, version independent.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nlogginOn::fmi3Boolean: If loggingOn = fmi3True, debug logging is enabled for the log categories specified in categories, otherwise it is disabled. Type fmi3Boolean is defined as an alias Type for the C-Type Boolean and is to be used with fmi3True and fmi3False.\nnCategories::UInt: Argument nCategories defines the length of the argument categories.\ncategories::Ptr{Nothing}:\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.1. Super State: FMU State Setable\n\nSee also fmi3SetDebugLogging.\n\n\n\n\n\nfmi3SetDebugLogging(c::FMU3Instance)\n\nSet the DebugLogger for the FMU.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nReturns a warning if str.state is not called in fmi3InstanceStateInstantiated.\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.1. Super State: FMU State Setable\n\nSee also fmi3SetDebugLogging.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#Initialization,-Termination,-and-Resetting-an-FMU","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Initialization, Termination, and Resetting an FMU","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"This section documents functions that deal with initialization, termination, resetting of an FMU.","category":"page"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3EnterInitializationMode\nfmi3ExitInitializationMode\nfmi3EnterConfigurationMode\nfmi3ExitConfigurationMode\nfmi3Terminate\nfmi3Reset","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3EnterInitializationMode","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3EnterInitializationMode","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.2. State: Instantiated\n\nInforms the FMU to enter Initialization Mode. Before calling this function, all variables with attribute <Datatype initial = \"exact\" or \"approx\"> can be set with the “fmi3SetXXX” functions (the ScalarVariable attributes are defined in the Model Description File, see section 2.4.7). Setting other variables is not allowed. Also sets the simulation start and stop time.\n\n\n\n\n\nfmi3EnterInitializationMode(c::FMU3Instance, toleranceDefined::fmi3Boolean,\n    tolerance::fmi3Float64,\n    startTime::fmi3Float64,\n    stopTimeDefined::fmi3Boolean,\n    stopTime::fmi3Float64)\n\nInforms the FMU to enter Initialization Mode. Before calling this function, all variables with attribute <Datatype initial = \"exact\" or \"approx\"> can be set with the “fmi3SetXXX” functions (the ScalarVariable attributes are defined in the Model Description File, see section 2.4.7). Setting other variables is not allowed. Also sets the simulation start and stop time.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\ntoleranceDefined::fmi3Boolean: Arguments toleranceDefined depend on the FMU type:\nfmuType = fmi3ModelExchange: If toleranceDefined = fmi3True, then the model is called with a numerical integration scheme where the step size is controlled by using tolerance for error estimation. In such a case, all numerical algorithms used inside the model (for example, to solve non-linear algebraic equations) should also operate with an error estimation of an appropriate smaller relative tolerance.\nfmuType = fmi3CoSimulation: If toleranceDefined = fmi3True, then the communication interval of the slave is controlled by error estimation.  In case the slave utilizes a numerical integrator with variable step size and error estimation, it is suggested to use “tolerance” for the error estimation of the internal integrator (usually as relative tolerance). An FMU for Co-Simulation might ignore this argument.\ntolerance::fmi3Float64: Argument tolerance is the desired tolerance\nstartTime::fmi3Float64: Argument startTime can be used to check whether the model is valid within the given boundaries or to allocate memory which is necessary for storing results. It is the fixed initial value of the independent variable and if the independent variable is time, startTime is the starting time of initializaton.\nstopTimeDefined::fmi3Boolean:  If stopTimeDefined = fmi3True, then stopTime is the defined final value of the independent variable and if stopTimeDefined = fmi3False, then no final value\n\nof the independent variable is defined and argument stopTime is meaningless.\n\nstopTime::fmi3Float64: Argument stopTime can be used to check whether the model is valid within the given boundaries or to allocate memory which is necessary for storing results. It is the fixed final value of the independent variable and if the independent variable is “time”, stopTime is the stop time of the simulation.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3EnterInitializationMode.\n\n\n\n\n\nfmi3EnterInitializationMode(c::FMU3Instance, startTime::Union{Real, Nothing} = nothing, stopTime::Union{Real, Nothing} = nothing; tolerance::Union{Real, Nothing} = nothing)\n\nFMU enters Initialization mode.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nstartTime::Union{Real, Nothing} = nothing: startTime is a real number which sets the value of starting time of the experiment. The default value is set automatically if doing nothing (default = nothing).\nstopTime::Union{Real, Nothing} = nothing: stopTime is a real number which sets the value of ending time of the experiment. The default value is set automatically if doing nothing (default = nothing).\n\nKeywords\n\ntolerance::Union{Real, Nothing} = nothing: tolerance is a real number which sets the value of tolerance range. The default value is set automatically if doing nothing (default = nothing).\n\nReturns\n\nReturns a warning if str.state is not called in fmi3InstanceStateInstantiated.\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3EnterInitializationMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3ExitInitializationMode","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3ExitInitializationMode","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.3. State: Initialization Mode\n\nInforms the FMU to exit Initialization Mode.\n\n\n\n\n\nfmi3ExitInitializationMode(c::FMU3Instance)\n\nInforms the FMU to exit Initialization Mode.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.3. State: Initialization Mode\n\nSee also fmi3ExitInitializationMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3EnterConfigurationMode","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3EnterConfigurationMode","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.2. State: Instantiated\n\nIf the importer needs to change structural parameters, it must move the FMU into Configuration Mode using fmi3EnterConfigurationMode.\n\n\n\n\n\nfmi3EnterConfigurationMode(c::FMU3Instance; soft::Bool=false)\n\nIf the importer needs to change structural parameters, it must move the FMU into Configuration Mode using fmi3EnterConfigurationMode.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state  fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.2. State: Instantiated\n\nSee also fmi3EnterConfigurationMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3ExitConfigurationMode","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3ExitConfigurationMode","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.6. State: Configuration Mode\n\nExits the Configuration Mode and returns to state Instantiated.\n\n\n\n\n\nfmi3ExitConfigurationMode(c::FMU3Instance; soft::Bool=false)\n\nExits the Configuration Mode and returns to state Instantiated.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state  fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.6. State: Configuration Mode\n\nSee also fmi3ExitConfigurationMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3Terminate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3Terminate","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.4. Super State: Initialized\n\nInforms the FMU that the simulation run is terminated.\n\n\n\n\n\nfmi3Terminate(c::FMU3Instance; soft::Bool=false)\n\nInforms the FMU that the simulation run is terminated.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state  fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.4. Super State: Initialized\n\nSee also fmi3Terminate.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3Reset","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3Reset","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.1. Super State: FMU State Setable\n\nIs called by the environment to reset the FMU after a simulation run. The FMU goes into the same state as if fmi3InstantiateXXX would have been called.\n\n\n\n\n\nfmi3Reset(c::FMU3Instance; soft::Bool = false)\n\nIs called by the environment to reset the FMU after a simulation run. The FMU goes into the same state as if fmi3InstantiateXXX would have been called.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.1. Super State: FMU State Setable\n\nSee also fmi3Reset.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#Getting-and-Setting-Variable-Values","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Getting and Setting Variable Values","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"All variable values of an FMU are identified with a variable handle called “value reference”. The handle is defined in the modelDescription.xml file (as attribute “valueReference” in element “ScalarVariable”). Element “valueReference” might not be unique for all variables. If two or more variables of the same base data type (such as fmi3Float64) have the same valueReference, then they have identical values but other parts of the variable definition might be different (for example, min/max attributes).","category":"page"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3GetFloat32\nfmi3GetFloat32!\nfmi3GetFloat64\nfmi3GetFloat64!\nfmi3GetInt8\nfmi3GetInt8!\nfmi3GetInt16\nfmi3GetInt16!\nfmi3GetInt32\nfmi3GetInt32!\nfmi3GetInt64\nfmi3GetInt64!\nfmi3GetUInt8\nfmi3GetUInt8!\nfmi3GetUInt16\nfmi3GetUInt16!\nfmi3GetUInt32\nfmi3GetUInt32!\nfmi3GetUInt64\nfmi3GetUInt64!\nfmi3GetBoolean\nfmi3GetBoolean!\nfmi3GetString\nfmi3GetString!\nfmi3GetBinary\nfmi3GetBinary!\nfmi3SetFloat32\nfmi3SetFloat64\nfmi3SetInt8\nfmi3SetInt16\nfmi3SetInt32\nfmi3SetInt64\nfmi3SetUInt8\nfmi3SetUInt16\nfmi3SetUInt32\nfmi3SetUInt64\nfmi3SetBoolean\nfmi3SetString\nfmi3SetBinary","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetFloat32","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetFloat32","text":"fmi3GetFloat32(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Float32 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Float32}: returns values of an array of fmi3Float32 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetFloat32.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetFloat32!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetFloat32!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetFloat32!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Float32}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Float32}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetFloat32!.\n\n\n\n\n\nfmi3GetFloat32!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Float32})\n\nWrites the real values of an array of variables in the given field\n\nfmi3GetFloat32! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Float32}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetFloat32!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetFloat64","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetFloat64","text":"fmi3GetFloat64(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Float64 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Float64}: returns values of an array of fmi3Float64 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetFloat64.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetFloat64!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetFloat64!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetFloat64!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Float64}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Float64}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetFloat64!.\n\n\n\n\n\nfmi3GetFloat64!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Float64})\n\nWrites the real values of an array of variables in the given field\n\nfmi3GetFloat64! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Float64}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetFloat64!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetInt8","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetInt8","text":"fmi3GetInt8(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Int8 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Int8}: returns values of an array of fmi3Int8 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt8.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetInt8!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetInt8!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetInt8!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int8}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int8}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt8!.\n\n\n\n\n\nfmi3GetInt8!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Int8})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetInt8! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Int8}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt8!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetInt16","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetInt16","text":"fmi3GetInt16(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Int16 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Int16}: returns values of an array of fmi3Int16 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt16.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetInt16!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetInt16!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetInt16!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int16}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int16}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt16!.\n\n\n\n\n\nfmi3GetInt16!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Int16})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetInt16! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Int16}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt16!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetInt32","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetInt32","text":"fmi3GetInt32(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Int32 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Int32}: returns values of an array of fmi3Int32 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt32.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetInt32!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetInt32!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetInt32!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int32}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int32}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt32!.\n\n\n\n\n\nfmi3GetInt32!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Int32})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetInt32! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Int32}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt32!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetInt64","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetInt64","text":"fmi3GetInt64(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Int64 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Int64}: returns values of an array of fmi3Int64 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt64.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetInt64!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetInt64!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetInt64!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int64}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int64}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt64!.\n\n\n\n\n\nfmi3GetInt64!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Int64})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetInt64! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Int64}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetInt64!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetUInt8","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetUInt8","text":"fmi3GetUInt8(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3UInt8 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3UInt8}: returns values of an array of fmi3UInt8 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt8.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetUInt8!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetUInt8!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetUInt8!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt8}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt8}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt8!.\n\n\n\n\n\nfmi3GetUInt8!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3UInt8})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetUInt8! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3UInt8}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt8!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetUInt16","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetUInt16","text":"fmi3GetUInt16(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3UInt16 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3UInt16}: returns values of an array of fmi3UInt16 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt16.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetUInt16!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetUInt16!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetUInt16(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt16}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt16}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt16!.\n\n\n\n\n\nfmi3GetUInt16!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3UInt16})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetUInt16! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3UInt16}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt16!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetUInt32","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetUInt32","text":"fmi3GetUInt32(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3UInt32 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3UInt32}: returns values of an array of fmi3UInt32 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt32.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetUInt32!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetUInt32!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetUInt32!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt32}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt32}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt32!.\n\n\n\n\n\nfmi3GetUInt32!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3UInt32})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetUInt32! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3UInt32}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt32!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetUInt64","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetUInt64","text":"fmi3GetUInt64(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3UInt64 variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3UInt64}: returns values of an array of fmi3UInt64 variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt64.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetUInt64!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetUInt64!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetUInt64!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt64}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt64}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt64!.\n\n\n\n\n\nfmi3GetUInt64!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3UInt64})\n\nWrites the integer values of an array of variables in the given field\n\nfmi3GetUInt64! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3UInt64}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetUInt64!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetBoolean","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetBoolean","text":"fmi3GetBoolean(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Boolean variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Boolean}: returns values of an array of fmi3Boolean variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetBoolean.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetBoolean!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetBoolean!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetBoolean!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Boolean}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Boolean}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetBoolean!.\n\n\n\n\n\nfmi3GetBoolean!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Boolean})\n\nWrites the boolean values of an array of variables in the given field\n\nfmi3GetBoolean! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Boolean}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetBoolean!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetString","text":"fmi3GetString(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3String variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3String}: returns values of an array of fmi3String variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetString.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetString!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetString!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetString!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3String}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3String}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetString!.\n\n\n\n\n\nfmi3GetString!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3String})\n\nWrites the string values of an array of variables in the given field\n\nfmi3GetString! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3String}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetString!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetBinary","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetBinary","text":"fmi3GetBinary(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Binary variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Binary}: returns values of an array of fmi3Binary variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetBinary.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetBinary!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetBinary!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValues - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetBinary!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, valueSizes::AbstractArray{Csize_t}, value::AbstractArray{fmi3Binary}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalueSizes::AbstractArray{Csize_t}: Argument valueSizes defines the size of a binary element of each variable.\nvalue::AbstractArray{fmi3Binary}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetBinary!.\n\n\n\n\n\nfmi3GetBinary!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Binary})\n\nWrites the binary values of an array of variables in the given field\n\nfmi3GetBinary! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Binary}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetBinary!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetFloat32","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetFloat32","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetFloat32(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Float32}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Float32}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetFloat32.\n\n\n\n\n\nfmi3SetFloat32(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Float32}, fmi3Float32})\n\nSet the values of an array of real variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Float32}, fmi3Float32}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetFloat32.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetFloat64","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetFloat64","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetFloat64(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Float64}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Float64}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetFloat64.\n\n\n\n\n\nfmi3SetFloat64(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Float64}, fmi3Float64})\n\nSet the values of an array of real variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Float64}, fmi3Float64}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetFloat64.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetInt8","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetInt8","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetInt8(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int8}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int8}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\n\n\n\n\nfmi3SetInt8(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Int8}, fmi3Int8})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Int8}, fmi3Int8}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt8.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetInt16","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetInt16","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetInt16(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int16}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int16}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt16.\n\n\n\n\n\nfmi3SetInt16(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Int16}, fmi3Int16})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Int16}, fmi3Int16}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt16.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetInt32","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetInt32","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetInt32(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int32}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int32}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt32.\n\n\n\n\n\nfmi3SetInt32(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Int32}, fmi3Int32})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Int32}, fmi3Int32}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt32.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetInt64","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetInt64","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetInt64(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Int64}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Int64}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt64.\n\n\n\n\n\nfmi3SetInt64(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3Int64}, fmi3Int64})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Int64}, fmi3Int64}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetInt64.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetUInt8","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetUInt8","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetUInt8(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt8}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt8}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt8.\n\n\n\n\n\nfmi3SetUInt8(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3UInt8}, fmi3UInt8})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3UInt8}, fmi3UInt8}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt8.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetUInt16","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetUInt16","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetUInt16(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt16}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt16}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\n\n\n\n\nfmi3SetUInt16(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3UInt16}, fmi3UInt16})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3UInt16}, fmi3UInt16}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt16.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetUInt32","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetUInt32","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetInt32(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt32}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt32}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt32.\n\n\n\n\n\nfmi3SetUInt32(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3UInt32}, fmi3UInt32})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3UInt32}, fmi3UInt32}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt32.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetUInt64","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetUInt64","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetUInt64(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3UInt64}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3UInt64}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:     - fmi3OK: all well     - fmi3Warning: things are not quite right, but the computation can continue     - fmi3Discard: if the slave computed successfully only a subinterval of the communication step     - fmi3Error: the communication step could not be carried out at all     - fmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt64.\n\n\n\n\n\nfmi3SetUInt64(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{fmi3UInt64}, fmi3UInt64})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3UInt64}, fmi3UInt64}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetUInt64.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetBoolean","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetBoolean","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetBoolean(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Boolean}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3Boolean}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetBoolean.\n\n\n\n\n\nfmi3SetBoolean(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{Bool}, Bool})\n\nSet the values of an array of boolean variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{Bool}, Bool}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetBoolean.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetString","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetString(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3String}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi3String}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetString.\n\n\n\n\n\nfmi3SetString(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::Union{AbstractArray{String}, String})\n\nSet the values of an array of string variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{String}, String}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetString.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetBinary","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetBinary","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetBinary(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, valueSizes::AbstractArray{Csize_t}, value::AbstractArray{fmi3Binary}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalueSizes::AbstractArray{Csize_t}: Argument valueSizes defines the size of a binary element of each variable.\nvalue::AbstractArray{fmi3Binary}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetBinary.\n\n\n\n\n\nfmi3SetBinary(c::FMU3Instance, vr::fmi3ValueReferenceFormat, valueSizes::Union{AbstractArray{Csize_t}, Csize_t}, values::Union{AbstractArray{fmi3Binary}, fmi3Binary})\n\nSet the values of an array of binary variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalueSizes::Union{AbstractArray{Csize_t}, Csize_t}: Argument valueSizes defines the size of a binary element of each variable.\nvalues::Union{AbstractArray{fmi3Binary}, fmi3Binary}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetBinary.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3Get fmi3Get! fmi3Set","category":"page"},{"location":"fmi3_lowlevel_library_functions/#Getting-and-Setting-the-Complete-FMU-State","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Getting and Setting the Complete FMU State","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"The FMU has an internal state consisting of all values that are needed to continue a simulation. This internal state consists especially of the values of the continuous-time states, iteration variables, parameter values, input values, delay buffers, file identifiers, and FMU internal status information. With the functions of this section, the internal FMU state can be copied and the pointer to this copy is returned to the environment. The FMU state copy can be set as actual FMU state, in order to continue the simulation from it.","category":"page"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3GetFMUState\nfmi3GetFMUState!\nfmi3SetFMUState\nfmi3FreeFMUState\nfmi3SerializeFMUState\nfmi3SerializeFMUState!\nfmi3SerializedFMUStateSize\nfmi3SerializedFMUStateSize!\nfmi3DeSerializeFMUState\nfmi3DeSerializeFMUState!\nfmi3UpdateDiscreteStates\nfmi3EvaluateDiscreteStates\nfmi3GetNominalsOfContinuousStates","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetFMUState","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetFMUState","text":"fmi3GetFMUState(c::FMU3Instance)\n\nMakes a copy of the internal FMU state and returns a pointer to this copy.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nReturn state is a pointer to a copy of the internal FMU state.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3GetFMUState.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetFMUState!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetFMUState!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State\n\nfmi3GetFMUstate makes a copy of the internal FMU state and returns a pointer to this copy\n\n\n\n\n\nfmi3GetFMUState!(c::FMU3Instance, FMUstate::Ref{fmi3FMUState})\n\nMakes a copy of the internal FMU state and returns a pointer to this copy\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nFMUstate::Ref{fmi3FMUstate}:If on entry FMUstate == NULL, a new allocation is required. If FMUstate != NULL, then FMUstate points to a previously returned FMUstate that has not been modified since.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3GetFMUState!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetFMUState","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetFMUState","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State\n\nfmi3SetFMUstate copies the content of the previously copied FMUstate back and uses it as actual new FMU state.\n\n\n\n\n\nfmi3SetFMUState(c::FMU3Instance, FMUstate::fmi3FMUState)\n\nCopies the content of the previously copied FMUstate back and uses it as actual new FMU state.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nFMUstate::fmi3FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3SetFMUState.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3FreeFMUState","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3FreeFMUState","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State\n\nfmi3FreeFMUstate frees all memory and other resources allocated with the fmi3GetFMUstate call for this FMUstate.\n\n\n\n\n\nfmi3FreeFMUState(c::FMU3Instance, FMUstate::Ref{fmi3FMUState})\n\nFrees all memory and other resources allocated with the fmi3GetFMUstate call for this FMUstate.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nFMUstate::fmi3FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\n\n\n\n\nfmi3FreeFMUState!(c::FMU3Instance, state::fmi3FMUState)\n\nFree the allocated memory for the FMU state.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nstate::fmi3FMUState: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nReturn singleton instance of type Nothing, if there is no value to return (as in a C void function) or when a variable or field holds no value.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3SerializeFMUState","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3SerializeFMUState","text":"fmi3SerializeFMUState(c::FMU3Instance, state::fmi3FMUState)\n\nSerializes the data referenced by the pointer FMUstate and copies this data into the byte vector serializedState of length size to be provided by the environment.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nstate::fmi3FMUState: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nserializedState:: Array{fmi3Byte}: Return serializedState contains the copy of the serialized data referenced by the pointer FMUstate\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3SerializeFMUState.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SerializeFMUState!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SerializeFMUState!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State\n\nfmi3SerializeFMUstate serializes the data which is referenced by pointer FMUstate and copies this data in to the byte vector serializedState of length size\n\n\n\n\n\nfmi3SerializeFMUState!(c::FMU3Instance, FMUstate::fmi3FMUState, serialzedState::AbstractArray{fmi3Byte}, size::Csize_t)\n\nSerializes the data which is referenced by pointer FMUState and copies this data in to the byte vector serializedState of length size, that must be provided by the environment.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nFMUstate::fmi3FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nserialzedState::AbstractArray{fmi3Byte}: Argument serializedState contains the copy of the serialized data referenced by the pointer FMUstate.\nsize::Ref{Csize_t}: Argument size is an object that safely references a value of type Csize_t and defines the size of the byte vector in which the FMUstate can be stored.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3SerializeFMUState!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3SerializedFMUStateSize","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3SerializedFMUStateSize","text":"fmi3SerializedFMUStateSize(c::FMU3Instance, state::fmi3FMUState)\n\nReturns the size of the byte vector in which the FMUstate can be stored.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nstate::fmi3FMUState: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nReturn size is an object that safely references a value of type Csize_t.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3SerializedFMUStateSize.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SerializedFMUStateSize!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SerializedFMUStateSize!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State\n\nfmi3SerializedFMUstateSize returns the size of the byte vector which is needed to store FMUstate in it.\n\n\n\n\n\nfmi3SerializedFMUStateSize!(c::FMU3Instance, FMUstate::fmi3FMUState, size::Ref{Csize_t})\n\nFrees all memory and other resources allocated with the fmi3GetFMUstate call for this FMUstate.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nFMUstate::fmi3FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nsize::Ref{Csize_t}: Argument size is an object that safely references a value of type Csize_t and defines the size of the byte vector in which the FMUstate can be stored.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3SerializedFMUStateSize!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3DeSerializeFMUState","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3DeSerializeFMUState","text":"fmi3SerializeFMUState(c::FMU3Instance, state::fmi3FMUState)\n\nSerializes the data referenced by the pointer FMUstate and copies this data into the byte vector serializedState of length size to be provided by the environment.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nserializedState::Array{fmi3Byte}: Argument serializedState contains the fmi3Byte field to be deserialized.\n\nReturns\n\nReturn state is a pointer to a copy of the internal FMU state.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3DeSerializeFMUState.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3DeSerializeFMUState!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3DeSerializeFMUState!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.4. Getting and Setting the Complete FMU State\n\nfmi3DeSerializeFMUstate deserializes the byte vector serializedState of length size, constructs a copy of the FMU state and returns FMUstate, the pointer to this copy.\n\n\n\n\n\nfmi3DeSerializeFMUState!(c::FMU3Instance, serialzedState::AbstractArray{fmi3Byte}, size::Csize_t, FMUstate::Ref{fmi3FMUState})\n\nDeserializes the byte vector serializedState of length size, constructs a copy of the FMU state and stores the FMU state in the given address of the reference FMUstate, the pointer to this copy.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nFMUstate::fmi3FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nserialzedState::AbstractArray{fmi3Byte}: Argument serializedState contains the copy of the serialized data referenced by the pointer FMUstate.\nsize::Ref{Csize_t}: Argument size is an object that safely references a value of type Csize_t and defines the size of the byte vector in which the FMUstate can be stored.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.4. Getting and Setting the Complete FMU State\n\nSee also fmi3DeSerializeFMUState!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3UpdateDiscreteStates","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3UpdateDiscreteStates","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.5. State: Event Mode\n\nThis function is called to signal a converged solution at the current super-dense time instant. fmi3UpdateDiscreteStates must be called at least once per super-dense time instant.\n\n\n\n\n\nfmi3UpdateDiscreteStates(c::FMU3Instance, discreteStatesNeedUpdate::Ref{fmi3Boolean}, terminateSimulation::Ref{fmi3Boolean}, \n                                nominalsOfContinuousStatesChanged::Ref{fmi3Boolean}, valuesOfContinuousStatesChanged::Ref{fmi3Boolean},\n                                nextEventTimeDefined::Ref{fmi3Boolean}, nextEventTime::Ref{fmi3Float64})\n\nThis function is called to signal a converged solution at the current super-dense time instant. fmi3UpdateDiscreteStates must be called at least once per super-dense time instant.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\ndiscreteStatesNeedUpdate::Ref{fmi3Boolean}: \nterminateSimulation::Ref{fmi3Boolean}: \nnominalsOfContinuousStatesChanged::Ref{fmi3Boolean}: \nvaluesOfContinuousStatesChanged::Ref{fmi3Boolean}: \nnextEventTimeDefined::Ref{fmi3Boolean}: \nnextEventTime::Ref{fmi3Float64}: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.5. State: Event Mode\n\n\n\n\n\nfmi3UpdateDiscreteStates(c::FMU3Instance)\n\nThis function is called to signal a converged solution at the current super-dense time instant. fmi3UpdateDiscreteStates must be called at least once per super-dense time instant. Results are returned, use fmi3UpdateDiscreteStates! for the inplace variant.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\ndiscreteStatesNeedUpdate\nterminateSimulation\nnominalsOfContinuousStatesChanged\nvaluesOfContinuousStatesChanged\nnextEventTimeDefined\nnextEventTime\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.3.5. State: Event Mode\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3EvaluateDiscreteStates","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3EvaluateDiscreteStates","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.3. State: Initialization Mode\n\nThis function is called to trigger the evaluation of fdisc to compute the current values of discrete states from previous values.  The FMU signals the support of fmi3EvaluateDiscreteStates via the capability flag providesEvaluateDiscreteStates.\n\n\n\n\n\nfmi3EvaluateDiscreteStates(c::FMU3Instance)\n\nThis function is called to trigger the evaluation of fdisc to compute the current values of discrete states from previous values.  The FMU signals the support of fmi3EvaluateDiscreteStates via the capability flag providesEvaluateDiscreteStates.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.3. State: Initialization Mode\n\nSee also fmi3EvaluateDiscreteStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetNominalsOfContinuousStates","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetNominalsOfContinuousStates","text":"fmi3GetNominalsOfContinuousStates(c::FMU3Instance)\n\nReturn the nominal values of the continuous states.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nx::Array{fmi3Float64}: Returns an array of fmi3Float64 values representing the new nominals of continuous state vector x.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.3.3. State: Initialization Mode\n\nSee also fmi3GetNominalsOfContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#Getting-Partial-Dervatives","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Getting Partial Dervatives","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"It is optionally possible to provide evaluation of partial derivatives for an FMU. For Model Exchange, this means computing the partial derivatives at a particular time instant. For Co-Simulation, this means to compute the partial derivatives at a particular communication point. One function is provided to compute directional derivatives. This function can be used to construct the desired partial derivative matrices.","category":"page"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3GetDirectionalDerivative\nfmi3GetDirectionalDerivative!\nfmi3GetContinuousStateDerivatives\nfmi3GetContinuousStateDerivatives!\nfmi3GetAdjointDerivative\nfmi3GetAdjointDerivative!\nfmi3GetOutputDerivatives\nfmi3GetOutputDerivatives!","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetDirectionalDerivative","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetDirectionalDerivative","text":"fmi3GetDirectionalDerivative(c::FMU3Instance,\n    unknowns::AbstractArray{fmi3ValueReference},\n    knowns::AbstractArray{fmi3ValueReference},\n    seed::AbstractArray{fmi3Float64})\n\nWrapper Function call to compute the partial derivative with respect to the variables unknowns.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = 𝐡(knowns, rest)\n\nunknowns: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknown> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Output> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><ContinuousStateDerivative>).\nEvent Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Output> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Output> with type Real and variability = continuous or discrete. If <ModelStructure><ContinuousStateDerivative> is present, also the variables listed here as state derivatives.\nknowns: Real input variables of function h that changes its value in the actual Mode.\nrest: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔunknowns = (δh / δknowns) Δknowns\n\nArguments\n\nc::FMU3Instance Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nunknowns::AbstracArray{fmi3ValueReference}: Argument unknowns contains values of typefmi3ValueReference which are identifiers of a variable value of the model. unknowns can be equated with unknowns(variable described above).\nknowns::AbstractArray{fmi3ValueReference}: Argument knowns contains values of type fmi3ValueReference which are identifiers of a variable value of the model.knowns can be equated with knowns(variable described above).\nseed::AbstractArray{fmi3Float64}:The vector values Compute the partial derivative with respect to the given entries in vector knowns with the matching evaluate of sensitivity.\n\nReturns\n\nsensitivity::Array{fmi3Float64}: Return sensitivity contains the directional derivative vector values.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.11. Getting Partial Derivatives\n\nSee also fmi3GetDirectionalDerivative.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetDirectionalDerivative!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetDirectionalDerivative!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.11. Getting Partial Derivatives\n\nThis function computes the directional derivatives v{sensitivity} = J ⋅ v{seed} of an FMU.\n\nunknowns - contains value references to the unknowns.\n\nnUnknowns - contains the length of argument unknowns.\n\nknowns - contains value references of the knowns.\n\nnKnowns - contains the length of argument knowns.\n\nseed - contains the components of the seed vector.\n\nnSeed - contains the length of seed.\n\nsensitivity - contains the components of the sensitivity vector.\n\nnSensitivity - contains the length of sensitivity.\n\nThis function can only be called if the 'ProvidesDirectionalDerivatives' tag in the ModelDescription is set.\n\n\n\n\n\nfmi3GetDirectionalDerivative!(c::FMU3Instance,\n                                   unknowns::AbstractArray{fmi3ValueReference},\n                                   nUnknowns::Csize_t,\n                                   knowns::AbstractArray{fmi3ValueReference},\n                                   nKnowns::Csize_t,\n                                   seed::AbstractArray{fmi3Float64},\n                                   nSeed::Csize_t,\n                                   sensitivity::AbstractArray{fmi3Float64},\n                                   nSensitivity::Csize_t)\n\nWrapper Function call to compute the partial derivative with respect to the variables unknowns.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = 𝐡(knowns, rest)\n\nunknowns: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknown> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Output> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><ContinuousStateDerivative>).\nEvent Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Output> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Output> with type Real and variability = continuous or discrete. If <ModelStructure><ContinuousStateDerivative> is present, also the variables listed here as state derivatives.\nknowns: Real input variables of function h that changes its value in the actual Mode.\nrest: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔunknowns = (δh / δknowns) Δknowns\n\nArguments\n\nc::FMU3Instance Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nunknowns::AbstracArray{fmi3ValueReference}: Argument unknowns contains values of typefmi3ValueReference which are identifiers of a variable value of the model. unknowns can be equated with unknowns(variable described above).\nnUnknowns::Csize_t:\nknowns::AbstractArray{fmi3ValueReference}: Argument knowns contains values of type fmi3ValueReference which are identifiers of a variable value of the model.knowns can be equated with knowns(variable described above).\nnKnowns::Csize_t:\nseed::AbstractArray{fmi3Float64}:The vector values Compute the partial derivative with respect to the given entries in vector knowns with the matching evaluate of sensitivity.\nnKnowns::Csize_t:\nsensitivity::AbstractArray{fmi3Float64}: Stores the directional derivative vector values.\nnKnowns::Csize_t:\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.11. Getting Partial Derivatives\n\nSee also fmi3GetDirectionalDerivative.\n\n\n\n\n\nfmi3GetDirectionalDerivative!(c::FMU3Instance,\n    unknowns::AbstractArray{fmi3ValueReference},\n    knowns::AbstractArray{fmi3ValueReference},\n    sensitivity::AbstractArray{fmi3Float64},\n    seed::AbstractArray{fmi3Float64})\n\nWrapper Function call to compute the partial derivative with respect to the variables unknowns.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = 𝐡(knowns, rest)\n\nunknowns: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknown> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Output> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><ContinuousStateDerivative>).\nEvent Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Output> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Output> with type Real and variability = continuous or discrete. If <ModelStructure><ContinuousStateDerivative> is present, also the variables listed here as state derivatives.\nknowns: Real input variables of function h that changes its value in the actual Mode.\nrest: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔunknowns = (δh / δknowns) Δknowns\n\nArguments\n\nc::FMU3Instance Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nunknowns::AbstracArray{fmi3ValueReference}: Argument unknowns contains values of typefmi3ValueReference which are identifiers of a variable value of the model. unknowns can be equated with unknowns(variable described above).\nknowns::AbstractArray{fmi3ValueReference}: Argument knowns contains values of type fmi3ValueReference which are identifiers of a variable value of the model.knowns can be equated with knowns(variable described above).\nsensitivity::AbstractArray{fmi3Float64}: Stores the directional derivative vector values.\nseed::AbstractArray{fmi3Float64}:The vector values Compute the partial derivative with respect to the given entries in vector knowns with the matching evaluate of sensitivity.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.11. Getting Partial Derivatives\n\nSee also fmi3GetDirectionalDerivative!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetContinuousStateDerivatives","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetContinuousStateDerivatives","text":"fmi3GetContinuousStateDerivatives(c::FMU3Instance)\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nReturns\n\nderivatives::Array{fmi3Float64}: Returns an array of fmi3Float64 values representing the derivatives for the current states. The ordering of the elements of the derivatives vector is identical to the ordering of the state\n\nvector.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3GetContinuousStateDerivatives.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetContinuousStateDerivatives!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetContinuousStateDerivatives!","text":"Source: FMISpec3.0, Version D5ef1c1: 3.2.1. State: Continuous-Time Mode\n\nCompute first-oder state derivatives at the current time instant and for the current states.\n\n\n\n\n\nfmi3GetContinuousStateDerivatives!(c::FMU3Instance,\n                        derivatives::AbstractArray{fmi3Float64},\n                        nx::Csize_t)\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nderivatives::AbstractArray{fmi3Float64}: Argument derivatives contains values of type fmi3Float64 which is a alias type for Real data type.derivatives is the AbstractArray which contains the Real values of the vector that represent the derivatives. The ordering of the elements of the derivatives vector is identical to the ordering of the state vector.\nnx::Csize_t: Argument nx defines the length of vector derivatives and is provided for checking purposes\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3GetContinuousStateDerivatives!.\n\n\n\n\n\nfmi3GetContinuousStateDerivatives!(c::FMU3Instance, derivatives::Array{fmi3Float64})\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nderivatives::AbstractArray{fmi3Float64}: Argument derivatives contains values of type fmi3Float64 which is a alias type for Real data type.derivatives is the AbstractArray which contains the Real values of the vector that represent the derivatives. The ordering of the elements of the derivatives vector is identical to the ordering of the state vector.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 3.2.1. State: Continuous-Time Mode\n\nSee also fmi3GetContinuousStateDerivatives!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetAdjointDerivative","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetAdjointDerivative","text":"fmi3GetAdjointDerivative(c::FMU3Instance,\n    unknowns::AbstractArray{fmi3ValueReference},\n    knowns::AbstractArray{fmi3ValueReference},\n    seed::AbstractArray{fmi3Float64})\n\nWrapper Function call to compute the partial derivative with respect to the variables unknowns.\n\nComputes the adjoint derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = 𝐡(knowns, rest)\n\nunknowns: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknown> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Output> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><ContinuousStateDerivative>).\nEvent Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Output> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Output> with type Real and variability = continuous or discrete. If <ModelStructure><ContinuousStateDerivative> is present, also the variables listed here as state derivatives.\nknowns: Real input variables of function h that changes its value in the actual Mode.\nrest: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔunknowns = (δh / δknowns) Δknowns\n\nArguments\n\nc::FMU3Instance Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nunknowns::AbstracArray{fmi3ValueReference}: Argument unknowns contains values of typefmi3ValueReference which are identifiers of a variable value of the model. unknowns can be equated with unknowns(variable described above).\nknowns::AbstractArray{fmi3ValueReference}: Argument knowns contains values of type fmi3ValueReference which are identifiers of a variable value of the model.knowns can be equated with knowns(variable described above).\nseed::AbstractArray{fmi3Float64}:The vector values Compute the partial derivative with respect to the given entries in vector knowns with the matching evaluate of sensitivity.\n\nReturns\n\nsensitivity::Array{fmi3Float64}: Return sensitivity contains the directional derivative vector values.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.11. Getting Partial Derivatives\n\nSee also fmi3GetAdjointDerivative.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetAdjointDerivative!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetAdjointDerivative!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.11. Getting Partial Derivatives\n\nThis function computes the adjoint derivatives v^T{sensitivity}= v^T{seed} ⋅ J of an FMU.\n\nunknowns - contains value references to the unknowns.\n\nnUnknowns - contains the length of argument unknowns.\n\nknowns - contains value references of the knowns.\n\nnKnowns - contains the length of argument knowns.\n\nseed - contains the components of the seed vector.\n\nnSeed - contains the length of seed.\n\nsensitivity - contains the components of the sensitivity vector.\n\nnSensitivity - contains the length of sensitivity.\n\nThis function can only be called if the 'ProvidesAdjointDerivatives' tag in the ModelDescription is set.\n\n\n\n\n\nfmi3GetAdjointDerivative!(c::FMU3Instance,\n            unknowns::AbstractArray{fmi3ValueReference},\n            nUnknowns::Csize_t,\n            knowns::AbstractArray{fmi3ValueReference},\n            nKnowns::Csize_t,\n            seed::AbstractArray{fmi3Float64},\n            nSeed::Csize_t,\n            sensitivity::AbstractArray{fmi3Float64},\n            nSensitivity::Csize_t)\n\nWrapper Function call to compute the partial derivative with respect to the variables unknowns.\n\nComputes the adjoint derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = 𝐡(knowns, rest)\n\nunknowns: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknown> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Output> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><ContinuousStateDerivative>).\nEvent Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Output> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Output> with type Real and variability = continuous or discrete. If <ModelStructure><ContinuousStateDerivative> is present, also the variables listed here as state derivatives.\nknowns: Real input variables of function h that changes its value in the actual Mode.\nrest: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔunknowns = (δh / δknowns) Δknowns\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nunknowns::AbstracArray{fmi3ValueReference}: Argument unknowns contains values of typefmi3ValueReference which are identifiers of a variable value of the model. unknowns can be equated with unknowns(variable described above).\nnUnknowns::Csize_t:\nknowns::AbstractArray{fmi3ValueReference}: Argument knowns contains values of type fmi3ValueReference which are identifiers of a variable value of the model.knowns can be equated with knowns(variable described above).\nnKnowns::Csize_t:\nseed::AbstractArray{fmi3Float64}:The vector values Compute the partial derivative with respect to the given entries in vector knowns with the matching evaluate of sensitivity.\nnKnowns::Csize_t:\nsensitivity::AbstractArray{fmi3Float64}: Stores the adjoint derivative vector values.\nnKnowns::Csize_t:\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.11. Getting Partial Derivatives\n\nSee also fmi3GetAdjointDerivative!.\n\n\n\n\n\nfmi3GetAdjointDerivative!(c::FMU3Instance,\n    unknowns::AbstractArray{fmi3ValueReference},\n    knowns::AbstractArray{fmi3ValueReference},\n    sensitivity::AbstractArray{fmi3Float64},\n    seed::AbstractArray{fmi3Float64})\n\nWrapper Function call to compute the partial derivative with respect to the variables unknowns.\n\nComputes the adjoint derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3) and Co-Simulation (section 4). In every Mode, the general form of the FMU equations are: unknowns = 𝐡(knowns, rest)\n\nunknowns: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknown> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Output> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><ContinuousStateDerivative>).\nEvent Mode (ModelExchange/CoSimulation): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Output> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Output> with type Real and variability = continuous or discrete. If <ModelStructure><ContinuousStateDerivative> is present, also the variables listed here as state derivatives.\nknowns: Real input variables of function h that changes its value in the actual Mode.\nrest: Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔunknowns = (δh / δknowns) Δknowns\n\nArguments\n\nc::FMU3Instance Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nunknowns::AbstracArray{fmi3ValueReference}: Argument unknowns contains values of typefmi3ValueReference which are identifiers of a variable value of the model. unknowns can be equated with unknowns(variable described above).\nknowns::AbstractArray{fmi3ValueReference}: Argument knowns contains values of type fmi3ValueReference which are identifiers of a variable value of the model.knowns can be equated with knowns(variable described above).\nsensitivity::AbstractArray{fmi3Float64}: Stores the directional derivative vector values.\nseed::AbstractArray{fmi3Float64}:The vector values Compute the partial derivative with respect to the given entries in vector knowns with the matching evaluate of sensitivity.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.11. Getting Partial Derivatives\n\nSee also fmi3GetAdjointDerivative!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetOutputDerivatives","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetOutputDerivatives","text":"fmi3GetOutputDerivatives!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nValueReferences::Csizet, order::AbstractArray{fmi3Int32}, values::AbstractArray{fmi3Float64}, nValues::Csizet)\n\nRetrieves the n-th derivative of output values.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::Array{fmi3ValueReference}: Argument vr is an array of nValueReferences value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\norder::Array{fmi3Int32}: Argument order is an array of fmi3Int32 values witch specifys the corresponding order of derivative of the real input variable.\n\nReturns\n\nvalue::AbstactArray{fmi3Float64}: Return value is an array which represents a vector with the values of the derivatives.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.12. Getting Derivatives of Continuous Outputs\n\nSee also fmi3GetOutputDerivatives.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetOutputDerivatives!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetOutputDerivatives!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.12. Getting Derivatives of Continuous Outputs\n\nRetrieves the n-th derivative of output values.\n\nvalueReferences - is a vector of value references that define the variables whose derivatives shall be retrieved. If multiple derivatives of a variable shall be retrieved, list the value reference multiple times.\n\nnValueReferences - is the dimension of the arguments valueReferences and orders.\n\norders - contains the orders of the respective derivative (1 means the first derivative, 2 means the second derivative, …, 0 is not allowed).  If multiple derivatives of a variable shall be retrieved, provide a list of them in the orders array, corresponding to a multiply occurring value reference in the valueReferences array. The highest order of derivatives retrievable can be determined by the 'maxOutputDerivativeOrder' tag in the ModelDescription.\n\nvalues - is a vector with the values of the derivatives. The order of the values elements is derived from a twofold serialization: the outer level corresponds to the combination of a value reference (e.g., valueReferences[k]) and order (e.g., orders[k]), and the inner level to the serialization of variables as defined in Section 2.2.6.1. The inner level does not exist for scalar variables.\n\nnValues - is the size of the argument values. nValues only equals nValueReferences if all corresponding output variables are scalar variables.\n\n\n\n\n\nfmi3GetOutputDerivatives!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nValueReferences::Csize_t, order::AbstractArray{fmi3Int32}, values::AbstractArray{fmi3Float64}, nValues::Csize_t)\n\nRetrieves the n-th derivative of output values.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::Array{fmi3ValueReference}: Argument vr is an array of nValueReferences value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\nnValueReferences::Csize_t: Argument nValueReferences defines the size of vr.\norder::Array{fmi3Int32}: Argument order is an array of fmi3Int32 values witch specifys the corresponding order of derivative of the real input variable.\nvalues::Array{fmi3Float64}: Argument values is an array with the actual values of these variables.\nnValues::Csize_t: Argument nValues defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.12. Getting Derivatives of Continuous Outputs\n\nSee also fmi3GetOutputDerivatives!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3SampleDirectionalDerivative fmi3SampleDirectionalDerivative! fmi3GetJacobian fmi3GetJacobian! fmi3GetFullJacobian fmi3GetFullJacobian!","category":"page"},{"location":"fmi3_lowlevel_library_functions/#TODO:-Clockstuff","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"TODO: Clockstuff","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3GetIntervalDecimal!\nfmi3SetIntervalDecimal\nfmi3GetIntervalFraction!\nfmi3SetIntervalFraction\nfmi3GetShiftDecimal!\nfmi3GetShiftFraction!\nfmi3GetClock\nfmi3GetClock!\nfmi3SetClock\nfmi3ActivateModelPartition","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetIntervalDecimal!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetIntervalDecimal!","text":"fmi3GetIntervalDecimal!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, intervals::AbstractArray{fmi3Float64}, qualifiers::fmi3IntervalQualifier)\n\nfmi3GetIntervalDecimal retrieves the interval until the next clock tick.\n\nFor input Clocks it is allowed to call this function to query the next activation interval. For changing aperiodic Clock, this function must be called in every Event Mode where this clock was activated. For countdown aperiodic Clock, this function must be called in every Event Mode. Clock intervals are computed in fmi3UpdateDiscreteStates (at the latest), therefore, this function should be called after fmi3UpdateDiscreteStates. For information about fmi3IntervalQualifiers, call ?fmi3IntervalQualifier\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nintervals::AbstractArray{fmi3Float64}: \nqualifiers::fmi3IntervalQualifier: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.9. Clocks\n\nSee also fmi3GetIntervalDecimal!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetIntervalDecimal","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetIntervalDecimal","text":"fmi3SetIntervalDecimal(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, intervals::AbstractArray{fmi3Float64})\n\nSets the interval until the next clock tick\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nintervals::AbstractArray{fmi3Float64}: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.9. Clocks\n\nSee also fmi3SetIntervalDecimal.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetIntervalFraction!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetIntervalFraction!","text":"fmi3GetIntervalFraction!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, intervalCounters::AbstractArray{fmi3UInt64}, resolutions::AbstractArray{fmi3UInt64}, qualifiers::fmi3IntervalQualifier)\n\nfmi3GetIntervalFraction retrieves the interval until the next clock tick.\n\nFor input Clocks it is allowed to call this function to query the next activation interval. For changing aperiodic Clock, this function must be called in every Event Mode where this clock was activated. For countdown aperiodic Clock, this function must be called in every Event Mode. Clock intervals are computed in fmi3UpdateDiscreteStates (at the latest), therefore, this function should be called after fmi3UpdateDiscreteStates. For information about fmi3IntervalQualifiers, call ?fmi3IntervalQualifier\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nintervalCounters::AbstractArray{fmi3UInt64}: \nresolutions::AbstractArray{fmi3UInt64}: \nqualifiers::fmi3IntervalQualifier: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.9. Clocks\n\nSee also fmi3GetIntervalFraction!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetIntervalFraction","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetIntervalFraction","text":"fmi3SetIntervalFraction(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, intervalCounters::AbstractArray{fmi3UInt64}, resolutions::AbstractArray{fmi3UInt64})\n\nSets the interval until the next clock tick. Only allowed if the attribute 'supportsFraction' is set.\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nintervalCounters::AbstractArray{fmi3UInt64}: \nresolutions::AbstractArray{fmi3UInt64}: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.9. Clocks\n\nSee also fmi3SetIntervalFraction.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetShiftDecimal!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetShiftDecimal!","text":"fmi3GetShiftDecimal!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, shifts::AbstractArray{fmi3Float64})\n\nfmi3GetShiftDecimal retrieves the delay to the first Clock tick from the FMU.\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nshifts::AbstractArray{fmi3Float64}:\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.9. Clocks\n\nSee also fmi3GetShiftDecimal!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetShiftFraction!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetShiftFraction!","text":"fmi3GetShiftFraction!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, shiftCounters::AbstractArray{fmi3UInt64}, resolutions::AbstractArray{fmi3UInt64})\n\nfmi3GetShiftFraction retrieves the delay to the first Clock tick from the FMU.\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nshiftCounters::AbstractArray{fmi3UInt64}:\nresolutions::AbstractArray{fmi3UInt64}:\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.9. Clocks\n\nSee also fmi3GetShiftFraction!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetClock","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetClock","text":"fmi3GetClock(c::FMU3Instance, vr::fmi3ValueReferenceFormat)\n\nGet the values of an array of fmi3Clock variables.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi3Clock}: returns values of an array of fmi3Clock variables with the dimension of fmi3ValueReferenceFormat length.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetClock.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetClock!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetClock!","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3GetClock!(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Clock}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::AbstractArray{fmi3Clock}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetClock!.\n\n\n\n\n\nfmi3GetClock!(c::FMU3Instance, vr::fmi3ValueReferenceFormat, values::AbstractArray{fmi3Clock})\n\nWrites the clock values of an array of variables in the given field\n\nfmi3GetClock! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi3Clock}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3GetClock!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3SetClock","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3SetClock","text":"Source: FMISpec3.0, Version D5ef1c1: 2.2.6.2. Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nnValue - is different from nvr if the value reference represents an array and therefore are more values tied to a single value reference.\n\n\n\n\n\nfmi3SetClock(c::FMU3Instance, vr::AbstractArray{fmi3ValueReference}, nvr::Csize_t, value::AbstractArray{fmi3Clock}, nvalue::Csize_t)\n\nFunctions to get and set values of variables idetified by their valueReference.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::AbstractArray{fmi3ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::AbstractArray{fmi3Clock}: Argument values is an AbstractArray with the actual values of these variables.\nnvalue::Csize_t: Argument nvalue defines the size of values.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetClock.\n\n\n\n\n\nfmi3SetClock(c::FMU3Instance, vr::fmi3ValueReferenceFormat, valueSizes::Union{AbstractArray{Csize_t}, Csize_t}, values::Union{AbstractArray{fmi3Clock}, fmi3Clock})\n\nSet the values of an array of clock variables\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi3ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi3ValueReference, Array{fmi3ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{AbstractArray{fmi3Clock}, fmi3Clock}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.6.2. Getting and Setting Variable Values\n\nSee also fmi3SetClock.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3ActivateModelPartition","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3ActivateModelPartition","text":"fmi3ActivateModelPartition(c::FMU3Instance, vr::fmi3ValueReference, activationTime::AbstractArray{fmi3Float64})\n\nDuring Clock Activation Mode (see 5.2.2.) after fmi3ActivateModelPartition has been called for a calculated, tunable or changing Clock the FMU provides the information on when the Clock will tick again, i.e. when the corresponding model partition has to be scheduled the next time.\n\nEach fmi3ActivateModelPartition call is associated with the computation of an exposed model partition of the FMU and therefore to an input Clock.\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReference: Argument vr is the value handel called \"ValueReference\" that define the variable that shall be inquired.\nactivationTime::AbstractArray{fmi3Float64}: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 5.2.2. State: Clock Activation Mode\n\nSee also fmi3ActivateModelPartition.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3CallbackClockUpdate","category":"page"},{"location":"fmi3_lowlevel_library_functions/#Conversion-functions","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Conversion functions","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"stringToType\ntypeToString\nstringToVariableNamingConvention\nvariableNamingConventionToString\nintervalQualifierToString","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMIBase.stringToType","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.stringToType","text":"stringToType(s::AbstractString)\n\nConvert s (\"coSimulation\", \"modelExchange\", \"scheduledExecution\") to the corresponding fmi3Type.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIBase.typeToString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.typeToString","text":"typeToString(c::fmi3Type)\n\nConvert fmi3Type c to the corresponding String (\"coSimulation\", \"modelExchange\", \"scheduledExecution\").\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIBase.stringToVariableNamingConvention","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.stringToVariableNamingConvention","text":"stringToVariableNamingConvention(s::AbstractString)\n\nConvert s (\"flat\", \"structured\") to the corresponding fmi3VariableNamingConvention.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIBase.variableNamingConventionToString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.variableNamingConventionToString","text":"variableNamingConventionToString(c::fmi3VariableNamingConvention)\n\nConvert fmi3VariableNamingConvention c to the corresponding String (\"flat\", \"structured\").\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIBase.intervalQualifierToString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.intervalQualifierToString","text":"intervalQualifierToString(c::fmi3IntervalQualifier)\n\nConvert fmi3IntervalQualifier c to the corresponding String (\"intervalNotYetKnown\", \"intervalUnchanged\", \"intervalChanged\").\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3StringToCausality fmi3StatusToString fmi3StringToInitial","category":"page"},{"location":"fmi3_lowlevel_library_functions/#External/Additional-functions","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"External/Additional functions","text":"","category":"section"},{"location":"fmi3_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi3GetNumberOfVariableDependencies\nfmi3GetNumberOfVariableDependencies!\nfmi3GetVariableDependencies\nfmi3GetVariableDependencies!","category":"page"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetNumberOfVariableDependencies","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetNumberOfVariableDependencies","text":"fmi3GetNumberOfVariableDependencies(c::FMU3Instance, vr::fmi3ValueReference, nvr::Ref{Csize_t})\n\nThe number of dependencies of a given variable, which may change if structural parameters are changed, can be retrieved by calling fmi3GetNumberOfVariableDependencies.\n\nThis information can only be retrieved if the 'providesPerElementDependencies' tag in the ModelDescription is set.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::Union{fmi3ValueReference, String}: Argument vr is the value handel called \"ValueReference\" that define the variable that shall be inquired.\n\nReturns\n\nsize::Integer: Return size is the number of variable dependencies for the given variable \n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.10. Dependencies of Variables\n\nSee also fmi3GetNumberOfVariableDependencies.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetNumberOfVariableDependencies!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetNumberOfVariableDependencies!","text":"fmi3GetNumberOfVariableDependencies!(c::FMU3Instance, vr::fmi3ValueReference, nvr::Ref{Csize_t})\n\nThe number of dependencies of a given variable, which may change if structural parameters are changed, can be retrieved by calling fmi3GetNumberOfVariableDependencies.\n\nThis information can only be retrieved if the 'providesPerElementDependencies' tag in the ModelDescription is set.\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReference: Argument vr is the value handel called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.10. Dependencies of Variables\n\nSee also fmi3GetNumberOfVariableDependencies!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMIImport.fmi3GetVariableDependencies","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi3GetVariableDependencies","text":"fmi3GetVariableDependencies(c::FMU3Instance, vr::Union{fmi3ValueReference, String})\n\nThe actual dependencies (of type dependenciesKind) can be retrieved by calling the function fmi3GetVariableDependencies:\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::Union{fmi3ValueReference, String}: Argument vr is the value handel called \"ValueReference\" that define the variable that shall be inquired.\n\nReturns\n\nelementIndicesOfDependent::AbstractArray{Csize_t}: must point to a buffer of size_t values of size nDependencies allocated by the calling environment.    It is filled in by this function with the element index of the dependent variable that dependency information is provided for. The element indices start with 1. Using the element index 0 means all elements of the variable. (Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in Section 2.2.6.1.)\nindependents::AbstractArray{fmi3ValueReference}:  must point to a buffer of fmi3ValueReference values of size nDependencies allocated by the calling environment.    It is filled in by this function with the value reference of the independent variable that this dependency entry is dependent upon.\nelementIndicesIndependents::AbstractArray{Csize_t}: must point to a buffer of size_t values of size nDependencies allocated by the calling environment.    It is filled in by this function with the element index of the independent variable that this dependency entry is dependent upon. The element indices start with 1. Using the element index 0 means all elements of the variable. (Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in Section 2.2.6.1.)\ndependencyKinds::AbstractArray{fmi3DependencyKind}: must point to a buffer of dependenciesKind values of size nDependencies allocated by the calling environment.    It is filled in by this function with the enumeration value describing the dependency of this dependency entry.\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.10. Dependencies of Variables\n\nSee also fmi3GetVariableDependencies!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_library_functions/#FMICore.fmi3GetVariableDependencies!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi3GetVariableDependencies!","text":"fmi3GetVariableDependencies!(c::FMU3Instance, vr::fmi3ValueReference, elementIndiceOfDependents::AbstractArray{Csize_t}, independents::AbstractArray{fmi3ValueReference},  \n    elementIndiceOfInpendents::AbstractArray{Csize_t}, dependencyKind::AbstractArray{fmi3DependencyKind}, ndependencies::Csize_t)\n\nThe actual dependencies (of type dependenciesKind) can be retrieved by calling the function fmi3GetVariableDependencies:\n\nArguments\n\nc::FMU3Instance: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\nvr::fmi3ValueReference: Argument vr is the value handel called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nelementIndiceOfDependents::AbstractArray{Csize_t}: must point to a buffer of size_t values of size nDependencies allocated by the calling environment.    It is filled in by this function with the element index of the dependent variable that dependency information is provided for. The element indices start with 1. Using the element index 0 means all elements of the variable. (Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in Section 2.2.6.1.)\nindependents::AbstractArray{fmi3ValueReference}:  must point to a buffer of fmi3ValueReference values of size nDependencies allocated by the calling environment.    It is filled in by this function with the value reference of the independent variable that this dependency entry is dependent upon.\nelementIndiceOfInpendents::AbstractArray{Csize_t}: must point to a buffer of size_t values of size nDependencies allocated by the calling environment.    It is filled in by this function with the element index of the independent variable that this dependency entry is dependent upon. The element indices start with 1. Using the element index 0 means all elements of the variable. (Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in Section 2.2.6.1.)\ndependencyKind::AbstractArray{fmi3DependencyKind}: must point to a buffer of dependenciesKind values of size nDependencies allocated by the calling environment.    It is filled in by this function with the enumeration value describing the dependency of this dependency entry.\nndependencies::Csize_t: specifies the number of dependencies that the calling environment allocated space for in the result buffers, and should correspond to value obtained by calling fmi3GetNumberOfVariableDependencies.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.2.10. Dependencies of Variables\n\nSee also fmi3GetVariableDependencies!.\n\n\n\n\n\n","category":"function"},{"location":"examples/parameter_optimization/#FMU-Parameter-Optimization","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Tutorial by Tobias Thummerer","category":"page"},{"location":"examples/parameter_optimization/#License","page":"FMU Parameter Optimization","title":"License","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/parameter_optimization/#Introduction-to-the-example","page":"FMU Parameter Optimization","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"This example shows how a parameter optimization can be set up for a FMU. The goal is to fit FMU parameters (and initial states), so that a reference trajectory is fit as good as possible.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Note, that this tutorial covers optimization without gradient information. Basically, FMI.jl supports gradient based optimization, too.","category":"page"},{"location":"examples/parameter_optimization/#Other-formats","page":"FMU Parameter Optimization","title":"Other formats","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/parameter_optimization/#Getting-started","page":"FMU Parameter Optimization","title":"Getting started","text":"","category":"section"},{"location":"examples/parameter_optimization/#Installation-prerequisites","page":"FMU Parameter Optimization","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":" Description Command\n1. Enter Package Manager via ]\n2. Install FMI via add FMI\n3. Install FMIZoo via add FMIZoo\n4. Install Optim  via add Optim\n5. Install Plots  via add Plots","category":"page"},{"location":"examples/parameter_optimization/#Code-section","page":"FMU Parameter Optimization","title":"Code section","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"# imports\nusing FMI\nusing FMIZoo\nusing Optim\nusing Plots\nusing DifferentialEquations","category":"page"},{"location":"examples/parameter_optimization/#Simulation-setup","page":"FMU Parameter Optimization","title":"Simulation setup","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Next, the start time and end time of the simulation are set.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"tStart = 0.0\ntStop = 5.0\ntStep = 0.1\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"0.0:0.1:5.0","category":"page"},{"location":"examples/parameter_optimization/#Import-FMU","page":"FMU Parameter Optimization","title":"Import FMU","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"# we use an FMU from the FMIZoo.jl\nfmu = loadFMU(\"SpringPendulum1D\", \"Dymola\", \"2022x\"; type=:ME)\ninfo(fmu)","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{fc15d8c4-758b-48e6-b00e-5bf47b8b14e5}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:23Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t0\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\tStates:\t\t\t\t2\n\n\n\t\t33554432 [\"mass.s\"]\n\t\t33554433 [\"mass.v\"]\n\tParameters:\t\t\t7\n\t\t16777216 [\"mass_s0\"]\n\t\t16777217 [\"mass_v0\"]\n\t\t16777218 [\"fixed.s0\"]\n\t\t16777219 [\"spring.c\"]\n\t\t16777220 [\"spring.s_rel0\"]\n\t\t16777221 [\"mass.m\"]\n\t\t16777222 [\"mass.L\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Now, the optimization objective (the function to minimize) needs to be defined. In this case, we just want to do a simulation and compare it to a regular sin wave.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"s_tar = 1.0 .+ sin.(tSave)\n\n# a function to simulate the FMU for given parameters\nfunction simulateFMU(p)\n    s0, v0, c, m = p # unpack parameters: s0 (start position), v0 (start velocity), c (spring constant) and m (pendulum mass)\n\n    # pack the parameters into a dictionary\n    paramDict = Dict{String, Any}()\n    paramDict[\"spring.c\"] = c \n    paramDict[\"mass.m\"] = m\n\n    # pack the start state\n    x0 = [s0, v0]\n\n    # simulate with given start stae and parameters\n    sol = simulate(fmu, (tStart, tStop); x0=x0, parameters=paramDict, saveat=tSave)\n\n    # get state with index 1 (the position) from the solution\n    s_res = getState(sol, 1; isIndex=true) \n\n    return s_res\nend\n\n# the optimization objective\nfunction objective(p)\n    s_res = simulateFMU(p)\n\n    # return the position error sum between FMU simulation (s_res) and target (s_tar)\n    return sum(abs.(s_tar .- s_res))    \nend","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"objective (generic function with 1 method)","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Now let's see how far we are away for our guess parameters:","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"s0 = 0.0 \nv0 = 0.0\nc = 1.0\nm = 1.0 \np = [s0, v0, c, m]\n\nobj_before = objective(p) # not really good!","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"54.432324541060666","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Let's have a look on the differences:","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"s_fmu = simulateFMU(p); # simulate the position\n\nplot(tSave, s_fmu; label=\"FMU\")\nplot!(tSave, s_tar; label=\"Optimization target\")","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"<?xml version=\"1.0\" encoding=\"utf-8\"?> <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"600\" height=\"400\" viewBox=\"0 0 2400 1600\"> <defs>   <clipPath id=\"clip780\">     <rect x=\"0\" y=\"0\" width=\"2400\" height=\"1600\"/>   </clipPath> </defs> <path clip-path=\"url(#clip780)\" d=\"M0 1600 L2400 1600 L2400 0 L0 0  Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"1\"/> <defs>   <clipPath id=\"clip781\">     <rect x=\"480\" y=\"0\" width=\"1681\" height=\"1600\"/>   </clipPath> </defs> <path clip-path=\"url(#clip780)\" d=\"M156.112 1486.45 L2352.76 1486.45 L2352.76 47.2441 L156.112 47.2441  Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"1\"/> <defs>   <clipPath id=\"clip782\">     <rect x=\"156\" y=\"47\" width=\"2198\" height=\"1440\"/>   </clipPath> </defs> <polyline clip-path=\"url(#clip782)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"218.281,1486.45 218.281,47.2441 \"/> <polyline clip-path=\"url(#clip782)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"632.742,1486.45 632.742,47.2441 \"/> <polyline clip-path=\"url(#clip782)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"1047.2,1486.45 1047.2,47.2441 \"/> <polyline clip-path=\"url(#clip782)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"1461.66,1486.45 1461.66,47.2441 \"/> <polyline clip-path=\"url(#clip782)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"1876.13,1486.45 1876.13,47.2441 \"/> <polyline clip-path=\"url(#clip782)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"2290.59,1486.45 2290.59,47.2441 \"/> <polyline clip-path=\"url(#clip782)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"156.112,1445.72 2352.76,1445.72 \"/> <polyline clip-path=\"url(#clip782)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"156.112,1137.01 2352.76,1137.01 \"/> <polyline clip-path=\"url(#clip782)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"156.112,828.294 2352.76,828.294 \"/> <polyline clip-path=\"url(#clip782)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"156.112,519.584 2352.76,519.584 \"/> <polyline clip-path=\"url(#clip782)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"156.112,210.873 2352.76,210.873 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,1486.45 2352.76,1486.45 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"218.281,1486.45 218.281,1467.55 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"632.742,1486.45 632.742,1467.55 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1047.2,1486.45 1047.2,1467.55 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1461.66,1486.45 1461.66,1467.55 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1876.13,1486.45 1876.13,1467.55 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"2290.59,1486.45 2290.59,1467.55 \"/> <path clip-path=\"url(#clip780)\" d=\"M218.281 1517.37 Q214.67 1517.37 212.842 1520.93 Q211.036 1524.47 211.036 1531.6 Q211.036 1538.71 212.842 1542.27 Q214.67 1545.82 218.281 1545.82 Q221.916 1545.82 223.721 1542.27 Q225.55 1538.71 225.55 1531.6 Q225.55 1524.47 223.721 1520.93 Q221.916 1517.37 218.281 1517.37 M218.281 1513.66 Q224.091 1513.66 227.147 1518.27 Q230.226 1522.85 230.226 1531.6 Q230.226 1540.33 227.147 1544.94 Q224.091 1549.52 218.281 1549.52 Q212.471 1549.52 209.392 1544.94 Q206.337 1540.33 206.337 1531.6 Q206.337 1522.85 209.392 1518.27 Q212.471 1513.66 218.281 1513.66 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M623.124 1544.91 L630.763 1544.91 L630.763 1518.55 L622.453 1520.21 L622.453 1515.95 L630.717 1514.29 L635.393 1514.29 L635.393 1544.91 L643.032 1544.91 L643.032 1548.85 L623.124 1548.85 L623.124 1544.91 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M1041.86 1544.91 L1058.18 1544.91 L1058.18 1548.85 L1036.23 1548.85 L1036.23 1544.91 Q1038.89 1542.16 1043.48 1537.53 Q1048.08 1532.88 1049.26 1531.53 Q1051.51 1529.01 1052.39 1527.27 Q1053.29 1525.51 1053.29 1523.82 Q1053.29 1521.07 1051.35 1519.33 Q1049.43 1517.6 1046.32 1517.6 Q1044.12 1517.6 1041.67 1518.36 Q1039.24 1519.13 1036.46 1520.68 L1036.46 1515.95 Q1039.29 1514.82 1041.74 1514.24 Q1044.19 1513.66 1046.23 1513.66 Q1051.6 1513.66 1054.8 1516.35 Q1057.99 1519.03 1057.99 1523.52 Q1057.99 1525.65 1057.18 1527.57 Q1056.39 1529.47 1054.29 1532.07 Q1053.71 1532.74 1050.61 1535.95 Q1047.5 1539.15 1041.86 1544.91 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M1465.91 1530.21 Q1469.27 1530.93 1471.14 1533.2 Q1473.04 1535.47 1473.04 1538.8 Q1473.04 1543.92 1469.52 1546.72 Q1466 1549.52 1459.52 1549.52 Q1457.35 1549.52 1455.03 1549.08 Q1452.74 1548.66 1450.29 1547.81 L1450.29 1543.29 Q1452.23 1544.43 1454.55 1545.01 Q1456.86 1545.58 1459.38 1545.58 Q1463.78 1545.58 1466.07 1543.85 Q1468.39 1542.11 1468.39 1538.8 Q1468.39 1535.75 1466.24 1534.03 Q1464.11 1532.3 1460.29 1532.3 L1456.26 1532.3 L1456.26 1528.45 L1460.47 1528.45 Q1463.92 1528.45 1465.75 1527.09 Q1467.58 1525.7 1467.58 1523.11 Q1467.58 1520.45 1465.68 1519.03 Q1463.81 1517.6 1460.29 1517.6 Q1458.37 1517.6 1456.17 1518.01 Q1453.97 1518.43 1451.33 1519.31 L1451.33 1515.14 Q1453.99 1514.4 1456.31 1514.03 Q1458.64 1513.66 1460.7 1513.66 Q1466.03 1513.66 1469.13 1516.09 Q1472.23 1518.5 1472.23 1522.62 Q1472.23 1525.49 1470.59 1527.48 Q1468.94 1529.45 1465.91 1530.21 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M1879.13 1518.36 L1867.33 1536.81 L1879.13 1536.81 L1879.13 1518.36 M1877.91 1514.29 L1883.79 1514.29 L1883.79 1536.81 L1888.72 1536.81 L1888.72 1540.7 L1883.79 1540.7 L1883.79 1548.85 L1879.13 1548.85 L1879.13 1540.7 L1863.53 1540.7 L1863.53 1536.19 L1877.91 1514.29 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M2280.86 1514.29 L2299.22 1514.29 L2299.22 1518.22 L2285.15 1518.22 L2285.15 1526.7 Q2286.17 1526.35 2287.18 1526.19 Q2288.2 1526 2289.22 1526 Q2295.01 1526 2298.39 1529.17 Q2301.77 1532.34 2301.77 1537.76 Q2301.77 1543.34 2298.3 1546.44 Q2294.82 1549.52 2288.5 1549.52 Q2286.33 1549.52 2284.06 1549.15 Q2281.81 1548.78 2279.41 1548.04 L2279.41 1543.34 Q2281.49 1544.47 2283.71 1545.03 Q2285.93 1545.58 2288.41 1545.58 Q2292.42 1545.58 2294.75 1543.48 Q2297.09 1541.37 2297.09 1537.76 Q2297.09 1534.15 2294.75 1532.04 Q2292.42 1529.94 2288.41 1529.94 Q2286.54 1529.94 2284.66 1530.35 Q2282.81 1530.77 2280.86 1531.65 L2280.86 1514.29 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,1486.45 156.112,47.2441 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,1445.72 175.01,1445.72 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,1137.01 175.01,1137.01 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,828.294 175.01,828.294 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,519.584 175.01,519.584 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,210.873 175.01,210.873 \"/> <path clip-path=\"url(#clip780)\" d=\"M62.9365 1431.51 Q59.3254 1431.51 57.4967 1435.08 Q55.6912 1438.62 55.6912 1445.75 Q55.6912 1452.86 57.4967 1456.42 Q59.3254 1459.96 62.9365 1459.96 Q66.5707 1459.96 68.3763 1456.42 Q70.205 1452.86 70.205 1445.75 Q70.205 1438.62 68.3763 1435.08 Q66.5707 1431.51 62.9365 1431.51 M62.9365 1427.81 Q68.7467 1427.81 71.8022 1432.42 Q74.8809 1437 74.8809 1445.75 Q74.8809 1454.48 71.8022 1459.08 Q68.7467 1463.67 62.9365 1463.67 Q57.1264 1463.67 54.0477 1459.08 Q50.9921 1454.48 50.9921 1445.75 Q50.9921 1437 54.0477 1432.42 Q57.1264 1427.81 62.9365 1427.81 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M83.0984 1457.12 L87.9827 1457.12 L87.9827 1463 L83.0984 1463 L83.0984 1457.12 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M108.168 1431.51 Q104.557 1431.51 102.728 1435.08 Q100.922 1438.62 100.922 1445.75 Q100.922 1452.86 102.728 1456.42 Q104.557 1459.96 108.168 1459.96 Q111.802 1459.96 113.608 1456.42 Q115.436 1452.86 115.436 1445.75 Q115.436 1438.62 113.608 1435.08 Q111.802 1431.51 108.168 1431.51 M108.168 1427.81 Q113.978 1427.81 117.033 1432.42 Q120.112 1437 120.112 1445.75 Q120.112 1454.48 117.033 1459.08 Q113.978 1463.67 108.168 1463.67 Q102.358 1463.67 99.2789 1459.08 Q96.2234 1454.48 96.2234 1445.75 Q96.2234 1437 99.2789 1432.42 Q102.358 1427.81 108.168 1427.81 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M63.9319 1122.8 Q60.3208 1122.8 58.4921 1126.37 Q56.6865 1129.91 56.6865 1137.04 Q56.6865 1144.15 58.4921 1147.71 Q60.3208 1151.25 63.9319 1151.25 Q67.5661 1151.25 69.3717 1147.71 Q71.2004 1144.15 71.2004 1137.04 Q71.2004 1129.91 69.3717 1126.37 Q67.5661 1122.8 63.9319 1122.8 M63.9319 1119.1 Q69.742 1119.1 72.7976 1123.71 Q75.8763 1128.29 75.8763 1137.04 Q75.8763 1145.77 72.7976 1150.37 Q69.742 1154.96 63.9319 1154.96 Q58.1217 1154.96 55.043 1150.37 Q51.9875 1145.77 51.9875 1137.04 Q51.9875 1128.29 55.043 1123.71 Q58.1217 1119.1 63.9319 1119.1 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M84.0938 1148.41 L88.978 1148.41 L88.978 1154.29 L84.0938 1154.29 L84.0938 1148.41 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M99.2095 1119.73 L117.566 1119.73 L117.566 1123.66 L103.492 1123.66 L103.492 1132.13 Q104.51 1131.79 105.529 1131.62 Q106.547 1131.44 107.566 1131.44 Q113.353 1131.44 116.733 1134.61 Q120.112 1137.78 120.112 1143.2 Q120.112 1148.78 116.64 1151.88 Q113.168 1154.96 106.848 1154.96 Q104.672 1154.96 102.404 1154.59 Q100.159 1154.22 97.7511 1153.47 L97.7511 1148.78 Q99.8345 1149.91 102.057 1150.47 Q104.279 1151.02 106.756 1151.02 Q110.76 1151.02 113.098 1148.91 Q115.436 1146.81 115.436 1143.2 Q115.436 1139.59 113.098 1137.48 Q110.76 1135.37 106.756 1135.37 Q104.881 1135.37 103.006 1135.79 Q101.154 1136.21 99.2095 1137.09 L99.2095 1119.73 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M53.7467 841.639 L61.3856 841.639 L61.3856 815.274 L53.0754 816.94 L53.0754 812.681 L61.3393 811.014 L66.0152 811.014 L66.0152 841.639 L73.654 841.639 L73.654 845.574 L53.7467 845.574 L53.7467 841.639 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M83.0984 839.695 L87.9827 839.695 L87.9827 845.574 L83.0984 845.574 L83.0984 839.695 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M108.168 814.093 Q104.557 814.093 102.728 817.658 Q100.922 821.199 100.922 828.329 Q100.922 835.436 102.728 839 Q104.557 842.542 108.168 842.542 Q111.802 842.542 113.608 839 Q115.436 835.436 115.436 828.329 Q115.436 821.199 113.608 817.658 Q111.802 814.093 108.168 814.093 M108.168 810.389 Q113.978 810.389 117.033 814.996 Q120.112 819.579 120.112 828.329 Q120.112 837.056 117.033 841.662 Q113.978 846.246 108.168 846.246 Q102.358 846.246 99.2789 841.662 Q96.2234 837.056 96.2234 828.329 Q96.2234 819.579 99.2789 814.996 Q102.358 810.389 108.168 810.389 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M54.7421 532.929 L62.381 532.929 L62.381 506.563 L54.0708 508.23 L54.0708 503.97 L62.3347 502.304 L67.0106 502.304 L67.0106 532.929 L74.6494 532.929 L74.6494 536.864 L54.7421 536.864 L54.7421 532.929 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M84.0938 530.984 L88.978 530.984 L88.978 536.864 L84.0938 536.864 L84.0938 530.984 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M99.2095 502.304 L117.566 502.304 L117.566 506.239 L103.492 506.239 L103.492 514.711 Q104.51 514.364 105.529 514.202 Q106.547 514.017 107.566 514.017 Q113.353 514.017 116.733 517.188 Q120.112 520.359 120.112 525.776 Q120.112 531.354 116.64 534.456 Q113.168 537.535 106.848 537.535 Q104.672 537.535 102.404 537.165 Q100.159 536.794 97.7511 536.054 L97.7511 531.354 Q99.8345 532.489 102.057 533.044 Q104.279 533.6 106.756 533.6 Q110.76 533.6 113.098 531.493 Q115.436 529.387 115.436 525.776 Q115.436 522.165 113.098 520.058 Q110.76 517.952 106.756 517.952 Q104.881 517.952 103.006 518.368 Q101.154 518.785 99.2095 519.665 L99.2095 502.304 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M56.9643 224.218 L73.2837 224.218 L73.2837 228.153 L51.3393 228.153 L51.3393 224.218 Q54.0014 221.463 58.5847 216.834 Q63.1911 212.181 64.3717 210.838 Q66.617 208.315 67.4967 206.579 Q68.3994 204.82 68.3994 203.13 Q68.3994 200.375 66.455 198.639 Q64.5337 196.903 61.4319 196.903 Q59.2328 196.903 56.7791 197.667 Q54.3486 198.431 51.5708 199.982 L51.5708 195.26 Q54.3949 194.125 56.8486 193.547 Q59.3023 192.968 61.3393 192.968 Q66.7096 192.968 69.9041 195.653 Q73.0985 198.338 73.0985 202.829 Q73.0985 204.959 72.2883 206.88 Q71.5013 208.778 69.3948 211.371 Q68.8161 212.042 65.7143 215.26 Q62.6124 218.454 56.9643 224.218 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M83.0984 222.273 L87.9827 222.273 L87.9827 228.153 L83.0984 228.153 L83.0984 222.273 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M108.168 196.672 Q104.557 196.672 102.728 200.237 Q100.922 203.778 100.922 210.908 Q100.922 218.014 102.728 221.579 Q104.557 225.121 108.168 225.121 Q111.802 225.121 113.608 221.579 Q115.436 218.014 115.436 210.908 Q115.436 203.778 113.608 200.237 Q111.802 196.672 108.168 196.672 M108.168 192.968 Q113.978 192.968 117.033 197.575 Q120.112 202.158 120.112 210.908 Q120.112 219.635 117.033 224.241 Q113.978 228.824 108.168 228.824 Q102.358 228.824 99.2789 224.241 Q96.2234 219.635 96.2234 210.908 Q96.2234 202.158 99.2789 197.575 Q102.358 192.968 108.168 192.968 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><polyline clip-path=\"url(#clip782)\" style=\"stroke:#009af9; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"218.281,1445.72 259.727,1442.32 301.174,1432.18 342.62,1415.38 384.066,1392.1 425.512,1362.58 466.958,1327.09 508.404,1286.01 549.85,1239.73 591.296,1188.73 632.742,1133.51 674.188,1074.62 715.635,1012.66 757.081,948.231 798.527,881.991 839.973,814.597 881.419,746.724 922.865,679.049 964.311,612.248 1005.76,546.989 1047.2,483.923 1088.65,423.682 1130.1,366.866 1171.54,314.044 1212.99,265.743 1254.43,222.447 1295.88,184.586 1337.33,152.541 1378.77,126.63 1420.22,107.114 1461.66,94.1859 1503.11,87.9763 1544.56,88.5467 1586,95.8916 1627.45,109.937 1668.9,130.544 1710.34,157.505 1751.79,190.552 1793.23,229.354 1834.68,273.523 1876.13,322.619 1917.57,376.15 1959.02,433.582 2000.46,494.341 2041.91,557.82 2083.36,623.385 2124.8,690.379 2166.25,758.135 2207.69,825.975 2249.14,893.222 2290.59,959.202 \"/> <polyline clip-path=\"url(#clip782)\" style=\"stroke:#e26f46; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"218.281,828.294 259.727,766.655 301.174,705.632 342.62,645.834 384.066,587.859 425.512,532.287 466.958,479.672 508.404,430.541 549.85,385.383 591.296,344.652 632.742,308.752 674.188,278.044 715.635,252.834 757.081,233.373 798.527,219.857 839.973,212.42 881.419,211.136 922.865,216.019 964.311,227.02 1005.76,244.029 1047.2,266.875 1088.65,295.33 1130.1,329.111 1171.54,367.88 1212.99,411.249 1254.43,458.785 1295.88,510.013 1337.33,564.421 1378.77,621.466 1420.22,680.577 1461.66,741.164 1503.11,802.622 1544.56,864.336 1586,925.69 1627.45,986.071 1668.9,1044.88 1710.34,1101.52 1751.79,1155.43 1793.23,1206.07 1834.68,1252.94 1876.13,1295.56 1917.57,1333.52 1959.02,1366.42 2000.46,1393.95 2041.91,1415.83 2083.36,1431.84 2124.8,1441.82 2166.25,1445.67 2207.69,1443.35 2249.14,1434.88 2290.59,1420.35 \"/> <path clip-path=\"url(#clip780)\" d=\"M1601.19 250.738 L2279.53 250.738 L2279.53 95.2176 L1601.19 95.2176  Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"1\"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1601.19,250.738 2279.53,250.738 2279.53,95.2176 1601.19,95.2176 1601.19,250.738 \"/> <polyline clip-path=\"url(#clip780)\" style=\"stroke:#009af9; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1625.6,147.058 1772.04,147.058 \"/> <path clip-path=\"url(#clip780)\" d=\"M1796.45 129.778 L1816.31 129.778 L1816.31 133.713 L1801.13 133.713 L1801.13 143.898 L1814.83 143.898 L1814.83 147.833 L1801.13 147.833 L1801.13 164.338 L1796.45 164.338 L1796.45 129.778 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M1823.72 129.778 L1830.69 129.778 L1839.5 153.296 L1848.37 129.778 L1855.34 129.778 L1855.34 164.338 L1850.78 164.338 L1850.78 133.99 L1841.87 157.694 L1837.17 157.694 L1828.25 133.99 L1828.25 164.338 L1823.72 164.338 L1823.72 129.778 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M1864.09 129.778 L1868.79 129.778 L1868.79 150.773 Q1868.79 156.328 1870.8 158.782 Q1872.81 161.213 1877.33 161.213 Q1881.82 161.213 1883.83 158.782 Q1885.85 156.328 1885.85 150.773 L1885.85 129.778 L1890.55 129.778 L1890.55 151.352 Q1890.55 158.111 1887.19 161.56 Q1883.86 165.009 1877.33 165.009 Q1870.78 165.009 1867.42 161.56 Q1864.09 158.111 1864.09 151.352 L1864.09 129.778 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><polyline clip-path=\"url(#clip780)\" style=\"stroke:#e26f46; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1625.6,198.898 1772.04,198.898 \"/> <path clip-path=\"url(#clip780)\" d=\"M1812.47 184.789 Q1807.38 184.789 1804.37 188.585 Q1801.38 192.381 1801.38 198.932 Q1801.38 205.46 1804.37 209.256 Q1807.38 213.053 1812.47 213.053 Q1817.56 213.053 1820.52 209.256 Q1823.51 205.46 1823.51 198.932 Q1823.51 192.381 1820.52 188.585 Q1817.56 184.789 1812.47 184.789 M1812.47 180.993 Q1819.74 180.993 1824.09 185.877 Q1828.44 190.738 1828.44 198.932 Q1828.44 207.104 1824.09 211.988 Q1819.74 216.849 1812.47 216.849 Q1805.18 216.849 1800.8 211.988 Q1796.45 207.127 1796.45 198.932 Q1796.45 190.738 1800.8 185.877 Q1805.18 180.993 1812.47 180.993 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M1839.69 212.289 L1839.69 226.039 L1835.41 226.039 L1835.41 190.252 L1839.69 190.252 L1839.69 194.187 Q1841.03 191.872 1843.07 190.761 Q1845.13 189.627 1847.98 189.627 Q1852.7 189.627 1855.64 193.377 Q1858.6 197.127 1858.6 203.238 Q1858.6 209.349 1855.64 213.099 Q1852.7 216.849 1847.98 216.849 Q1845.13 216.849 1843.07 215.738 Q1841.03 214.603 1839.69 212.289 M1854.18 203.238 Q1854.18 198.539 1852.24 195.877 Q1850.31 193.192 1846.94 193.192 Q1843.56 193.192 1841.61 195.877 Q1839.69 198.539 1839.69 203.238 Q1839.69 207.937 1841.61 210.622 Q1843.56 213.284 1846.94 213.284 Q1850.31 213.284 1852.24 210.622 Q1854.18 207.937 1854.18 203.238 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M1869.87 182.891 L1869.87 190.252 L1878.65 190.252 L1878.65 193.562 L1869.87 193.562 L1869.87 207.636 Q1869.87 210.807 1870.73 211.71 Q1871.61 212.613 1874.27 212.613 L1878.65 212.613 L1878.65 216.178 L1874.27 216.178 Q1869.34 216.178 1867.47 214.349 Q1865.59 212.497 1865.59 207.636 L1865.59 193.562 L1862.47 193.562 L1862.47 190.252 L1865.59 190.252 L1865.59 182.891 L1869.87 182.891 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M1884.25 190.252 L1888.51 190.252 L1888.51 216.178 L1884.25 216.178 L1884.25 190.252 M1884.25 180.159 L1888.51 180.159 L1888.51 185.553 L1884.25 185.553 L1884.25 180.159 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M1917.61 195.229 Q1919.2 192.358 1921.43 190.993 Q1923.65 189.627 1926.66 189.627 Q1930.71 189.627 1932.91 192.474 Q1935.11 195.298 1935.11 200.529 L1935.11 216.178 L1930.82 216.178 L1930.82 200.668 Q1930.82 196.942 1929.5 195.136 Q1928.18 193.33 1925.48 193.33 Q1922.17 193.33 1920.24 195.53 Q1918.32 197.729 1918.32 201.525 L1918.32 216.178 L1914.04 216.178 L1914.04 200.668 Q1914.04 196.918 1912.72 195.136 Q1911.4 193.33 1908.65 193.33 Q1905.38 193.33 1903.46 195.553 Q1901.54 197.752 1901.54 201.525 L1901.54 216.178 L1897.26 216.178 L1897.26 190.252 L1901.54 190.252 L1901.54 194.28 Q1903 191.895 1905.04 190.761 Q1907.07 189.627 1909.87 189.627 Q1912.7 189.627 1914.67 191.062 Q1916.66 192.497 1917.61 195.229 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M1943.6 190.252 L1947.86 190.252 L1947.86 216.178 L1943.6 216.178 L1943.6 190.252 M1943.6 180.159 L1947.86 180.159 L1947.86 185.553 L1943.6 185.553 L1943.6 180.159 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M1954.92 190.252 L1975.15 190.252 L1975.15 194.141 L1959.13 212.775 L1975.15 212.775 L1975.15 216.178 L1954.34 216.178 L1954.34 212.289 L1970.36 193.655 L1954.92 193.655 L1954.92 190.252 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M1993.44 203.145 Q1988.28 203.145 1986.29 204.326 Q1984.3 205.506 1984.3 208.354 Q1984.3 210.622 1985.78 211.965 Q1987.28 213.284 1989.85 213.284 Q1993.39 213.284 1995.52 210.784 Q1997.67 208.261 1997.67 204.094 L1997.67 203.145 L1993.44 203.145 M2001.93 201.386 L2001.93 216.178 L1997.67 216.178 L1997.67 212.242 Q1996.22 214.603 1994.04 215.738 Q1991.86 216.849 1988.72 216.849 Q1984.74 216.849 1982.37 214.627 Q1980.04 212.381 1980.04 208.631 Q1980.04 204.256 1982.95 202.034 Q1985.89 199.812 1991.7 199.812 L1997.67 199.812 L1997.67 199.395 Q1997.67 196.455 1995.73 194.858 Q1993.81 193.238 1990.31 193.238 Q1988.09 193.238 1985.99 193.77 Q1983.88 194.303 1981.93 195.367 L1981.93 191.432 Q1984.27 190.53 1986.47 190.09 Q1988.67 189.627 1990.75 189.627 Q1996.38 189.627 1999.16 192.543 Q2001.93 195.46 2001.93 201.386 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M2014.92 182.891 L2014.92 190.252 L2023.69 190.252 L2023.69 193.562 L2014.92 193.562 L2014.92 207.636 Q2014.92 210.807 2015.78 211.71 Q2016.66 212.613 2019.32 212.613 L2023.69 212.613 L2023.69 216.178 L2019.32 216.178 Q2014.39 216.178 2012.51 214.349 Q2010.64 212.497 2010.64 207.636 L2010.64 193.562 L2007.51 193.562 L2007.51 190.252 L2010.64 190.252 L2010.64 182.891 L2014.92 182.891 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M2029.3 190.252 L2033.55 190.252 L2033.55 216.178 L2029.3 216.178 L2029.3 190.252 M2029.3 180.159 L2033.55 180.159 L2033.55 185.553 L2029.3 185.553 L2029.3 180.159 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M2052.51 193.238 Q2049.09 193.238 2047.1 195.923 Q2045.11 198.585 2045.11 203.238 Q2045.11 207.891 2047.07 210.576 Q2049.06 213.238 2052.51 213.238 Q2055.92 213.238 2057.91 210.553 Q2059.9 207.867 2059.9 203.238 Q2059.9 198.631 2057.91 195.946 Q2055.92 193.238 2052.51 193.238 M2052.51 189.627 Q2058.07 189.627 2061.24 193.238 Q2064.41 196.849 2064.41 203.238 Q2064.41 209.604 2061.24 213.238 Q2058.07 216.849 2052.51 216.849 Q2046.93 216.849 2043.76 213.238 Q2040.61 209.604 2040.61 203.238 Q2040.61 196.849 2043.76 193.238 Q2046.93 189.627 2052.51 189.627 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M2093.02 200.529 L2093.02 216.178 L2088.76 216.178 L2088.76 200.668 Q2088.76 196.988 2087.33 195.159 Q2085.89 193.33 2083.02 193.33 Q2079.57 193.33 2077.58 195.53 Q2075.59 197.729 2075.59 201.525 L2075.59 216.178 L2071.31 216.178 L2071.31 190.252 L2075.59 190.252 L2075.59 194.28 Q2077.12 191.942 2079.18 190.784 Q2081.26 189.627 2083.97 189.627 Q2088.44 189.627 2090.73 192.405 Q2093.02 195.159 2093.02 200.529 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M2120.8 182.891 L2120.8 190.252 L2129.57 190.252 L2129.57 193.562 L2120.8 193.562 L2120.8 207.636 Q2120.8 210.807 2121.66 211.71 Q2122.54 212.613 2125.2 212.613 L2129.57 212.613 L2129.57 216.178 L2125.2 216.178 Q2120.27 216.178 2118.39 214.349 Q2116.52 212.497 2116.52 207.636 L2116.52 193.562 L2113.39 193.562 L2113.39 190.252 L2116.52 190.252 L2116.52 182.891 L2120.8 182.891 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M2146.96 203.145 Q2141.79 203.145 2139.8 204.326 Q2137.81 205.506 2137.81 208.354 Q2137.81 210.622 2139.29 211.965 Q2140.8 213.284 2143.37 213.284 Q2146.91 213.284 2149.04 210.784 Q2151.19 208.261 2151.19 204.094 L2151.19 203.145 L2146.96 203.145 M2155.45 201.386 L2155.45 216.178 L2151.19 216.178 L2151.19 212.242 Q2149.73 214.603 2147.56 215.738 Q2145.38 216.849 2142.23 216.849 Q2138.25 216.849 2135.89 214.627 Q2133.55 212.381 2133.55 208.631 Q2133.55 204.256 2136.47 202.034 Q2139.41 199.812 2145.22 199.812 L2151.19 199.812 L2151.19 199.395 Q2151.19 196.455 2149.25 194.858 Q2147.33 193.238 2143.83 193.238 Q2141.61 193.238 2139.5 193.77 Q2137.4 194.303 2135.45 195.367 L2135.45 191.432 Q2137.79 190.53 2139.99 190.09 Q2142.19 189.627 2144.27 189.627 Q2149.9 189.627 2152.67 192.543 Q2155.45 195.46 2155.45 201.386 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M2179.25 194.233 Q2178.53 193.817 2177.67 193.631 Q2176.84 193.423 2175.82 193.423 Q2172.21 193.423 2170.27 195.784 Q2168.35 198.122 2168.35 202.52 L2168.35 216.178 L2164.06 216.178 L2164.06 190.252 L2168.35 190.252 L2168.35 194.28 Q2169.69 191.918 2171.84 190.784 Q2173.99 189.627 2177.07 189.627 Q2177.51 189.627 2178.04 189.696 Q2178.58 189.743 2179.22 189.858 L2179.25 194.233 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M2199.94 202.914 Q2199.94 198.284 2198.02 195.738 Q2196.12 193.192 2192.67 193.192 Q2189.25 193.192 2187.33 195.738 Q2185.43 198.284 2185.43 202.914 Q2185.43 207.52 2187.33 210.066 Q2189.25 212.613 2192.67 212.613 Q2196.12 212.613 2198.02 210.066 Q2199.94 207.52 2199.94 202.914 M2204.2 212.96 Q2204.2 219.58 2201.26 222.798 Q2198.32 226.039 2192.26 226.039 Q2190.01 226.039 2188.02 225.691 Q2186.03 225.367 2184.16 224.673 L2184.16 220.529 Q2186.03 221.548 2187.86 222.034 Q2189.69 222.52 2191.59 222.52 Q2195.78 222.52 2197.86 220.321 Q2199.94 218.145 2199.94 213.724 L2199.94 211.617 Q2198.62 213.909 2196.56 215.043 Q2194.5 216.178 2191.63 216.178 Q2186.86 216.178 2183.95 212.543 Q2181.03 208.909 2181.03 202.914 Q2181.03 196.895 2183.95 193.261 Q2186.86 189.627 2191.63 189.627 Q2194.5 189.627 2196.56 190.761 Q2198.62 191.895 2199.94 194.187 L2199.94 190.252 L2204.2 190.252 L2204.2 212.96 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M2235.15 202.15 L2235.15 204.233 L2215.57 204.233 Q2215.85 208.631 2218.21 210.946 Q2220.59 213.238 2224.83 213.238 Q2227.28 213.238 2229.57 212.636 Q2231.89 212.034 2234.16 210.83 L2234.16 214.858 Q2231.86 215.83 2229.46 216.34 Q2227.05 216.849 2224.57 216.849 Q2218.37 216.849 2214.73 213.238 Q2211.12 209.627 2211.12 203.469 Q2211.12 197.104 2214.55 193.377 Q2218 189.627 2223.83 189.627 Q2229.06 189.627 2232.1 193.006 Q2235.15 196.363 2235.15 202.15 M2230.89 200.9 Q2230.85 197.405 2228.92 195.321 Q2227.03 193.238 2223.88 193.238 Q2220.31 193.238 2218.16 195.252 Q2216.03 197.266 2215.71 200.923 L2230.89 200.9 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip780)\" d=\"M2246.35 182.891 L2246.35 190.252 L2255.13 190.252 L2255.13 193.562 L2246.35 193.562 L2246.35 207.636 Q2246.35 210.807 2247.21 211.71 Q2248.09 212.613 2250.75 212.613 L2255.13 212.613 L2255.13 216.178 L2250.75 216.178 Q2245.82 216.178 2243.95 214.349 Q2242.07 212.497 2242.07 207.636 L2242.07 193.562 L2238.95 193.562 L2238.95 190.252 L2242.07 190.252 L2242.07 182.891 L2246.35 182.891 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /></svg>","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Not that good. So let's do a bit of optimization!","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"opt = Optim.optimize(objective, p; iterations=250) # do max. 250 iterations\nobj_after = opt.minimum # much better!\np_res = opt.minimizer # the optimized parameters","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"4-element Vector{Float64}:\n 1.000927423495889\n 0.9780437253734777\n 0.11212447550094248\n 0.09761028417513656","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Looks promising, let's have a look on the results plot:","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"s_fmu = simulateFMU(p_res); # simulate the position\n\nplot(tSave, s_fmu; label=\"FMU\")\nplot!(tSave, s_tar; label=\"Optimization target\")","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"<?xml version=\"1.0\" encoding=\"utf-8\"?> <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"600\" height=\"400\" viewBox=\"0 0 2400 1600\"> <defs>   <clipPath id=\"clip870\">     <rect x=\"0\" y=\"0\" width=\"2400\" height=\"1600\"/>   </clipPath> </defs> <path clip-path=\"url(#clip870)\" d=\"M0 1600 L2400 1600 L2400 0 L0 0  Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"1\"/> <defs>   <clipPath id=\"clip871\">     <rect x=\"480\" y=\"0\" width=\"1681\" height=\"1600\"/>   </clipPath> </defs> <path clip-path=\"url(#clip870)\" d=\"M156.112 1486.45 L2352.76 1486.45 L2352.76 47.2441 L156.112 47.2441  Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"1\"/> <defs>   <clipPath id=\"clip872\">     <rect x=\"156\" y=\"47\" width=\"2198\" height=\"1440\"/>   </clipPath> </defs> <polyline clip-path=\"url(#clip872)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"218.281,1486.45 218.281,47.2441 \"/> <polyline clip-path=\"url(#clip872)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"632.742,1486.45 632.742,47.2441 \"/> <polyline clip-path=\"url(#clip872)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"1047.2,1486.45 1047.2,47.2441 \"/> <polyline clip-path=\"url(#clip872)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"1461.66,1486.45 1461.66,47.2441 \"/> <polyline clip-path=\"url(#clip872)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"1876.13,1486.45 1876.13,47.2441 \"/> <polyline clip-path=\"url(#clip872)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"2290.59,1486.45 2290.59,47.2441 \"/> <polyline clip-path=\"url(#clip872)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"156.112,1445.77 2352.76,1445.77 \"/> <polyline clip-path=\"url(#clip872)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"156.112,1109.56 2352.76,1109.56 \"/> <polyline clip-path=\"url(#clip872)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"156.112,773.351 2352.76,773.351 \"/> <polyline clip-path=\"url(#clip872)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"156.112,437.143 2352.76,437.143 \"/> <polyline clip-path=\"url(#clip872)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:2; stroke-opacity:0.1; fill:none\" points=\"156.112,100.935 2352.76,100.935 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,1486.45 2352.76,1486.45 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"218.281,1486.45 218.281,1467.55 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"632.742,1486.45 632.742,1467.55 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1047.2,1486.45 1047.2,1467.55 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1461.66,1486.45 1461.66,1467.55 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1876.13,1486.45 1876.13,1467.55 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"2290.59,1486.45 2290.59,1467.55 \"/> <path clip-path=\"url(#clip870)\" d=\"M218.281 1517.37 Q214.67 1517.37 212.842 1520.93 Q211.036 1524.47 211.036 1531.6 Q211.036 1538.71 212.842 1542.27 Q214.67 1545.82 218.281 1545.82 Q221.916 1545.82 223.721 1542.27 Q225.55 1538.71 225.55 1531.6 Q225.55 1524.47 223.721 1520.93 Q221.916 1517.37 218.281 1517.37 M218.281 1513.66 Q224.091 1513.66 227.147 1518.27 Q230.226 1522.85 230.226 1531.6 Q230.226 1540.33 227.147 1544.94 Q224.091 1549.52 218.281 1549.52 Q212.471 1549.52 209.392 1544.94 Q206.337 1540.33 206.337 1531.6 Q206.337 1522.85 209.392 1518.27 Q212.471 1513.66 218.281 1513.66 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M623.124 1544.91 L630.763 1544.91 L630.763 1518.55 L622.453 1520.21 L622.453 1515.95 L630.717 1514.29 L635.393 1514.29 L635.393 1544.91 L643.032 1544.91 L643.032 1548.85 L623.124 1548.85 L623.124 1544.91 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M1041.86 1544.91 L1058.18 1544.91 L1058.18 1548.85 L1036.23 1548.85 L1036.23 1544.91 Q1038.89 1542.16 1043.48 1537.53 Q1048.08 1532.88 1049.26 1531.53 Q1051.51 1529.01 1052.39 1527.27 Q1053.29 1525.51 1053.29 1523.82 Q1053.29 1521.07 1051.35 1519.33 Q1049.43 1517.6 1046.32 1517.6 Q1044.12 1517.6 1041.67 1518.36 Q1039.24 1519.13 1036.46 1520.68 L1036.46 1515.95 Q1039.29 1514.82 1041.74 1514.24 Q1044.19 1513.66 1046.23 1513.66 Q1051.6 1513.66 1054.8 1516.35 Q1057.99 1519.03 1057.99 1523.52 Q1057.99 1525.65 1057.18 1527.57 Q1056.39 1529.47 1054.29 1532.07 Q1053.71 1532.74 1050.61 1535.95 Q1047.5 1539.15 1041.86 1544.91 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M1465.91 1530.21 Q1469.27 1530.93 1471.14 1533.2 Q1473.04 1535.47 1473.04 1538.8 Q1473.04 1543.92 1469.52 1546.72 Q1466 1549.52 1459.52 1549.52 Q1457.35 1549.52 1455.03 1549.08 Q1452.74 1548.66 1450.29 1547.81 L1450.29 1543.29 Q1452.23 1544.43 1454.55 1545.01 Q1456.86 1545.58 1459.38 1545.58 Q1463.78 1545.58 1466.07 1543.85 Q1468.39 1542.11 1468.39 1538.8 Q1468.39 1535.75 1466.24 1534.03 Q1464.11 1532.3 1460.29 1532.3 L1456.26 1532.3 L1456.26 1528.45 L1460.47 1528.45 Q1463.92 1528.45 1465.75 1527.09 Q1467.58 1525.7 1467.58 1523.11 Q1467.58 1520.45 1465.68 1519.03 Q1463.81 1517.6 1460.29 1517.6 Q1458.37 1517.6 1456.17 1518.01 Q1453.97 1518.43 1451.33 1519.31 L1451.33 1515.14 Q1453.99 1514.4 1456.31 1514.03 Q1458.64 1513.66 1460.7 1513.66 Q1466.03 1513.66 1469.13 1516.09 Q1472.23 1518.5 1472.23 1522.62 Q1472.23 1525.49 1470.59 1527.48 Q1468.94 1529.45 1465.91 1530.21 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M1879.13 1518.36 L1867.33 1536.81 L1879.13 1536.81 L1879.13 1518.36 M1877.91 1514.29 L1883.79 1514.29 L1883.79 1536.81 L1888.72 1536.81 L1888.72 1540.7 L1883.79 1540.7 L1883.79 1548.85 L1879.13 1548.85 L1879.13 1540.7 L1863.53 1540.7 L1863.53 1536.19 L1877.91 1514.29 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M2280.86 1514.29 L2299.22 1514.29 L2299.22 1518.22 L2285.15 1518.22 L2285.15 1526.7 Q2286.17 1526.35 2287.18 1526.19 Q2288.2 1526 2289.22 1526 Q2295.01 1526 2298.39 1529.17 Q2301.77 1532.34 2301.77 1537.76 Q2301.77 1543.34 2298.3 1546.44 Q2294.82 1549.52 2288.5 1549.52 Q2286.33 1549.52 2284.06 1549.15 Q2281.81 1548.78 2279.41 1548.04 L2279.41 1543.34 Q2281.49 1544.47 2283.71 1545.03 Q2285.93 1545.58 2288.41 1545.58 Q2292.42 1545.58 2294.75 1543.48 Q2297.09 1541.37 2297.09 1537.76 Q2297.09 1534.15 2294.75 1532.04 Q2292.42 1529.94 2288.41 1529.94 Q2286.54 1529.94 2284.66 1530.35 Q2282.81 1530.77 2280.86 1531.65 L2280.86 1514.29 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,1486.45 156.112,47.2441 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,1445.77 175.01,1445.77 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,1109.56 175.01,1109.56 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,773.351 175.01,773.351 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,437.143 175.01,437.143 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"156.112,100.935 175.01,100.935 \"/> <path clip-path=\"url(#clip870)\" d=\"M62.9365 1431.57 Q59.3254 1431.57 57.4967 1435.13 Q55.6912 1438.67 55.6912 1445.8 Q55.6912 1452.91 57.4967 1456.47 Q59.3254 1460.01 62.9365 1460.01 Q66.5707 1460.01 68.3763 1456.47 Q70.205 1452.91 70.205 1445.8 Q70.205 1438.67 68.3763 1435.13 Q66.5707 1431.57 62.9365 1431.57 M62.9365 1427.86 Q68.7467 1427.86 71.8022 1432.47 Q74.8809 1437.05 74.8809 1445.8 Q74.8809 1454.53 71.8022 1459.14 Q68.7467 1463.72 62.9365 1463.72 Q57.1264 1463.72 54.0477 1459.14 Q50.9921 1454.53 50.9921 1445.8 Q50.9921 1437.05 54.0477 1432.47 Q57.1264 1427.86 62.9365 1427.86 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M83.0984 1457.17 L87.9827 1457.17 L87.9827 1463.05 L83.0984 1463.05 L83.0984 1457.17 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M108.168 1431.57 Q104.557 1431.57 102.728 1435.13 Q100.922 1438.67 100.922 1445.8 Q100.922 1452.91 102.728 1456.47 Q104.557 1460.01 108.168 1460.01 Q111.802 1460.01 113.608 1456.47 Q115.436 1452.91 115.436 1445.8 Q115.436 1438.67 113.608 1435.13 Q111.802 1431.57 108.168 1431.57 M108.168 1427.86 Q113.978 1427.86 117.033 1432.47 Q120.112 1437.05 120.112 1445.8 Q120.112 1454.53 117.033 1459.14 Q113.978 1463.72 108.168 1463.72 Q102.358 1463.72 99.2789 1459.14 Q96.2234 1454.53 96.2234 1445.8 Q96.2234 1437.05 99.2789 1432.47 Q102.358 1427.86 108.168 1427.86 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M63.9319 1095.36 Q60.3208 1095.36 58.4921 1098.92 Q56.6865 1102.46 56.6865 1109.59 Q56.6865 1116.7 58.4921 1120.27 Q60.3208 1123.81 63.9319 1123.81 Q67.5661 1123.81 69.3717 1120.27 Q71.2004 1116.7 71.2004 1109.59 Q71.2004 1102.46 69.3717 1098.92 Q67.5661 1095.36 63.9319 1095.36 M63.9319 1091.65 Q69.742 1091.65 72.7976 1096.26 Q75.8763 1100.84 75.8763 1109.59 Q75.8763 1118.32 72.7976 1122.93 Q69.742 1127.51 63.9319 1127.51 Q58.1217 1127.51 55.043 1122.93 Q51.9875 1118.32 51.9875 1109.59 Q51.9875 1100.84 55.043 1096.26 Q58.1217 1091.65 63.9319 1091.65 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M84.0938 1120.96 L88.978 1120.96 L88.978 1126.84 L84.0938 1126.84 L84.0938 1120.96 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M99.2095 1092.28 L117.566 1092.28 L117.566 1096.21 L103.492 1096.21 L103.492 1104.69 Q104.51 1104.34 105.529 1104.18 Q106.547 1103.99 107.566 1103.99 Q113.353 1103.99 116.733 1107.16 Q120.112 1110.33 120.112 1115.75 Q120.112 1121.33 116.64 1124.43 Q113.168 1127.51 106.848 1127.51 Q104.672 1127.51 102.404 1127.14 Q100.159 1126.77 97.7511 1126.03 L97.7511 1121.33 Q99.8345 1122.46 102.057 1123.02 Q104.279 1123.58 106.756 1123.58 Q110.76 1123.58 113.098 1121.47 Q115.436 1119.36 115.436 1115.75 Q115.436 1112.14 113.098 1110.03 Q110.76 1107.93 106.756 1107.93 Q104.881 1107.93 103.006 1108.34 Q101.154 1108.76 99.2095 1109.64 L99.2095 1092.28 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M53.7467 786.696 L61.3856 786.696 L61.3856 760.33 L53.0754 761.997 L53.0754 757.738 L61.3393 756.071 L66.0152 756.071 L66.0152 786.696 L73.654 786.696 L73.654 790.631 L53.7467 790.631 L53.7467 786.696 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M83.0984 784.752 L87.9827 784.752 L87.9827 790.631 L83.0984 790.631 L83.0984 784.752 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M108.168 759.15 Q104.557 759.15 102.728 762.715 Q100.922 766.256 100.922 773.386 Q100.922 780.492 102.728 784.057 Q104.557 787.599 108.168 787.599 Q111.802 787.599 113.608 784.057 Q115.436 780.492 115.436 773.386 Q115.436 766.256 113.608 762.715 Q111.802 759.15 108.168 759.15 M108.168 755.446 Q113.978 755.446 117.033 760.053 Q120.112 764.636 120.112 773.386 Q120.112 782.113 117.033 786.719 Q113.978 791.303 108.168 791.303 Q102.358 791.303 99.2789 786.719 Q96.2234 782.113 96.2234 773.386 Q96.2234 764.636 99.2789 760.053 Q102.358 755.446 108.168 755.446 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M54.7421 450.488 L62.381 450.488 L62.381 424.122 L54.0708 425.789 L54.0708 421.53 L62.3347 419.863 L67.0106 419.863 L67.0106 450.488 L74.6494 450.488 L74.6494 454.423 L54.7421 454.423 L54.7421 450.488 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M84.0938 448.544 L88.978 448.544 L88.978 454.423 L84.0938 454.423 L84.0938 448.544 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M99.2095 419.863 L117.566 419.863 L117.566 423.798 L103.492 423.798 L103.492 432.271 Q104.51 431.923 105.529 431.761 Q106.547 431.576 107.566 431.576 Q113.353 431.576 116.733 434.747 Q120.112 437.919 120.112 443.335 Q120.112 448.914 116.64 452.016 Q113.168 455.095 106.848 455.095 Q104.672 455.095 102.404 454.724 Q100.159 454.354 97.7511 453.613 L97.7511 448.914 Q99.8345 450.048 102.057 450.604 Q104.279 451.159 106.756 451.159 Q110.76 451.159 113.098 449.053 Q115.436 446.946 115.436 443.335 Q115.436 439.724 113.098 437.618 Q110.76 435.511 106.756 435.511 Q104.881 435.511 103.006 435.928 Q101.154 436.345 99.2095 437.224 L99.2095 419.863 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M56.9643 114.28 L73.2837 114.28 L73.2837 118.215 L51.3393 118.215 L51.3393 114.28 Q54.0014 111.525 58.5847 106.896 Q63.1911 102.243 64.3717 100.9 Q66.617 98.3773 67.4967 96.6412 Q68.3994 94.882 68.3994 93.1922 Q68.3994 90.4376 66.455 88.7015 Q64.5337 86.9654 61.4319 86.9654 Q59.2328 86.9654 56.7791 87.7293 Q54.3486 88.4931 51.5708 90.0441 L51.5708 85.3219 Q54.3949 84.1876 56.8486 83.6089 Q59.3023 83.0302 61.3393 83.0302 Q66.7096 83.0302 69.9041 85.7154 Q73.0985 88.4006 73.0985 92.8913 Q73.0985 95.0209 72.2883 96.9422 Q71.5013 98.8403 69.3948 101.433 Q68.8161 102.104 65.7143 105.322 Q62.6124 108.516 56.9643 114.28 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M83.0984 112.336 L87.9827 112.336 L87.9827 118.215 L83.0984 118.215 L83.0984 112.336 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M108.168 86.7339 Q104.557 86.7339 102.728 90.2987 Q100.922 93.8403 100.922 100.97 Q100.922 108.076 102.728 111.641 Q104.557 115.183 108.168 115.183 Q111.802 115.183 113.608 111.641 Q115.436 108.076 115.436 100.97 Q115.436 93.8403 113.608 90.2987 Q111.802 86.7339 108.168 86.7339 M108.168 83.0302 Q113.978 83.0302 117.033 87.6367 Q120.112 92.22 120.112 100.97 Q120.112 109.697 117.033 114.303 Q113.978 118.886 108.168 118.886 Q102.358 118.886 99.2789 114.303 Q96.2234 109.697 96.2234 100.97 Q96.2234 92.22 99.2789 87.6367 Q102.358 83.0302 108.168 83.0302 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><polyline clip-path=\"url(#clip872)\" style=\"stroke:#009af9; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"218.281,772.728 259.727,708.495 301.174,642.323 342.62,576.882 384.066,512.925 425.512,451.185 466.958,392.37 508.404,337.156 549.85,286.176 591.296,240.015 632.742,199.202 674.188,164.207 715.635,135.431 757.081,113.204 798.527,97.7816 839.973,89.3399 881.419,87.9763 922.865,93.7063 964.311,106.464 1005.76,126.104 1047.2,152.399 1088.65,185.049 1130.1,223.679 1171.54,267.845 1212.99,317.04 1254.43,370.701 1295.88,428.21 1337.33,488.909 1378.77,552.1 1420.22,617.059 1461.66,683.04 1503.11,749.285 1544.56,815.035 1586,879.535 1627.45,942.045 1668.9,1001.85 1710.34,1058.25 1751.79,1110.62 1793.23,1158.35 1834.68,1200.88 1876.13,1237.74 1917.57,1268.49 1959.02,1292.8 2000.46,1310.37 2041.91,1321 2083.36,1324.58 2124.8,1321.06 2166.25,1310.48 2207.69,1292.97 2249.14,1268.73 2290.59,1238.02 \"/> <polyline clip-path=\"url(#clip872)\" style=\"stroke:#e26f46; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"218.281,773.351 259.727,706.222 301.174,639.763 342.62,574.639 384.066,511.5 425.512,450.978 466.958,393.677 508.404,340.169 549.85,290.99 591.296,246.63 632.742,207.533 674.188,174.089 715.635,146.633 757.081,125.439 798.527,110.719 839.973,102.62 881.419,101.222 922.865,106.54 964.311,118.52 1005.76,137.044 1047.2,161.925 1088.65,192.915 1130.1,229.705 1171.54,271.927 1212.99,319.159 1254.43,370.929 1295.88,426.72 1337.33,485.974 1378.77,548.1 1420.22,612.476 1461.66,678.46 1503.11,745.392 1544.56,812.603 1586,879.422 1627.45,945.181 1668.9,1009.22 1710.34,1070.91 1751.79,1129.62 1793.23,1184.77 1834.68,1235.82 1876.13,1282.24 1917.57,1323.57 1959.02,1359.41 2000.46,1389.4 2041.91,1413.22 2083.36,1430.66 2124.8,1441.53 2166.25,1445.72 2207.69,1443.19 2249.14,1433.97 2290.59,1418.15 \"/> <path clip-path=\"url(#clip870)\" d=\"M1601.19 250.738 L2279.53 250.738 L2279.53 95.2176 L1601.19 95.2176  Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"1\"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1601.19,250.738 2279.53,250.738 2279.53,95.2176 1601.19,95.2176 1601.19,250.738 \"/> <polyline clip-path=\"url(#clip870)\" style=\"stroke:#009af9; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1625.6,147.058 1772.04,147.058 \"/> <path clip-path=\"url(#clip870)\" d=\"M1796.45 129.778 L1816.31 129.778 L1816.31 133.713 L1801.13 133.713 L1801.13 143.898 L1814.83 143.898 L1814.83 147.833 L1801.13 147.833 L1801.13 164.338 L1796.45 164.338 L1796.45 129.778 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M1823.72 129.778 L1830.69 129.778 L1839.5 153.296 L1848.37 129.778 L1855.34 129.778 L1855.34 164.338 L1850.78 164.338 L1850.78 133.99 L1841.87 157.694 L1837.17 157.694 L1828.25 133.99 L1828.25 164.338 L1823.72 164.338 L1823.72 129.778 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M1864.09 129.778 L1868.79 129.778 L1868.79 150.773 Q1868.79 156.328 1870.8 158.782 Q1872.81 161.213 1877.33 161.213 Q1881.82 161.213 1883.83 158.782 Q1885.85 156.328 1885.85 150.773 L1885.85 129.778 L1890.55 129.778 L1890.55 151.352 Q1890.55 158.111 1887.19 161.56 Q1883.86 165.009 1877.33 165.009 Q1870.78 165.009 1867.42 161.56 Q1864.09 158.111 1864.09 151.352 L1864.09 129.778 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><polyline clip-path=\"url(#clip870)\" style=\"stroke:#e26f46; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none\" points=\"1625.6,198.898 1772.04,198.898 \"/> <path clip-path=\"url(#clip870)\" d=\"M1812.47 184.789 Q1807.38 184.789 1804.37 188.585 Q1801.38 192.381 1801.38 198.932 Q1801.38 205.46 1804.37 209.256 Q1807.38 213.053 1812.47 213.053 Q1817.56 213.053 1820.52 209.256 Q1823.51 205.46 1823.51 198.932 Q1823.51 192.381 1820.52 188.585 Q1817.56 184.789 1812.47 184.789 M1812.47 180.993 Q1819.74 180.993 1824.09 185.877 Q1828.44 190.738 1828.44 198.932 Q1828.44 207.104 1824.09 211.988 Q1819.74 216.849 1812.47 216.849 Q1805.18 216.849 1800.8 211.988 Q1796.45 207.127 1796.45 198.932 Q1796.45 190.738 1800.8 185.877 Q1805.18 180.993 1812.47 180.993 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M1839.69 212.289 L1839.69 226.039 L1835.41 226.039 L1835.41 190.252 L1839.69 190.252 L1839.69 194.187 Q1841.03 191.872 1843.07 190.761 Q1845.13 189.627 1847.98 189.627 Q1852.7 189.627 1855.64 193.377 Q1858.6 197.127 1858.6 203.238 Q1858.6 209.349 1855.64 213.099 Q1852.7 216.849 1847.98 216.849 Q1845.13 216.849 1843.07 215.738 Q1841.03 214.603 1839.69 212.289 M1854.18 203.238 Q1854.18 198.539 1852.24 195.877 Q1850.31 193.192 1846.94 193.192 Q1843.56 193.192 1841.61 195.877 Q1839.69 198.539 1839.69 203.238 Q1839.69 207.937 1841.61 210.622 Q1843.56 213.284 1846.94 213.284 Q1850.31 213.284 1852.24 210.622 Q1854.18 207.937 1854.18 203.238 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M1869.87 182.891 L1869.87 190.252 L1878.65 190.252 L1878.65 193.562 L1869.87 193.562 L1869.87 207.636 Q1869.87 210.807 1870.73 211.71 Q1871.61 212.613 1874.27 212.613 L1878.65 212.613 L1878.65 216.178 L1874.27 216.178 Q1869.34 216.178 1867.47 214.349 Q1865.59 212.497 1865.59 207.636 L1865.59 193.562 L1862.47 193.562 L1862.47 190.252 L1865.59 190.252 L1865.59 182.891 L1869.87 182.891 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M1884.25 190.252 L1888.51 190.252 L1888.51 216.178 L1884.25 216.178 L1884.25 190.252 M1884.25 180.159 L1888.51 180.159 L1888.51 185.553 L1884.25 185.553 L1884.25 180.159 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M1917.61 195.229 Q1919.2 192.358 1921.43 190.993 Q1923.65 189.627 1926.66 189.627 Q1930.71 189.627 1932.91 192.474 Q1935.11 195.298 1935.11 200.529 L1935.11 216.178 L1930.82 216.178 L1930.82 200.668 Q1930.82 196.942 1929.5 195.136 Q1928.18 193.33 1925.48 193.33 Q1922.17 193.33 1920.24 195.53 Q1918.32 197.729 1918.32 201.525 L1918.32 216.178 L1914.04 216.178 L1914.04 200.668 Q1914.04 196.918 1912.72 195.136 Q1911.4 193.33 1908.65 193.33 Q1905.38 193.33 1903.46 195.553 Q1901.54 197.752 1901.54 201.525 L1901.54 216.178 L1897.26 216.178 L1897.26 190.252 L1901.54 190.252 L1901.54 194.28 Q1903 191.895 1905.04 190.761 Q1907.07 189.627 1909.87 189.627 Q1912.7 189.627 1914.67 191.062 Q1916.66 192.497 1917.61 195.229 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M1943.6 190.252 L1947.86 190.252 L1947.86 216.178 L1943.6 216.178 L1943.6 190.252 M1943.6 180.159 L1947.86 180.159 L1947.86 185.553 L1943.6 185.553 L1943.6 180.159 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M1954.92 190.252 L1975.15 190.252 L1975.15 194.141 L1959.13 212.775 L1975.15 212.775 L1975.15 216.178 L1954.34 216.178 L1954.34 212.289 L1970.36 193.655 L1954.92 193.655 L1954.92 190.252 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M1993.44 203.145 Q1988.28 203.145 1986.29 204.326 Q1984.3 205.506 1984.3 208.354 Q1984.3 210.622 1985.78 211.965 Q1987.28 213.284 1989.85 213.284 Q1993.39 213.284 1995.52 210.784 Q1997.67 208.261 1997.67 204.094 L1997.67 203.145 L1993.44 203.145 M2001.93 201.386 L2001.93 216.178 L1997.67 216.178 L1997.67 212.242 Q1996.22 214.603 1994.04 215.738 Q1991.86 216.849 1988.72 216.849 Q1984.74 216.849 1982.37 214.627 Q1980.04 212.381 1980.04 208.631 Q1980.04 204.256 1982.95 202.034 Q1985.89 199.812 1991.7 199.812 L1997.67 199.812 L1997.67 199.395 Q1997.67 196.455 1995.73 194.858 Q1993.81 193.238 1990.31 193.238 Q1988.09 193.238 1985.99 193.77 Q1983.88 194.303 1981.93 195.367 L1981.93 191.432 Q1984.27 190.53 1986.47 190.09 Q1988.67 189.627 1990.75 189.627 Q1996.38 189.627 1999.16 192.543 Q2001.93 195.46 2001.93 201.386 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M2014.92 182.891 L2014.92 190.252 L2023.69 190.252 L2023.69 193.562 L2014.92 193.562 L2014.92 207.636 Q2014.92 210.807 2015.78 211.71 Q2016.66 212.613 2019.32 212.613 L2023.69 212.613 L2023.69 216.178 L2019.32 216.178 Q2014.39 216.178 2012.51 214.349 Q2010.64 212.497 2010.64 207.636 L2010.64 193.562 L2007.51 193.562 L2007.51 190.252 L2010.64 190.252 L2010.64 182.891 L2014.92 182.891 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M2029.3 190.252 L2033.55 190.252 L2033.55 216.178 L2029.3 216.178 L2029.3 190.252 M2029.3 180.159 L2033.55 180.159 L2033.55 185.553 L2029.3 185.553 L2029.3 180.159 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M2052.51 193.238 Q2049.09 193.238 2047.1 195.923 Q2045.11 198.585 2045.11 203.238 Q2045.11 207.891 2047.07 210.576 Q2049.06 213.238 2052.51 213.238 Q2055.92 213.238 2057.91 210.553 Q2059.9 207.867 2059.9 203.238 Q2059.9 198.631 2057.91 195.946 Q2055.92 193.238 2052.51 193.238 M2052.51 189.627 Q2058.07 189.627 2061.24 193.238 Q2064.41 196.849 2064.41 203.238 Q2064.41 209.604 2061.24 213.238 Q2058.07 216.849 2052.51 216.849 Q2046.93 216.849 2043.76 213.238 Q2040.61 209.604 2040.61 203.238 Q2040.61 196.849 2043.76 193.238 Q2046.93 189.627 2052.51 189.627 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M2093.02 200.529 L2093.02 216.178 L2088.76 216.178 L2088.76 200.668 Q2088.76 196.988 2087.33 195.159 Q2085.89 193.33 2083.02 193.33 Q2079.57 193.33 2077.58 195.53 Q2075.59 197.729 2075.59 201.525 L2075.59 216.178 L2071.31 216.178 L2071.31 190.252 L2075.59 190.252 L2075.59 194.28 Q2077.12 191.942 2079.18 190.784 Q2081.26 189.627 2083.97 189.627 Q2088.44 189.627 2090.73 192.405 Q2093.02 195.159 2093.02 200.529 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M2120.8 182.891 L2120.8 190.252 L2129.57 190.252 L2129.57 193.562 L2120.8 193.562 L2120.8 207.636 Q2120.8 210.807 2121.66 211.71 Q2122.54 212.613 2125.2 212.613 L2129.57 212.613 L2129.57 216.178 L2125.2 216.178 Q2120.27 216.178 2118.39 214.349 Q2116.52 212.497 2116.52 207.636 L2116.52 193.562 L2113.39 193.562 L2113.39 190.252 L2116.52 190.252 L2116.52 182.891 L2120.8 182.891 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M2146.96 203.145 Q2141.79 203.145 2139.8 204.326 Q2137.81 205.506 2137.81 208.354 Q2137.81 210.622 2139.29 211.965 Q2140.8 213.284 2143.37 213.284 Q2146.91 213.284 2149.04 210.784 Q2151.19 208.261 2151.19 204.094 L2151.19 203.145 L2146.96 203.145 M2155.45 201.386 L2155.45 216.178 L2151.19 216.178 L2151.19 212.242 Q2149.73 214.603 2147.56 215.738 Q2145.38 216.849 2142.23 216.849 Q2138.25 216.849 2135.89 214.627 Q2133.55 212.381 2133.55 208.631 Q2133.55 204.256 2136.47 202.034 Q2139.41 199.812 2145.22 199.812 L2151.19 199.812 L2151.19 199.395 Q2151.19 196.455 2149.25 194.858 Q2147.33 193.238 2143.83 193.238 Q2141.61 193.238 2139.5 193.77 Q2137.4 194.303 2135.45 195.367 L2135.45 191.432 Q2137.79 190.53 2139.99 190.09 Q2142.19 189.627 2144.27 189.627 Q2149.9 189.627 2152.67 192.543 Q2155.45 195.46 2155.45 201.386 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M2179.25 194.233 Q2178.53 193.817 2177.67 193.631 Q2176.84 193.423 2175.82 193.423 Q2172.21 193.423 2170.27 195.784 Q2168.35 198.122 2168.35 202.52 L2168.35 216.178 L2164.06 216.178 L2164.06 190.252 L2168.35 190.252 L2168.35 194.28 Q2169.69 191.918 2171.84 190.784 Q2173.99 189.627 2177.07 189.627 Q2177.51 189.627 2178.04 189.696 Q2178.58 189.743 2179.22 189.858 L2179.25 194.233 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M2199.94 202.914 Q2199.94 198.284 2198.02 195.738 Q2196.12 193.192 2192.67 193.192 Q2189.25 193.192 2187.33 195.738 Q2185.43 198.284 2185.43 202.914 Q2185.43 207.52 2187.33 210.066 Q2189.25 212.613 2192.67 212.613 Q2196.12 212.613 2198.02 210.066 Q2199.94 207.52 2199.94 202.914 M2204.2 212.96 Q2204.2 219.58 2201.26 222.798 Q2198.32 226.039 2192.26 226.039 Q2190.01 226.039 2188.02 225.691 Q2186.03 225.367 2184.16 224.673 L2184.16 220.529 Q2186.03 221.548 2187.86 222.034 Q2189.69 222.52 2191.59 222.52 Q2195.78 222.52 2197.86 220.321 Q2199.94 218.145 2199.94 213.724 L2199.94 211.617 Q2198.62 213.909 2196.56 215.043 Q2194.5 216.178 2191.63 216.178 Q2186.86 216.178 2183.95 212.543 Q2181.03 208.909 2181.03 202.914 Q2181.03 196.895 2183.95 193.261 Q2186.86 189.627 2191.63 189.627 Q2194.5 189.627 2196.56 190.761 Q2198.62 191.895 2199.94 194.187 L2199.94 190.252 L2204.2 190.252 L2204.2 212.96 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M2235.15 202.15 L2235.15 204.233 L2215.57 204.233 Q2215.85 208.631 2218.21 210.946 Q2220.59 213.238 2224.83 213.238 Q2227.28 213.238 2229.57 212.636 Q2231.89 212.034 2234.16 210.83 L2234.16 214.858 Q2231.86 215.83 2229.46 216.34 Q2227.05 216.849 2224.57 216.849 Q2218.37 216.849 2214.73 213.238 Q2211.12 209.627 2211.12 203.469 Q2211.12 197.104 2214.55 193.377 Q2218 189.627 2223.83 189.627 Q2229.06 189.627 2232.1 193.006 Q2235.15 196.363 2235.15 202.15 M2230.89 200.9 Q2230.85 197.405 2228.92 195.321 Q2227.03 193.238 2223.88 193.238 Q2220.31 193.238 2218.16 195.252 Q2216.03 197.266 2215.71 200.923 L2230.89 200.9 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /><path clip-path=\"url(#clip870)\" d=\"M2246.35 182.891 L2246.35 190.252 L2255.13 190.252 L2255.13 193.562 L2246.35 193.562 L2246.35 207.636 Q2246.35 210.807 2247.21 211.71 Q2248.09 212.613 2250.75 212.613 L2255.13 212.613 L2255.13 216.178 L2250.75 216.178 Q2245.82 216.178 2243.95 214.349 Q2242.07 212.497 2242.07 207.636 L2242.07 193.562 L2238.95 193.562 L2238.95 190.252 L2242.07 190.252 L2242.07 182.891 L2246.35 182.891 Z\" fill=\"#000000\" fill-rule=\"nonzero\" fill-opacity=\"1\" /></svg>","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Actually a pretty fit! If you have higher requirements, check out the Optim.jl library.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"unloadFMU(fmu)","category":"page"},{"location":"examples/parameter_optimization/#Summary","page":"FMU Parameter Optimization","title":"Summary","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"This tutorial showed how a parameter (and start value) optimization can be performed on a FMU with a gradient free optimizer. This tutorial will be extended soon to further show how convergence for large parameter spaces can be improoved!","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMI-Common-Concepts-for-Model-Exchange-and-Co-Simulation","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"In both cases, FMI defines an input/output block of a dynamic model where the distribution of the block, the platform dependent header file, several access functions, as well as the schema files are identical.","category":"page"},{"location":"fmi2_lowlevel_library_functions/#Opening-and-closing-FMUs","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Opening and closing FMUs","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"","category":"page"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2Unzip fmi2Load fmi2Reload fmi2Unload","category":"page"},{"location":"fmi2_lowlevel_library_functions/#Creation,-Destruction-and-Logging-of-FMU-Instances","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Creation, Destruction and Logging of FMU Instances","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2Instantiate!\nfmi2Instantiate\nfmi2FreeInstance\nfmi2SetDebugLogging","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2Instantiate!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2Instantiate!","text":"fmi2Instantiate!(fmu::FMU2;\n                    instanceName::String=fmu.modelName,\n                    type::fmi2Type=fmu.type,\n                    pushComponents::Bool = true,\n                    visible::Bool = false,\n                    loggingOn::Bool = fmu.executionConfig.loggingOn,\n                    externalCallbacks::Bool = fmu.executionConfig.externalCallbacks,\n                    logStatusOK::Bool=true,\n                    logStatusWarning::Bool=true,\n                    logStatusDiscard::Bool=true,\n                    logStatusError::Bool=true,\n                    logStatusFatal::Bool=true,\n                    logStatusPending::Bool=true)\n\nCreate a new instance of the given fmu, adds a logger if logginOn == true.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nKeywords\n\ninstanceName::String=fmu.modelName: Name of the instance\ntype::fmi2Type=fmu.type: Defines whether a Co-Simulation or Model Exchange is present\npushComponents::Bool = true: Defines if the fmu components should be pushed in the application.\nvisible::Bool = false if the FMU should be started with graphic interface, if supported (default=false)\nloggingOn::Bool = fmu.executionConfig.loggingOn if the FMU should log and display function calls (default=false)\nexternalCallbacks::Bool = fmu.executionConfig.externalCallbacks if an external shared library should be used for the fmi2CallbackFunctions, this may improve readability of logging messages (default=false)\nlogStatusOK::Bool=true whether to log status of kind fmi2OK (default=true)\nlogStatusWarning::Bool=true whether to log status of kind fmi2Warning (default=true)\nlogStatusDiscard::Bool=true whether to log status of kind fmi2Discard (default=true)\nlogStatusError::Bool=true whether to log status of kind fmi2Error (default=true)\nlogStatusFatal::Bool=true whether to log status of kind fmi2Fatal (default=true)\nlogStatusPending::Bool=true whether to log status of kind fmi2Pending (default=true)\n\nReturns\n\nReturns the instance of a new FMU component.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\nSee also fmi2Instantiate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2Instantiate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2Instantiate","text":"Source: FMISpec2.0.2[p.19]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nThe function returns a new instance of an FMU.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2FreeInstance","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2FreeInstance","text":"Source: FMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nDisposes the given instance, unloads the loaded model, and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface. If a null pointer is provided for “c”, the function call is ignored (does not have an effect).\n\nRemoves the component from the FMUs component list.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetDebugLogging","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetDebugLogging","text":"Source: FMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nThe function controls debug logging that is output via the logger function callback. If loggingOn = fmi2True, debug logging is enabled, otherwise it is switched off.\n\n\n\n\n\nfmi2SetDebugLogging(c::FMU2Component, loggingOn::fmi2Boolean, nCategories::Unsigned, categories::Ptr{Nothing})\n\nControl the use of the logging callback function, version independent.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nloggingOn::fmi2Boolean: If loggingOn = fmi2True, debug logging is enabled for the log categories specified in categories, otherwise it is disabled. Type fmi2Boolean is defined as an alias Type for the C-Type Boolean and is to be used with fmi2True and fmi2False.\nnCategories::Unsigned: Argument nCategories defines the length of the argument categories.\ncategories::Ptr{Nothing}:\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nSee also fmi2SetDebugLogging.\n\n\n\n\n\nfmi2SetDebugLogging(c::FMU2Component)\n\nControl the use of the logging callback function, version independent.\n\nArguments\n\nc::FMU2Component: Argument c is a mutable struct representing an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nSee also fmi2SetDebugLogging.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#Initialization,-Termination,-and-Resetting-an-FMU","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Initialization, Termination, and Resetting an FMU","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2SetupExperiment\nfmi2EnterInitializationMode\nfmi2ExitInitializationMode\nfmi2Terminate\nfmi2Reset","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetupExperiment","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetupExperiment","text":"Source: FMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nInforms the FMU to setup the experiment. This function must be called after fmi2Instantiate and before fmi2EnterInitializationMode is called.The function controls debug logging that is output via the logger function callback. If loggingOn = fmi2True, debug logging is enabled, otherwise it is switched off.\n\n\n\n\n\nfmi2SetupExperiment(c::FMU2Component, toleranceDefined::fmi2Boolean, tolerance::fmi2Real, startTime::fmi2Real, stopTimeDefined::fmi2Boolean, stopTime::fmi2Real)\n\nInforms the FMU to setup the experiment. This function must be called after fmi2Instantiate and before fmi2EnterInitializationMode is called.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ntoleranceDefined::fmi2Boolean: Arguments toleranceDefined depend on the FMU type:\nfmuType = fmi2ModelExchange: If toleranceDefined = fmi2True, then the model is called with a numerical integration scheme where the step size is controlled by using tolerance for error estimation. In such a case, all numerical algorithms used inside the model (for example, to solve non-linear algebraic equations) should also operate with an error estimation of an appropriate smaller relative tolerance.\nfmuType = fmi2CoSimulation: If toleranceDefined = fmi2True, then the communication interval of the slave is controlled by error estimation.  In case the slave utilizes a numerical integrator with variable step size and error estimation, it is suggested to use “tolerance” for the error estimation of the internal integrator (usually as relative tolerance). An FMU for Co-Simulation might ignore this argument.\nstartTime::fmi2Real: Argument startTime can be used to check whether the model is valid within the given boundaries or to allocate memory which is necessary for storing results. It is the fixed initial value of the independent variable and if the independent variable is time, startTime is the starting time of initializaton.\nstopTimeDefined::fmi2Boolean:  If stopTimeDefined = fmi2True, then stopTime is the defined final value of the independent variable and if stopTimeDefined = fmi2False, then no final value\n\nof the independent variable is defined and argument stopTime is meaningless.\n\nstopTime::fmi2Real: Argument stopTime can be used to check whether the model is valid within the given boundaries or to allocate memory which is necessary for storing results. It is the fixed final value of the independent variable and if the independent variable is “time”, stopTime is the stop time of the simulation.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2SetupExperiment.\n\n\n\n\n\nfmi2SetupExperiment(c::FMU2Component, \n                        startTime::Union{Real, Nothing} = nothing, \n                        stopTime::Union{Real, Nothing} = nothing; \n                        tolerance::Union{Real, Nothing} = nothing)\n\nSetup the simulation but without defining all of the parameters.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct representing an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstartTime::Union{Real, Nothing} = nothing: startTime is a real number which sets the value of starting time of the experiment. The default value is set automatically if doing nothing (default = nothing).\nstopTime::Union{Real, Nothing} = nothing: stopTime is a real number which sets the value of ending time of the experiment. The default value is set automatically if doing nothing (default = nothing).\n\nKeywords\n\ntolerance::Union{Real, Nothing} = nothing: tolerance is a real number which sets the value of tolerance range. The default value is set automatically if doing nothing (default = nothing).\n\nReturns\n\nReturns a warning if str.state is not called in fmi2ComponentStateInstantiated.\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2SetupExperiment.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2EnterInitializationMode","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2EnterInitializationMode","text":"Source: FMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nInforms the FMU to enter Initialization Mode. Before calling this function, all variables with attribute <ScalarVariable initial = \"exact\" or \"approx\"> can be set with the “fmi2SetXXX” functions (the ScalarVariable attributes are defined in the Model Description File, see section 2.2.7). Setting other variables is not allowed. Furthermore, fmi2SetupExperiment must be called at least once before calling fmi2EnterInitializationMode, in order that startTime is defined.\n\n\n\n\n\nfmi2EnterInitializationMode(c::FMU2Component)\n\nInforms the FMU to enter Initialization Mode. Before calling this function, all variables with attribute <ScalarVariable initial = \"exact\" or \"approx\"> can be set with the “fmi2SetXXX” functions (the ScalarVariable attributes are defined in the Model Description File, see section 2.2.7). Setting other variables is not allowed. Furthermore, fmi2SetupExperiment must be called at least once before calling fmi2EnterInitializationMode, in order that startTime is defined.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2EnterInitializationMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2ExitInitializationMode","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2ExitInitializationMode","text":"Source: FMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nInforms the FMU to exit Initialization Mode.\n\n\n\n\n\nfmi2ExitInitializationMode(c::FMU2Component)\n\nInforms the FMU to exit Initialization Mode.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2EnterInitializationMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2Terminate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2Terminate","text":"Source: FMISpec2.0.2[p.24]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nInforms the FMU that the simulation run is terminated.\n\n\n\n\n\nfmi2Terminate(c::FMU2Component; soft::Bool=false)\n\nInforms the FMU that the simulation run is terminated.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2Terminate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2Reset","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2Reset","text":"Source: FMISpec2.0.2[p.24]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nIs called by the environment to reset the FMU after a simulation run. The FMU goes into the same state as if fmi2Instantiate would have been called.\n\n\n\n\n\nfmi2Reset(c::FMU2Component; soft::Bool=false)\n\nIs called by the environment to reset the FMU after a simulation run. The FMU goes into the same state as if fmi2Instantiate would have been called.All variables have their default values. Before starting a new run, fmi2SetupExperiment and fmi2EnterInitializationMode have to be called.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.3 Link: https://fmi-standard.org/\nFMISpec2.0.3[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.3[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.3[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2Terminate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#Getting-and-Setting-Variable-Values","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Getting and Setting Variable Values","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"All variable values of an FMU are identified with a variable handle called “value reference”. The handle is defined in the modelDescription.xml file (as attribute “valueReference” in element “ScalarVariable”). Element “valueReference” might not be unique for all variables. If two or more variables of the same base data type (such as fmi2Real) have the same valueReference, then they have identical values but other parts of the variable definition might be different (for example, min/max attributes).","category":"page"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2GetReal\nfmi2GetReal!\nfmi2GetInteger\nfmi2GetInteger!\nfmi2GetBoolean\nfmi2GetBoolean!\nfmi2GetString\nfmi2GetString!\nfmi2SetReal\nfmi2SetInteger\nfmi2SetBoolean\nfmi2SetString","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2GetReal","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2GetReal","text":"fmi2GetReal(c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nGet the values of an array of fmi2Real variables.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fm2Real}: Returns values of an array of fmi2Real variables with the dimension of fmi2ValueReferenceFormat length.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetReal.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetReal!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetReal!","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2GetReal!(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Real})\n\nFunctions to get and set values of variables idetified by their valueReference\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fm2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetReal!.\n\n\n\n\n\nfmi2GetReal!(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::AbstractArray{fmi2Real})\n\nGet the values of an array of fmi2Real variables.\n\nrites the real values of an array of variables in the given field\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fm2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetReal!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2GetInteger","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2GetInteger","text":"fmi2GetInteger(c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nReturns the integer values of an array of variables\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi2Integer}: Return values is an array with the actual values of these variables.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetInteger!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetInteger!","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2GetInteger!(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Integer})\n\nWrites the integer values of an array of variables in the given field\n\nfmi2GetInteger! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels, called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi2Integer}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!.\n\n\n\n\n\nfmi2GetInteger!(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::AbstractArray{fmi2Integer})\n\nWrites the integer values of an array of variables in the given field\n\nfmi2GetInteger! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::Array{fmi2Integer}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2GetBoolean","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2GetBoolean","text":"fmi2GetBoolean(c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nGet the values of an array of fmi2Boolean variables.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi2Boolean}: Return values is an array with the actual values of these variables.\n\nSee also fmi2GetBoolean!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetBoolean!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetBoolean!","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2GetBoolean!(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Boolean})\n\nWrites the boolean values of an array of variables in the given field\n\nfmi2GetBoolean! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::AbstractArray{fmi2Boolean}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean!.\n\n\n\n\n\nfmi2GetBoolean!(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::AbstractArray{fmi2Boolean})\n\nWrites the boolean values of an array of variables in the given field\n\nfmi2GetBoolean! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi2Boolean}: Argument value is an array with the actual values of these variables\n\nReturns\n\nReturn singleton instance of type Nothing, if there is no value to return (as in a C void function) or when a variable or field holds no value.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2GetString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2GetString","text":"fmi2GetString(c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nGet the values of an array of fmi2String variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi2String}:  Return values is an array with the actual values of these variables.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetString!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetString!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetString!","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2GetString!(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::Union{AbstractArray{Ptr{Cchar}}, AbstractArray{Ptr{UInt8}}})\n\nFunctions to get and set values of variables idetified by their valueReference\n\nThese functions are especially used to get the actual values of output variables if a model is connected with other models.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::Union{AbstractArray{Ptr{Cchar}, AbstractArray{Ptr{UInt8}}}: The value argument is an AbstractArray of values whose memory address refers to data of type Cchar or UInt8and describes a vector with the actual values of these. variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetString!.\n\n\n\n\n\nfmi2GetString!(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::AbstractArray{fmi2String})\n\nWrites the string values of an array of variables in the given field\n\nThese functions are especially used to get the actual values of output variables if a model is connected with other models.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi2String}: Argument values is an AbstractArray with the actual values of these variables\n\nReturns\n\nReturn singleton instance of type Nothing, if there is no value to return (as in a C void function) or when a variable or field holds no value.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetString!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetReal","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetReal","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2SetReal(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Real})\n\nFunctions to get and set values of variables idetified by their valueReference\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels, called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fm2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetReal.\n\n\n\n\n\nfmi2SetReal(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{AbstractArray{<:Real}, <:Real})\n\nSet the values of an array of real variables\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{Array{<:Real}, <:Real}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2SetReal.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetInteger","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetInteger","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2SetInteger(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Integer})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels, called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi2Integer}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!.\n\n\n\n\n\nfmi2SetInteger(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{AbstractArray{<:Integer}, <:Integer})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nvalues::Union{Array{<:Integer}, <:Integer}: Argument values is an array or a single value with type Integer or any subtyp\n\nReturns\n\nstatus::fmi2Status: Return status indicates the success of the function call.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2SetInteger.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetBoolean","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetBoolean","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2SetBoolean(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Boolean})\n\nFunctions to get and set values of variables idetified by their valueReference\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::AbstractArray{fmi2Boolean}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean.\n\n\n\n\n\nfmi2SetBoolean(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{AbstractArray{Bool}, Bool})\n\nSet the values of an array of boolean variables\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{Array{Bool}, Bool}: Argument values is an array or a single value with type Boolean or any subtyp\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetString","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetString","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2SetString(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::Union{AbstractArray{Ptr{Cchar}}, AbstractArray{Ptr{UInt8}}})\n\nSet the values of an array of string variables\n\nFor the exact rules on which type of variables fmi2SetXXX can be called see FMISpec2.0.2 section 2.2.7 , as well as FMISpec2.0.2 section 3.2.3 in case of ModelExchange and FMISpec2.0.2 section 4.2.4 in case ofCoSimulation.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::Union{AbstractArray{Ptr{Cchar}, AbstractArray{Ptr{UInt8}}}: The value argument is an AbstractArray of values whose memory address refers to data of type Cchar or UInt8and describes a vector with the actual values of these. variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetString!.\n\n\n\n\n\nfmi2SetString(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{AbstractArray{String}, String})\n\nSet the values of an array of string variables\n\nFor the exact rules on which type of variables fmi2SetXXX can be called see FMISpec2.0.2 section 2.2.7 , as well as FMISpec2.0.2 section 3.2.3 in case of ModelExchange and FMISpec2.0.2 section 4.2.4 in case of CoSimulation.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{Array{String}, String}: Argument values is an array or a single value with type String.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.46]: 2.2.7 Definition of Model Variables\nFMISpec2.0.2[p.46]: 3.2.3 State Machine of Calling Sequence\nFMISpec2.0.2[p.108]: 4.2.4 State Machine of Calling Sequence from Master to Slave\n\nSee also fmi2SetString.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2Get fmi2Get! fmi2Set","category":"page"},{"location":"fmi2_lowlevel_library_functions/#Getting-and-Setting-the-Complete-FMU-State","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Getting and Setting the Complete FMU State","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"The FMU has an internal state consisting of all values that are needed to continue a simulation. This internal state consists especially of the values of the continuous-time states, iteration variables, parameter values, input values, delay buffers, file identifiers, and FMU internal status information. With the functions of this section, the internal FMU state can be copied and the pointer to this copy is returned to the environment. The FMU state copy can be set as actual FMU state, in order to continue the simulation from it.","category":"page"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2GetFMUstate\nfmi2GetFMUstate!\nfmi2SetFMUstate\nfmi2FreeFMUstate\nfmi2SerializedFMUstateSize\nfmi2SerializedFMUstateSize!\nfmi2SerializeFMUstate\nfmi2SerializeFMUstate!\nfmi2DeSerializeFMUstate\nfmi2DeSerializeFMUstate!","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2GetFMUstate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2GetFMUstate","text":"fmi2GetFMUstate(c::FMU2Component)\n\nMakes a copy of the internal FMU state and returns a pointer to this copy.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nReturn state is a pointer to a copy of the internal FMU state.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2GetFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetFMUstate!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetFMUstate!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2GetFMUstate makes a copy of the internal FMU state and returns a pointer to this copy\n\n\n\n\n\nfmi2GetFMUstate!(c::FMU2Component, FMUstate::Ref{fmi2FMUstate})\n\nMakes a copy of the internal FMU state and returns a pointer to this copy.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::Ref{fmi2FMUstate}:If on entry FMUstate == NULL, a new allocation is required. If FMUstate != NULL, then FMUstate points to a previously returned FMUstate that has not been modified since.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetFMUstate!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetFMUstate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetFMUstate","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2SetFMUstate copies the content of the previously copied FMUstate back and uses it as actual new FMU state.\n\n\n\n\n\nfmi2SetFMUstate(c::FMU2Component, FMUstate::fmi2FMUstate)\n\nCopies the content of the previously copied FMUstate back and uses it as actual new FMU state.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::fmi2FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2GetFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2FreeFMUstate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2FreeFMUstate","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and setting the complete FMU state\n\nfmi2FreeFMUstate frees all memory and other resources allocated with the fmi2GetFMUstate call for this FMUstate.\n\n\n\n\n\nfmi2FreeFMUstate(c::FMU2Component, FMUstate::Ref{fmi2FMUstate})\n\nFrees all memory and other resources allocated with the fmi2GetFMUstate call for this FMUstate.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::Ref{fmi2FMUstate}: Argument FMUstate is an object that safely references data of type fmi3FMUstate which is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2FreeFMUstate.\n\n\n\n\n\nfmi2FreeFMUstate!(c::FMU2Component, state::fmi2FMUstate)\n\nFree the memory for the allocated FMU state\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nReturn singleton instance of type Nothing, if there is no value to return (as in a C void function) or when a variable or field holds no value.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2FreeFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2SerializedFMUstateSize","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2SerializedFMUstateSize","text":"fmi2SerializedFMUstateSize(c::FMU2Component, state::fmi2FMUstate)\n\nReturns the size of the byte vector in which the FMUstate can be stored.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nReturn size is an object that safely references a value of type Csize_t.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializedFMUstateSize.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SerializedFMUstateSize!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SerializedFMUstateSize!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2SerializedFMUstateSize returns the size of the byte vector, in order that FMUstate can be stored in it.\n\n\n\n\n\nfmi2SerializedFMUstateSize!(c::FMU2Component, FMUstate::fmi2FMUstate, size::Ref{Csize_t})\n\nStores the size of the byte vector in the given referenced Address, in order that FMUstate can be stored in it.\n\nArgument\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::fmi2FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nsize::Ref{Csize_t}: Argument size is an object that safely references a value of type Csize_t and defines the size of the byte vector in which the FMUstate can be stored.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializedFMUstateSize!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2SerializeFMUstate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2SerializeFMUstate","text":"fmi2SerializeFMUstate(c::FMU2Component, state::fmi2FMUstate)\n\nSerializes the data referenced by the pointer FMUstate and copies this data into the byte vector serializedState of length size to be provided by the environment.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nserializedState:: Array{fmi2Byte}: Return serializedState contains the copy of the serialized data referenced by the pointer FMUstate\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializeFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SerializeFMUstate!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SerializeFMUstate!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2SerializeFMUstate serializes the data which is referenced by pointer FMUstate and copies this data in to the byte vector serializedState of length size\n\n\n\n\n\nfmi2SerializeFMUstate!(c::FMU2Component, FMUstate::fmi2FMUstate, serialzedState::AbstractArray{fmi2Byte}, size::Csize_t)\n\nSerializes the data which is referenced by pointer FMUstate and copies this data in to the byte vector serializedState of length size, that must be provided by the environment.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nserialzedState::AbstractArray{fmi2Byte}: Argument serializedState contains the copy of the serialized data referenced by the pointer FMUstate.\nsize::Csize_t: Argument size defines the length of the serialized vector.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializeFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2DeSerializeFMUstate","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2DeSerializeFMUstate","text":"fmi2DeSerializeFMUstate(c::FMU2Component, serializedState::AbstractArray{fmi2Byte})\n\nDeserialize the data in the serializedState fmi2Byte field\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nserializedState::Array{fmi2Byte}: Argument serializedState contains the fmi2Byte field to be deserialized.\n\nReturns\n\nReturn state is a pointer to a copy of the internal FMU state.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2DeSerializeFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2DeSerializeFMUstate!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2DeSerializeFMUstate!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2DeSerializeFMUstate deserializes the byte vector serializedState of length size, constructs a copy of the FMU state and returns FMUstate, the pointer to this copy.\n\n\n\n\n\nfmi2DeSerializeFMUstate!(c::FMU2Component, serializedState::AbstractArray{fmi2Byte}, size::Csize_t, FMUstate::Ref{fmi2FMUstate})\n\nDeserializes the byte vector serializedState of length size, constructs a copy of the FMU state and stores the FMU state in the given address of the reference FMUstate, the pointer to this copy.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nserialzedState::AbstractArray{fmi2Byte}: Argument serializedState contains the copy of the serialized data referenced by the pointer FMUstate.\nsize::Csize_t: Argument size defines the length of the serialized vector.\nFMUstate::Ref{fmi2FMUstate}: Argument FMUstate is an object that safely references data of type fmi3FMUstate which is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2DeSerializeFMUstate!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#Getting-Partial-Dervatives","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"Getting Partial Dervatives","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"It is optionally possible to provide evaluation of partial derivatives for an FMU. For Model Exchange, this means computing the partial derivatives at a particular time instant. For Co-Simulation, this means to compute the partial derivatives at a particular communication point. One function is provided to compute directional derivatives. This function can be used to construct the desired partial derivative matrices.","category":"page"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2GetDirectionalDerivative\nfmi2GetDirectionalDerivative!\nfmi2SetRealInputDerivatives\nfmi2GetRealOutputDerivatives!","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMIImport.fmi2GetDirectionalDerivative","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIImport.fmi2GetDirectionalDerivative","text":"fmi2GetDirectionalDerivative(c::FMU2Component,\n                                  vUnknown_ref::AbstractArray{fmi2ValueReference},\n                                  vKnown_ref::AbstractArray{fmi2ValueReference},\n                                  dvKnown::Union{AbstractArray{fmi2Real}, Nothing} = nothing)\n\nWrapper Function call to compute the partial derivative with respect to the variables vKnown_ref.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns.The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1). In every Mode, the general form of the FMU equations are: 𝐯unknown = 𝐡(𝐯known, 𝐯_rest)\n\nv_unknown: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknowns> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Outputs> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><Derivatives>).\nEvent Mode (ModelExchange): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Outputs> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Outputs> with type Real and variability = continuous or discrete. If <ModelStructure><Derivatives> is present, also the variables listed here as state derivatives.\nv_known: Real input variables of function h that changes its value in the actual Mode.\nv_rest:Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔv_unknown = (δh / δv_known) Δv_known\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::AbstractArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model. vUnknown_ref can be equated with v_unknown(variable described above).\nvKnown_ref::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref can be equated with v_known(variable described above).\ndvKnown::Union{AbstractArray{fmi2Real}, Nothing} = nothing: If no seed vector is passed the value nothing is used. The vector values Compute the partial derivative with respect to the given entries in vector vKnown_ref with the matching evaluate of dvKnown.  # gehört das zu den v_rest values\n\nReturns\n\ndvUnknown::Array{fmi2Real}: Return dvUnknown contains the directional derivative vector values.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.9 Getting Partial Derivatives\n\nSee also fmi2GetDirectionalDerivative!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetDirectionalDerivative!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetDirectionalDerivative!","text":"Source: FMISpec2.0.2[p.26]: 2.1.9 Getting Partial Derivatives\n\nThis function computes the directional derivatives of an FMU.\n\nΔvUnknown = ∂h / ∂vKnown ⋅ ΔvKnown\n\n\n\n\n\nfmi2GetDirectionalDerivative!(c::FMU2Component,\n                                   vUnknown_ref::AbstractArray{fmi2ValueReference},\n                                   nUnknown::Csize_t,\n                                   vKnown_ref::AbstractArray{fmi2ValueReference},\n                                   nKnown::Csize_t,\n                                   dvKnown::AbstractArray{fmi2Real},\n                                   dvUnknown::AbstractArray{fmi2Real})\n\nWrapper Function call to compute the partial derivative with respect to the variables vKnown_ref.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1). In every Mode, the general form of the FMU equations are: 𝐯unknown = 𝐡(𝐯known, 𝐯_rest)\n\nv_unknown: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknowns> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Outputs> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><Derivatives>).\nEvent Mode (ModelExchange): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Outputs> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Outputs> with type Real and variability = continuous or discrete. If <ModelStructure><Derivatives> is present, also the variables listed here as state derivatives.\nv_known: Real input variables of function h that changes its value in the actual Mode.\nv_rest:Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔvunknown = (δh / δvknown) Δv_known\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::AbstracArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model. vUnknown_ref can be equated with v_unknown(variable described above).\nnUnknown::Csize_t: Length of the Unknown Array.\nvKnown_ref::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref can be equated with v_known(variable described above).\nnKnown::Csize_t: Length of the Known Array.\ndvKnown::AbstractArray{fmi2Real}:The vector values Compute the partial derivative with respect to the given entries in vector vKnown_ref with the matching evaluate of dvKnown.\ndvUnknown::AbstractArray{fmi2Real}: Stores the directional derivative vector values.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.9 Getting Partial Derivatives\n\nSee also fmi2GetDirectionalDerivative!.\n\n\n\n\n\nfmiGetDirectionalDerivative!(c::FMU2Component,\n                                  vUnknown_ref::AbstractArray{fmi2ValueReference},\n                                  vKnown_ref::AbstractArray{fmi2ValueReference},\n                                  dvKnown::Array{fmi2Real},\n                                  dvUnknown::AbstractArray)\n\nWrapper Function call to compute the partial derivative with respect to the variables vKnown_ref.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns.The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1). In every Mode, the general form of the FMU equations are: 𝐯unknown = 𝐡(𝐯known, 𝐯_rest)\n\nv_unknown: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknowns> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Outputs> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><Derivatives>).\nEvent Mode (ModelExchange): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Outputs> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Outputs> with type Real and variability = continuous or discrete. If <ModelStructure><Derivatives> is present, also the variables listed here as state derivatives.\nv_known: Real input variables of function h that changes its value in the actual Mode.\nv_rest:Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔv_unknown = (δh / δv_known) Δv_known\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::AbstracArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model. vUnknown_ref can be equated with v_unknown(variable described above).\nvKnown_ref::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref can be equated with v_known(variable described above).\ndvUnknown::AbstractArray{fmi2Real}: Stores the directional derivative vector values.\ndvKnown::Union{AbstractArray{fmi2Real}, Nothing} = nothing: If no seed vector is passed the value nothing is used. The vector values Compute the partial derivative with respect to the given entries in vector vKnown_ref with the matching evaluate of dvKnown.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.9 Getting Partial Derivatives\n\nSee also fmi2GetDirectionalDerivative!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2SetRealInputDerivatives","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2SetRealInputDerivatives","text":"Source: FMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\nSets the n-th time derivative of real input variables. vr defines the value references of the variables the array order specifies the corresponding order of derivation of the variables\n\n\n\n\n\nfmi2SetRealInputDerivatives(c::FMU2Component,\n                                vr::AbstractArray{fmi2ValueReference},\n                                nvr::Csize_t,\n                                order::AbstractArray{fmi2Integer}, \n                                value::AbstractArray{fmi2Real})\n\nSets the n-th time derivative of real input variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\nnvr::Csize_t: Argument nvr defines the size of vr.\norder::AbstractArray{fmi2Integer}: Argument order is an AbstractArray of fmi2Integer values witch specifys the corresponding order of derivative of the real input variable.\nvalues::AbstractArray{fmi2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\nSee also fmi2SetRealInputDerivatives.\n\n\n\n\n\nfmi2SetRealInputDerivatives(c::FMU2Component, \n                                vr::AbstractArray{fmi2ValueReference}, \n                                order::AbstractArray{fmi2Integer}, \n                                values::AbstractArray{fmi2Real})\n\nSets the n-th time derivative of real input variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variables whose derivatives shall be set.\norder::AbstractArray{fmi2Integer}: Argument order is an AbstractArray of fmi2Integer values witch specifys the corresponding order of derivative of the real input variable.\nvalues::AbstractArray{fmi2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\nSee also fmi2SetRealInputDerivatives.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMICore.fmi2GetRealOutputDerivatives!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMICore.fmi2GetRealOutputDerivatives!","text":"Source: FMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\nRetrieves the n-th derivative of output values. vr defines the value references of the variables the array order specifies the corresponding order of derivation of the variables\n\n\n\n\n\nfmi2GetRealOutputDerivatives!(c::FMU2Component,  \n                                vr::AbstractArray{fmi2ValueReference}, \n                                nvr::Csize_t, order::AbstractArray{fmi2Integer}, \n                                value::AbstractArray{fmi2Real})\n\nSets the n-th time derivative of real input variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\nnvr::Csize_t: Argument nvr defines the size of vr.\norder::Array{fmi2Integer}: Argument order is an array of fmi2Integer values witch specifys the corresponding order of derivative of the real input variable.\nvalues::Array{fmi2Real}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2SampleJacobian fmi2SampleJacobian!","category":"page"},{"location":"fmi2_lowlevel_library_functions/#External/Additional-functions","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"External/Additional functions","text":"","category":"section"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"setDiscreteStates\ngetDiscreteStates\ngetDiscreteStates!\ngetSimpleTypeAttributeStruct\ngetDeclaredType","category":"page"},{"location":"fmi2_lowlevel_library_functions/#FMIBase.setDiscreteStates","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.setDiscreteStates","text":"ToDo\n\n\n\n\n\nsetDiscreteStates(c::FMU2Component,\n                             x::Union{AbstractArray{Float32},AbstractArray{Float64}})\n\nSet a new (discrete) state vector and reinitialize chaching of variables that depend on states.\n\nArguments\n\n[ToDo]\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIBase.getDiscreteStates","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.getDiscreteStates","text":"getDiscreteStates(c)\n\nSets a new (discrete) state vector (out-of-place).\n\nArguments\n\nc::FMU2Component\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIBase.getDiscreteStates!","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.getDiscreteStates!","text":"getDiscreteStates!(c, xd)\n\nSets a new (discrete) state vector (in-place).\n\nArguments\n\nc::FMU2Component\nxd::AbstractArray{Union{fmi2Real, fmi2Integer, fmi2Boolean}}\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIBase.getSimpleTypeAttributeStruct","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.getSimpleTypeAttributeStruct","text":"getSimpleTypeAttributeStruct(st::fmi2SimpleType)\n\nReturns the attribute structure for the simple type st. Depending on definition, this is either st.Real, st.Integer, st.String, st.Boolean or st.Enumeration.\n\nArguments\n\nst::fmi2SimpleType: Struct which provides the information on custom SimpleTypes.\n\nSource\n\nFMISpec2.0.3 Link: https://fmi-standard.org/\nFMISpec2.0.3[p.40]: 2.2.3 Definition of Types (TypeDefinitions)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/#FMIBase.getDeclaredType","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMIBase.getDeclaredType","text":"getDeclaredType(md::fmi2ModelDescription, mv::fmi2ScalarVariable)\n\nReturns the fmi2SimpleType of the corresponding model variable mv as defined in md.typeDefinitions. If mv does not have a declared type, return nothing. If mv has a declared type, but it is not found, issue a warning and return nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\nmv::fmi2ScalarVariable: The “ModelVariables” element consists of an ordered set of “ScalarVariable” elements. A “ScalarVariable” represents a variable of primitive type, like a real or integer variable.\n\nSource\n\nFMISpec2.0.3 Link: https://fmi-standard.org/\nFMISpec2.0.3: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_lowlevel_library_functions/","page":"FMI Common Concepts for Model Exchange and Co-Simulation","title":"FMI Common Concepts for Model Exchange and Co-Simulation","text":"fmi2GetSolutionDerivative fmi2GetSolutionState fmi2GetSolutionValue fmi2GetSolutionTime fmi2GetJacobian fmi2GetJacobian! fmi2GetFullJacobian fmi2GetFullJacobian!","category":"page"},{"location":"fmi3_lowlevel_CS_functions/#FMI-for-Co-Simulation","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"","category":"section"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"This chapter defines the Functional Mock-up Interface (FMI) for the coupling of two or more simulation models in a Co-Simulation environment (FMI for Co-Simulation). Co-Simulation is a rather general approach to the simulation of coupled technical systems and coupled physical phenomena in engineering with focus on instationary (time-dependent) problems.","category":"page"},{"location":"fmi3_lowlevel_CS_functions/#Transfer-of-Input-/-Output-Values-and-Parameters","page":"FMI for Co-Simulation","title":"Transfer of Input / Output Values and Parameters","text":"","category":"section"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"In order to enable the slave to interpolate the continuous real inputs between communication steps, the derivatives of the inputs with respect to time can be provided. Also, higher derivatives can be set to allow higher order interpolation.","category":"page"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"","category":"page"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"fmi3CallbackIntermediateUpdate","category":"page"},{"location":"fmi3_lowlevel_CS_functions/#Computation","page":"FMI for Co-Simulation","title":"Computation","text":"","category":"section"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"The computation of time steps is controlled by the following function.","category":"page"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"fmi3EnterStepMode\nfmi3DoStep!","category":"page"},{"location":"fmi3_lowlevel_CS_functions/#FMICore.fmi3EnterStepMode","page":"FMI for Co-Simulation","title":"FMICore.fmi3EnterStepMode","text":"Source: FMISpec3.0, Version D5ef1c1: 2.3.5. State: Event Mode\n\nThis function must be called to change from Event Mode into Step Mode in Co-Simulation (see 4.2.).\n\n\n\n\n\nfmi3EnterStepMode(c::FMU3Instance; soft::Bool=false)\n\nThis function must be called to change from Event Mode into Step Mode in Co-Simulation (see 4.2.).\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the fmi3Teminate needs to be called in state  fmi3InstanceStateContinuousTimeMode or fmi3InstanceStateEventMode.\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions \nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 2.3.5. State: Event Mode\n\nSee also fmi3EnterStepMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_CS_functions/#FMICore.fmi3DoStep!","page":"FMI for Co-Simulation","title":"FMICore.fmi3DoStep!","text":"Source: FMISpec3.0, Version D5ef1c1: 4.2.1. State: Step Mode\n\nThe computation of a time step is started.\n\n\n\n\n\nfmi3DoStep!(c::FMU3Instance, currentCommunicationPoint::fmi3Float64, communicationStepSize::fmi3Float64, noSetFMUStatePriorToCurrentPoint::fmi3Boolean,\n                eventEncountered::Ref{fmi3Boolean}, terminateSimulation::Ref{fmi3Boolean}, earlyReturn::Ref{fmi3Boolean}, lastSuccessfulTime::Ref{fmi3Float64})\n\nThe computation of a time step is started.\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\ncurrentCommunicationPoint::fmi3Float64:  \ncommunicationStepSize::fmi3Float64: \nnoSetFMUStatePriorToCurrentPoint::fmi3Boolean: \neventEncountered::Ref{fmi3Boolean}: \nterminateSimulation::Ref{fmi3Boolean}: \nearlyReturn::Ref{fmi3Boolean}: \nlastSuccessfulTime::Ref{fmi3Float64}: \n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 4.2.1. State: Step Mode\n\nSee also fmi3DoStep!.\n\n\n\n\n\nfmi3DoStep!(c::FMU3Instance, currentCommunicationPoint::Union{Real, Nothing} = nothing, communicationStepSize::Union{Real, Nothing} = nothing, noSetFMUStatePriorToCurrentPoint::Bool = true,\n    eventEncountered::fmi3Boolean = fmi3False, terminateSimulation::fmi3Boolean = fmi3False, earlyReturn::fmi3Boolean = fmi3False, lastSuccessfulTime::fmi3Float64 = 0.0)\n\nThe computation of a time step is started.\n\nTODO argmuents\n\nArguments\n\nc::FMU3Instance: Mutable struct represents an instantiated instance of an FMU in the FMI 3.0 Standard.\ncurrentCommunicationPoint::Union{Real, Nothing} = nothing\ncommunicationStepSize::Union{Real, Nothing} = nothing\nnoSetFMUStatePriorToCurrentPoint::Bool = true\neventEncountered::fmi3Boolean = fmi3False\nterminateSimulation::fmi3Boolean = fmi3False\nearlyReturn::fmi3Boolean = fmi3False\nlastSuccessfulTime::fmi3Float64 = 0.0\n\nReturns\n\nstatus::fmi3Status: Return status is an enumeration of type fmi3Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi3OK: all well\nfmi3Warning: things are not quite right, but the computation can continue\nfmi3Discard: if the slave computed successfully only a subinterval of the communication step\nfmi3Error: the communication step could not be carried out at all\nfmi3Fatal: if an error occurred which corrupted the FMU irreparably\n\nSource\n\nFMISpec3.0 Link: https://fmi-standard.org/\nFMISpec3.0: 2.2.3 Platform Dependent Definitions\nFMISpec3.0: 2.2.4 Status Returned by Functions\nFMISpec3.0: 4.2.1. State: Step Mode\n\nSee also fmi3DoStep!.\n\n\n\n\n\n","category":"function"},{"location":"fmi3_lowlevel_CS_functions/#Retrieving-Status-Information-from-the-Slave","page":"FMI for Co-Simulation","title":"Retrieving Status Information from the Slave","text":"","category":"section"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"Status information is retrieved from the slave by the following functions:","category":"page"},{"location":"fmi3_lowlevel_CS_functions/","page":"FMI for Co-Simulation","title":"FMI for Co-Simulation","text":"","category":"page"},{"location":"fmi_lowlevel_library_functions/#Functions-in-FMI-Import/Core-.jl","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"","category":"section"},{"location":"fmi_lowlevel_library_functions/","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"logInfo\nlogWarning\nlogError","category":"page"},{"location":"fmi_lowlevel_library_functions/#FMIBase.logInfo","page":"Functions in FMI Import/Core .jl","title":"FMIBase.logInfo","text":"Prints a message with level info if the log level allows it.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.logWarning","page":"Functions in FMI Import/Core .jl","title":"FMIBase.logWarning","text":"Prints a message with level warn if the log level allows it.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.logError","page":"Functions in FMI Import/Core .jl","title":"FMIBase.logError","text":"Prints a message with level error if the log level allows it.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"loadBinary eval!","category":"page"},{"location":"fmi_lowlevel_library_functions/#Conversion-functions","page":"Functions in FMI Import/Core .jl","title":"Conversion functions","text":"","category":"section"},{"location":"fmi_lowlevel_library_functions/","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"stringToStatus\nstatusToString\nstringToDependencyKind\ndependencyKindToString\nvalueReferenceToString\nstringToInitial\ninitialToString\nstringToIntervalQualifier\nstringToDataType\nstringToCausality\ncausalityToString\nstringToVariability\nvariabilityToString","category":"page"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToStatus","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToStatus","text":"stringToStatus(s)\n\nConverts a String s to fmi2Status.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.statusToString","page":"Functions in FMI Import/Core .jl","title":"FMIBase.statusToString","text":"statusToString(::struct, status::Union{fmi2Status, Integer})\n\nConverts fmi2Status status into a String (\"OK\", \"Warning\", \"Discard\", \"Error\", \"Fatal\", \"Pending\").\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToDependencyKind","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToDependencyKind","text":"stringToDependencyKind(s::AbstractString)\n\nConverts s (\"dependent\", \"constant\", \"fixed\", \"tunable\", \"discrete\") to the corresponding fmi2DependencyKind\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.dependencyKindToString","page":"Functions in FMI Import/Core .jl","title":"FMIBase.dependencyKindToString","text":"dependencyKindToString(c::fmi2DependencyKind)\n\nConverts fmi2DependencyKind c to the corresponding String (\"dependent\", \"constant\", \"fixed\", \"tunable\", \"discrete\")\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.valueReferenceToString","page":"Functions in FMI Import/Core .jl","title":"FMIBase.valueReferenceToString","text":"valueReferenceToString(obj, reference)\n\nwhere: \n\nobj ∈ (fmi2ModelDescription, fmi3ModelDescription, FMU2, FMU3) reference ∈ (fmi2ValueReference, fmi3ValueReference, Integer\n\nReturns the string identifier for a give value reference.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToInitial","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToInitial","text":"stringToInitial(s::AbstractString)\n\nConverts s (\"approx\", \"exact\", \"calculated\") to the corresponding fmi2Initial.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.initialToString","page":"Functions in FMI Import/Core .jl","title":"FMIBase.initialToString","text":"fmi2InitialToString(c::fmi2Initial)\n\nConverts fmi2Initial c to the corresponding String (\"approx\", \"exact\", \"calculated\").\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToIntervalQualifier","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToIntervalQualifier","text":"stringToIntervalQualifier(::FMI3Struct, s::AbstractString)\n\nConvert s (\"intervalNotYetKnown\", \"intervalUnchanged\", \"intervalChanged\") to the corresponding fmi3IntervalQualifier.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToDataType","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToDataType","text":"stringToDataType(modelDescription, typename)\n\nConverts a typename to type, for example \"Float64\" (::String) to fmi3Float64 (::DataType).\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToCausality","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToCausality","text":"stringToCausality(s::AbstractString)\n\nConverts s (\"parameter\", \"calculatedParameter\", \"input\", \"output\", \"local\", \"independent\") to the corresponding fmi2Causality.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.causalityToString","page":"Functions in FMI Import/Core .jl","title":"FMIBase.causalityToString","text":"causalityToString(c::fmi2Causality)\n\nConverts fmi2Causality c to the corresponding String (\"parameter\", \"calculatedParameter\", \"input\", \"output\", \"local\", \"independent\").\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.stringToVariability","page":"Functions in FMI Import/Core .jl","title":"FMIBase.stringToVariability","text":"stringToVariability(s::AbstractString)\n\nConverts s (\"constant\", \"fixed\", \"tunable\", \"discrete\", \"continuous\") to the corresponding fmi2Variability.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.variabilityToString","page":"Functions in FMI Import/Core .jl","title":"FMIBase.variabilityToString","text":"variabilityToString(c::fmi2Variability)\n\nConverts fmi2Variability c to the corresponding String (\"constant\", \"fixed\", \"tunable\", \"discrete\", \"continuous\").\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"fmi2StringToInitial","category":"page"},{"location":"fmi_lowlevel_library_functions/#External/Additional-functions","page":"Functions in FMI Import/Core .jl","title":"External/Additional functions","text":"","category":"section"},{"location":"fmi_lowlevel_library_functions/","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"getInitial\ngetStartValue\nhasCurrentInstance\ngetCurrentInstance\nmodelVariablesForValueReference\nsetValue\ngetValue\ngetValue!\ngetUnit","category":"page"},{"location":"fmi_lowlevel_library_functions/#FMIBase.getInitial","page":"Functions in FMI Import/Core .jl","title":"FMIBase.getInitial","text":"getInitial(mv::fmi2ScalarVariable)\n\nReturns the inital entry of the corresponding model variable.\n\nArguments\n\nfmi2GetStartValue(mv::fmi2ScalarVariable): The “ModelVariables” element consists of an ordered set of “ScalarVariable” elements. A “ScalarVariable” represents a variable of primitive type, like a real or integer variable.\n\nReturns\n\nmv.Real.unit: Returns the inital entry of the corresponding ScalarVariable representing a variable of the primitive type Real. Otherwise nothing is returned.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.getStartValue","page":"Functions in FMI Import/Core .jl","title":"FMIBase.getStartValue","text":"getStartValue(md::fmi2ModelDescription, vrs::fmi2ValueReferenceFormat = md.valueReferences)\n\nReturns the start/default value for a given value reference.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\nvrs::fmi2ValueReferenceFormat = md.valueReferences: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nstarts::Array{fmi2ValueReferenceFormat}: start/default value for a given value reference\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.hasCurrentInstance","page":"Functions in FMI Import/Core .jl","title":"FMIBase.hasCurrentInstance","text":"ToDo: Doc String\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.getCurrentInstance","page":"Functions in FMI Import/Core .jl","title":"FMIBase.getCurrentInstance","text":"ToDo: Doc String\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.modelVariablesForValueReference","page":"Functions in FMI Import/Core .jl","title":"FMIBase.modelVariablesForValueReference","text":"modelVariablesForValueReference(obj, vr)\n\nwhere:\n\nobj ∈ (fmi2ModelDescription, fmi3ModelDescription, FMU2, FMU3) vr ∈ (fmi2ValueReference, fmi3ValueReference)\n\nReturns the model variable(s) matching the value reference.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.setValue","page":"Functions in FMI Import/Core .jl","title":"FMIBase.setValue","text":"setValue(component,\n            vrs::fmi2ValueReferenceFormat,\n            srcArray::AbstractArray;\n            filter=nothing)\n\nStores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference and returns an array that indicates the Status.\n\nArguments\n\ncomp::FMUInstance (FMU2Component or FMU3Instance): Mutable struct represents an instantiated instance of an FMU in the FMI 2 or 3.\nvrs::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\nsrcArray::AbstractArray: Stores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference to the input variable vr (vr = vrs[i]). srcArray has the same length as vrs.\n\nKeywords\n\nfilter=nothing: It is applied to each ModelVariable to determine if it should be updated.\n\nReturns\n\nretcodes::Array{fmi2Status}: Returns an array of length length(vrs) with Type fmi2Status. Type fmi2Status is an enumeration and indicates the success of the function call.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.getValue","page":"Functions in FMI Import/Core .jl","title":"FMIBase.getValue","text":"getValue(comp::FMU2Component, vrs::fmi2ValueReferenceFormat)\n\nReturns the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference in an array.\n\nArguments\n\ncomp::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvrs::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\ndstArray::Array{Any,1}(undef, length(vrs)): Stores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference to the input variable vr (vr = vrs[i]). dstArray is a 1-Dimensional Array that has the same length as vrs.\n\n\n\n\n\ngetValue(solution::FMUSolution, vr::fmi2ValueReferenceFormat; isIndex::Bool=false)\n\nReturns the Solution values.\n\nArguments\n\nsolution::FMUSolution: Struct contains information about the solution value, success, state and  events of a specific FMU.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nisIndex::Bool=false: Argument isIndex exists to check if vr ist the specific solution element (\"index\") that equals the given fmi2ValueReferenceFormat\n\nReturn\n\nIf he length of the given references equals 1, each element u in the collection solution.values.saveval is selecting the element at the index represented by indices[1] and returns it.\n\nThus, the collect() function is taking the generator expression and returning an array of the selected elements. \n\nIf more than one reference is given, the same process takes place as before. The difference is that now more than one index is accessed.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.getValue!","page":"Functions in FMI Import/Core .jl","title":"FMIBase.getValue!","text":"getValue!(comp::FMU2Component, vrs::fmi2ValueReferenceFormat, dst::AbstractArray)\n\nRetrieves values for the refernces vrs and stores them in dst\n\nArguments\n\ncomp::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvrs::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\ndst::AbstractArray: The array of destinations, must match the data types of the value references.\n\nReturns\n\nretcodes::Array{fmi2Status}: Returns an array of length length(vrs) with Type fmi2Status. Type fmi2Status is an enumeration and indicates the success of the function call.\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/#FMIBase.getUnit","page":"Functions in FMI Import/Core .jl","title":"FMIBase.getUnit","text":"getUnit(mv::fmi2ScalarVariable)\n\nReturns the unit entry (a string) of the corresponding model variable.\n\nArguments\n\nfmi2GetStartValue(mv::fmi2ScalarVariable): The “ModelVariables” element consists of an ordered set of “ScalarVariable” elements. A “ScalarVariable” represents a variable of primitive type, like a real or integer variable.\n\nReturns\n\nmv.Real.unit: Returns the unit entry of the corresponding ScalarVariable representing a variable of the primitive type Real. Otherwise nothing is returned.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\n","category":"function"},{"location":"fmi_lowlevel_library_functions/","page":"Functions in FMI Import/Core .jl","title":"Functions in FMI Import/Core .jl","text":"fmi2GetSolutionDerivative fmi2GetSolutionState fmi2GetSolutionValue fmi2GetSolutionTime fmi2GetJacobian fmi2GetJacobian! fmi2GetFullJacobian fmi2GetFullJacobian!","category":"page"},{"location":"index_library/#All-library-elements-of-FMI,-Import,-Export,-Core-and-Build","page":"API Index","title":"All library elements of FMI, Import, Export, Core and Build","text":"","category":"section"},{"location":"index_library/","page":"API Index","title":"API Index","text":"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: FMI.jl Logo)","category":"page"},{"location":"#FMI.jl","page":"Introduction","title":"FMI.jl","text":"","category":"section"},{"location":"#What-is-FMI.jl?","page":"Introduction","title":"What is FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI.jl is a free-to-use software library for the Julia programming language which integrates the Functional Mock-Up Interface (fmi-standard.org): load or create, parameterize, differentiate, linearize, simulate and plot FMUs seamlessly inside the Julia programming language!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":" \nDocumentation (Image: Build Docs) (Image: Dev Docs)\nExamples (Image: Examples (latest))\nTests (Image: Test (latest)) (Image: Test (LTS)) (Image: Aqua QA)\nFMI cross checks (Image: FMI2 Cross Checks)\nPackage evaluation (Image: Run PkgEval)\nCode coverage (Image: Coverage)\nCollaboration (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)\nFormatting (Image: SciML Code Style)","category":"page"},{"location":"#Breaking-Changes-in-FMI.jl-(starting-from-v0.14.0-until-release-of-v1.0.0)","page":"Introduction","title":"Breaking Changes in FMI.jl (starting from v0.14.0 until release of v1.0.0)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you want to migrate your project from FMI.jl < v1.0.0 to >= v1.0.0, you will face some breaking changes - but they are worth it as you will see! We decided to do multiple smaller breaking changes starting with v0.14.0, instead of one big one. Some of them are already implemented (checked), some are still on the todo (unchecked) but will be implemented before releasing v1.0.0.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[x] Many functions, that are not part of the FMI-standard, had the prefix fmi2... or fmi3.... This was corrected. Now, only functions that are defined by the standard itself, like e.g. fmi2Instantiate are allowed to keep the prefix. Other methods, like fmi2ValueReferenceToString, that where added to make this library more comfortable, are now cleaned to be more the Julia way: valueReferenceToString. If your code errors, the corresponding function might have lost it's prefix, so try this first.\n[x] Wrapper functions where removed, because that is not the Julia way. In most cases, this will not affect your code.\n[x] FMICore.jl and FMIImport.jl were divided into FMICore.jl, FMIImport.jl and FMIBase.jl. FMICore.jl now holds the pure standard definition (C-types and -functions), while FMIBase.jl holds everything that is needed on top of that in FMIImport.jl as well as in FMIExport.jl.\n[ ] Updated all library examples.\n[ ] Updated all library tests for a better code coverage.\n[ ] We tried to document every function, if you find undocumented user-level functions, please open an issue or PR.\n[ ] Allocations, type stability and code format where optimized and are monitored by CI now.\n[ ] Dependencies are reduced a little, to make the libraries more light-weight.\n[ ] RAM for allocated FMUs, their instances and states, is now auto-released. For maximum performance/safety you can use FMUs in blocks (like file reading/writing).\n[ ] New low-level interfaces are introduced, that fit the SciML-ecosystem. For example, a FMU can still be simulated with simulate(fmu), but one can also decide to create a prob = FMUProblem(fmu) (like an ODEProblem) and use solve(prob) to obtain a solution. Keywords will be adapted to have a fully consistent interface with the remaining SciML-ecosystem.\n[ ] Optimization for new Julia LTS v1.10, removing code to keep downward compatibility with old LTS v1.6.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"🎉 After all listed features are implemented, v1.0.0 will be released! 🎉 ","category":"page"},{"location":"#How-can-I-use-FMI.jl?","page":"Introduction","title":"How can I use FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"1. Open a Julia-REPL, switch to package mode using ], activate your preferred environment.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"2. Install FMI.jl:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(@v1) pkg> add FMI","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"3. If you want to check that everything works correctly, you can run the tests bundled with FMI.jl:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(@v1) pkg> test FMI","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"4. Have a look inside the examples folder in the examples branch or the examples section of the documentation. All examples are available as Julia-Script (.jl), Jupyter-Notebook (.ipynb) and Markdown (.md).","category":"page"},{"location":"#How-can-I-simulate-a-FMU-and-plot-values?","page":"Introduction","title":"How can I simulate a FMU and plot values?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using FMI, Plots\n\n# load and instantiate a FMU\nfmu = loadFMU(pathToFMU) \n\n# simulate from t=0.0s until t=10.0s and record the FMU variable named \"mass.s\"\nsimData = simulate(fmu, (0.0, 10.0); recordValues=[\"mass.s\"])\n\n# plot it!\nplot(simData)\n\n# free memory\nunloadFMU(myFMU)","category":"page"},{"location":"#What-is-currently-supported-in-FMI.jl?","page":"Introduction","title":"What is currently supported in FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"importing the full FMI 2.0.3 and FMI 3.0.0 command set, including optional specials like fmi2GetFMUstate, fmi2SetFMUstate and fmi2GetDirectionalDerivatives\nparameterization, simulation & plotting of CS- and ME-FMUs\nevent-handling for imported discontinuous ME-FMUs","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":" FMI2.0.3  FMI3.0  SSP1.0 \n Import Export Import Export Import Export\nCS ✔️✔️ 🚧 ✔️✔️ 📅 📅 📅\nME (continuous) ✔️✔️ ✔️✔️ ✔️✔️ 📅 📅 📅\nME (discontinuous) ✔️✔️ ✔️✔️ ✔️✔️ 📅 📅 📅\nSE 🚫 🚫 🚧 📅 🚫 🚫\nExplicit solvers ✔️✔️ ✔️✔️ ✔️✔️ 📅 📅 📅\nImplicit solvers (autodiff=false) ✔️✔️ ✔️✔️ ✔️✔️ 📅 📅 📅\nImplicit solvers (autodiff=true) ✔️ ✔️✔️ ✔️ 📅 📅 📅\nget/setFMUstate ✔️✔️ 📅 ✔️✔️ 📅 🚫 🚫\ngetDirectionalDerivatives ✔️✔️ 📅 ✔️✔️ 📅 🚫 🚫\ngetAdjointDerivatives 🚫 🚫 ✔️✔️ 📅 🚫 🚫\nFMI Cross Checks ✔️✔️ 📅 📅 📅 🚫 🚫\n64-bit binaries in FMUs ✔️✔️ ✔️✔️ ✔️✔️ 📅 🚫 🚫\n32-bit binaries in FMUs ✔️ 📅 📅 📅 🚫 🚫","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"✔️✔️ supported & CI-tested","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"✔️  beta supported: implemented, but not CI-tested","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"🚧 work in progress","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"📅  planned","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"🚫  not supported by the corresponding FMI standard (not applicable)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"❌  not planned","category":"page"},{"location":"#What-FMI.jl-Library-to-use?","page":"Introduction","title":"What FMI.jl-Library to use?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: FMI.jl Logo) To keep dependencies nice and clean, the original package FMI.jl had been split into new packages:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI.jl: High level loading, manipulating, saving or building entire FMUs from scratch\nFMIImport.jl: Importing FMUs into Julia\nFMIExport.jl: Exporting stand-alone FMUs from Julia Code\nFMIBase.jl: Common concepts for import and export of FMUs\nFMICore.jl: C-code wrapper for the FMI-standard\nFMISensitivity.jl: Static and dynamic sensitivities over FMUs\nFMIBuild.jl: Compiler/Compilation dependencies for FMIExport.jl\nFMIFlux.jl: Machine Learning with FMUs\nFMIZoo.jl: A collection of testing and example FMUs","category":"page"},{"location":"#What-Platforms-are-supported?","page":"Introduction","title":"What Platforms are supported?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI.jl is tested (and testing) under Julia Versions 1.6 LTS (64-bit) and latest (64-bit) on Windows latest (64-bit, 32-bit) and Ubuntu latest (64-bit). Mac (64-bit, 32-bit) and Ubuntu (32-bit) should work, but untested. For the best performance, we recommend using Julia >= 1.7, even if we support and test for the official LTS (1.6.7).","category":"page"},{"location":"#How-to-cite?","page":"Introduction","title":"How to cite?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Tobias Thummerer, Lars Mikelsons and Josef Kircher. 2021. NeuralFMU: towards structural integration of FMUs into neural networks. Martin Sjölund, Lena Buffoni, Adrian Pop and Lennart Ochel (Ed.). Proceedings of 14th Modelica Conference 2021, Linköping, Sweden, September 20-24, 2021. Linköping University Electronic Press, Linköping (Linköping Electronic Conference Proceedings ; 181), 297-306. DOI: 10.3384/ecp21181297","category":"page"},{"location":"#Related-publications?","page":"Introduction","title":"Related publications?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Tobias Thummerer, Johannes Stoljar and Lars Mikelsons. 2022. NeuralFMU: presenting a workflow for integrating hybrid NeuralODEs into real-world applications. Electronics 11, 19, 3202. DOI: 10.3390/electronics11193202","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Tobias Thummerer, Johannes Tintenherr, Lars Mikelsons. 2021 Hybrid modeling of the human cardiovascular system using NeuralFMUs Journal of Physics: Conference Series 2090, 1, 012155. DOI: 10.1088/1742-6596/2090/1/012155","category":"page"},{"location":"#Notes-for-contributors","page":"Introduction","title":"Notes for contributors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Contributors are welcome. Before contributing, please read, understand and follow the Contributor's Guide on Collaborative Practices for Community Packages.  During development of new implementations or optimizations on existing code, one will have to make design decisions that influence the library performance and usability. The following prioritization should be the basis for decision-making:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"#1 Compliance with standard: It is the highest priority to be compliant with the FMI standard (fmi-standard.org). Identifiers described in the standard must be used. Topologies should follow the specification as far as the possibilities of the Julia programming language allows.\n#2 Performance: Because FMI.jl is a simulation tool, performance is very important. This applies to the efficient use of CPU and GPU, but also the conscientious use of RAM and disc space.\n#3 Usability: The library should be as usable as possible and feel \"the Julia way\" (e.g. by using multiple dispatch instead of the \"C coding style\"), as long as being fully compliant with the FMI standard.","category":"page"},{"location":"examples/modelica_conference_2021/#Example-from-the-Modelica-Conference-2021","page":"Modelica conference 2021","title":"Example from the Modelica Conference 2021","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Tutorial by Tobias Thummerer, Johannes Stoljar","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"This example was updated over time to keep track with developments and changes in FMI.jl.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"🚧 This tutorial is under revision and will be replaced by an up-to-date version soon 🚧","category":"page"},{"location":"examples/modelica_conference_2021/#License","page":"Modelica conference 2021","title":"License","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/modelica_conference_2021/#Introduction-to-the-example","page":"Modelica conference 2021","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"FMUs can be simulated in multiple ways using FMI.jl. You can use a very simple interface, that offers possibilities that satisfy almost any user requirement. However, if you need to build a custom simulation loop for your use case using the core FMI functions, we show that too.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"(Image: svg)  ","category":"page"},{"location":"examples/modelica_conference_2021/#Other-formats","page":"Modelica conference 2021","title":"Other formats","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/modelica_conference_2021/#Code-section","page":"Modelica conference 2021","title":"Code section","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots","category":"page"},{"location":"examples/modelica_conference_2021/#Simulation-setup","page":"Modelica conference 2021","title":"Simulation setup","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Next, the start time and end time of the simulation are set. Finally, a step size is specified to store the results of the simulation at these time steps.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"tStart = 0.0\ntStep = 0.1\ntStop = 8.0\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"0.0:0.1:8.0","category":"page"},{"location":"examples/modelica_conference_2021/#Simple-FMU-Simulation","page":"Modelica conference 2021","title":"Simple FMU Simulation","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Next, the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"# we use an FMU from the FMIZoo.jl\nfmu = loadFMU(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\")\ninfo(fmu)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringFrictionPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{2e178ad3-5e9b-48ec-a7b2-baa5669efc0c}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:12Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t24\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\tStates:\t\t\t\t2\n\n\n\t\t33554432 [\"mass.s\"]\n\t\t33554433 [\"mass.v\", \"mass.v_relfric\"]\n\tParameters:\t\t\t12\n\t\t16777216 [\"fricScale\"]\n\t\t16777217 [\"s0\"]\n\t\t16777218 [\"v0\"]\n\t\t16777219 [\"fixed.s0\"]\n\t\t...\n\t\t16777223 [\"mass.smin\"]\n\t\t16777224 [\"mass.v_small\"]\n\t\t16777225 [\"mass.L\"]\n\t\t16777226 [\"mass.m\"]\n\t\t16777227 [\"mass.fexp\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/modelica_conference_2021/#Easy-Simulation","page":"Modelica conference 2021","title":"Easy Simulation","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"In the next commands the FMU is simulated, for which the start and end time and recorded variables are declared. Afterwards the simulation result is plotted. In the plot for the FMU, it can be seen that the oscillation keeps decreasing due to the effect of friction. If one simulates long enough, the oscillation comes to a standstill after a certain time.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"simData = simulate(fmu, (tStart, tStop); recordValues=[\"mass.s\"], saveat=tSave)\nplot(simData)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"unloadFMU(fmu)","category":"page"},{"location":"examples/modelica_conference_2021/#Custom-Simulation","page":"Modelica conference 2021","title":"Custom Simulation","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"In the following type of simulation a more advanced variant is presented, which allows intervening more in the simulation process. Analogous to the simple variant, an FMU model must be loaded.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"fmu = loadFMU(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\")","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Model name:\tSpringFrictionPendulum1D\nType:\t\t1","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Next, it is necessary to create an instance of the FMU, this is achieved by the command fmi2Instantiate!().  ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"instanceFMU = fmi2Instantiate!(fmu)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"FMU:            SpringFrictionPendulum1D\n    InstanceName:   SpringFrictionPendulum1D\n    Address:        Ptr{Nothing} @0x000001bb78171a50\n    State:          0\n    Logging:        false\n    FMU time:       -Inf\n    FMU states:     nothing","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"In the following code block, start and end time for the simulation is set by the fmi2SetupExperiment() command. Next, the FMU is initialized by the calls of fmi2EnterInitializationMode() and fmi2ExitInitializationMode(). It would also be possible to set initial states, parameters or inputs at this place in code.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"fmi2SetupExperiment(instanceFMU, tStart, tStop)\n# set initial model states\nfmi2EnterInitializationMode(instanceFMU)\n# get initial model states\nfmi2ExitInitializationMode(instanceFMU)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"0x00000000","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"The actual simulation loop is shown in the following block. Here a simulation step fmi2DoStep() with the fixed step size tStep is executed. As indicated in the code by the comments, the input values and output values of the FMU could be changed in the simulation loop as desired, whereby the higher possibility of adjustments arises.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"values = []\n\nfor t in tSave\n    # set model inputs if any\n    # ...\n\n    fmi2DoStep(instanceFMU, tStep)\n    \n    # get model outputs\n    value = fmi2GetReal(instanceFMU, \"mass.s\")\n    push!(values, value)\nend\n\nplot(tSave, values)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"The instantiated FMU must be terminated and then the memory area for the instance can also be deallocated. The last step is to unload the FMU to remove all unpacked data on disc. ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"fmi2Terminate(instanceFMU)\nfmi2FreeInstance!(instanceFMU)\nunloadFMU(fmu)","category":"page"},{"location":"examples/modelica_conference_2021/#Summary","page":"Modelica conference 2021","title":"Summary","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"The tutorial has shown how to use the default simulation command and how to deploy a custom simulation loop.","category":"page"},{"location":"examples/parameterize/#Parameterize-a-FMU","page":"Parameterize","title":"Parameterize a FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Tutorial by Tobias Thummerer, Johannes Stoljar","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Last update: 09.08.2023","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"🚧 This tutorial is under revision and will be replaced by an up-to-date version soon 🚧","category":"page"},{"location":"examples/parameterize/#License","page":"Parameterize","title":"License","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/parameterize/#Introduction","page":"Parameterize","title":"Introduction","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"This example shows how to parameterize a FMU. We will show to possible ways to parameterize: The default option using the parameterization feature of fmiSimulate, fmiSimulateME or fmiSimulateCS. Second, a custom parameterization routine for advanced users. ","category":"page"},{"location":"examples/parameterize/#Other-formats","page":"Parameterize","title":"Other formats","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/parameterize/#Code-section","page":"Parameterize","title":"Code section","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"# imports\nusing FMI\nusing FMIZoo","category":"page"},{"location":"examples/parameterize/#Simulation-setup","page":"Parameterize","title":"Simulation setup","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Next, the start time and end time of the simulation are set.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"tStart = 0.0\ntStop = 1.0\ntSave = collect(tStart:tStop)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"2-element Vector{Float64}:\n 0.0\n 1.0","category":"page"},{"location":"examples/parameterize/#Import-FMU","page":"Parameterize","title":"Import FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"# we use an FMU from the FMIZoo.jl\n# just replace this line with a local path if you want to use your own FMU\npathToFMU = get_model_filename(\"IO\", \"Dymola\", \"2022x\")\n\nfmu = loadFMU(pathToFMU)\ninfo(fmu)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"#################### Begin information for FMU ####################\n\tModel name:\t\t\tIO\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{889089a6-481b-41a6-a282-f6ce02a33aa6}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:53:52Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t4\n\tInputs:\t\t\t\t3\n\t\t352321536 [\"u_real\"]\n\t\t352321537 [\"u_boolean\"]\n\t\t352321538 [\"u_integer\"]\n\tOutputs:\t\t\t3\n\t\t335544320 [\"y_real\"]\n\t\t335544321 [\"y_boolean\"]\n\t\t335544322 [\"y_integer\"]\n\tStates:\t\t\t\t0\n\tParameters:\t\t\t5\n\t\t16777216 [\"p_real\"]\n\t\t16777217 [\"p_integer\"]\n\t\t16777218 [\"p_boolean\"]\n\t\t16777219 [\"p_enumeration\"]\n\t\t134217728 [\"p_string\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tIO\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\n\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tIO\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/parameterize/#Option-A:-Integrated-parameterization-feature-of-*FMI.jl*","page":"Parameterize","title":"Option A: Integrated parameterization feature of FMI.jl","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"If you are using the commands for simulation integrated in FMI.jl, the parameters and initial conditions are set at the correct locations during the initialization process of your FMU. This is the recommended way of parameterizing your model, if you don't have very uncommon requirements regarding initialization.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"dict = Dict{String, Any}()\ndict","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Dict{String, Any}()","category":"page"},{"location":"examples/parameterize/#Option-B:-Custom-parameterization-routine","page":"Parameterize","title":"Option B: Custom parameterization routine","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"If you have special requirements for initialization and parameterization, you can write your very own parameterization routine.","category":"page"},{"location":"examples/parameterize/#Instantiate-and-Setup-FMU","page":"Parameterize","title":"Instantiate and Setup FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Next it is necessary to create an instance of the FMU. This is achieved by the command fmiInstantiate!().","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"c = fmi2Instantiate!(fmu; loggingOn=true)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"FMU:            IO\n    InstanceName:   IO\n    Address:        Ptr{Nothing} @0x000001ce7d77d6f0\n    State:          0\n    Logging:        true\n    FMU time:       -Inf\n    FMU states:     nothing","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the following code block, start and end time for the simulation is set by the fmiSetupExperiment() command.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmi2SetupExperiment(c, tStart, tStop)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/#Parameterize-FMU","page":"Parameterize","title":"Parameterize FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In this example, for each data type (real, boolean, integer and string) a corresponding input or parameter is selected. From here on, the inputs and parameters will be referred to as parameters for simplicity.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"params = [\"p_real\", \"p_boolean\", \"p_integer\", \"p_string\"]","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"4-element Vector{String}:\n \"p_real\"\n \"p_boolean\"\n \"p_integer\"\n \"p_string\"","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"At the beginning we want to display the initial state of these parameters, for which the FMU must be in initialization mode. The next function fmiEnterInitializationMode() informs the FMU to enter the initialization mode. Before calling this function, the variables can be set. Furthermore, fmiSetupExperiment() must be called at least once before calling fmiEnterInitializationMode(), in order that the start time is defined.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmi2EnterInitializationMode(c)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The initial state of these parameters are displayed with the function getValue().","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"getValue(c, params)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"4-element Vector{Any}:\n 0.0\n 0\n 0\n  \"Hello World!\"","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The initialization mode is terminated with the function fmi2ExitInitializationMode(). (For the model exchange FMU type, this function switches off all initialization equations, and enters the event mode implicitly.)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmi2ExitInitializationMode(c)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the next step, a function is defined that generates a random value for each parameter. For the parameter p_string a random number is inserted into the string. All parameters are combined to a tuple and output.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"function generateRandomNumbers()\n    rndReal = 100 * rand()\n    rndBoolean = rand() > 0.5\n    rndInteger = round(Integer, 100 * rand())\n    rndString = \"Random number $(100 * rand())!\"\n\n    return rndReal, rndBoolean, rndInteger, rndString\nend","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"generateRandomNumbers (generic function with 1 method)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The previously defined function is called and the results are displayed in the console.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"paramsVal = generateRandomNumbers()","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"(43.89793421294513, true, 53, \"Random number 10.450564123938022!\")","category":"page"},{"location":"examples/parameterize/#First-variant","page":"Parameterize","title":"First variant","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To show the first variant, it is necessary to terminate and reset the FMU instance. Then, as before, the setup command must be called for the FMU. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmi2Terminate(c)\nfmi2Reset(c)\nfmi2SetupExperiment(c, tStart, tStop)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the next step it is possible to set the parameters for the FMU. With the first variant it is quickly possible to set all parameters at once. Even different data types can be set with only one command. The command setValue() selects itself which function is chosen for which data type.  As long as the output of the function gives the status code 0, setting the parameters has worked.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"setValue(c, params, collect(paramsVal))","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"4-element Vector{UInt32}:\n 0x00000000\n 0x00000000\n 0x00000000\n 0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"After setting the parameters, it can be checked whether the corresponding parameters were set correctly. For this the function getValue() can be used as above. To be able to call the function getValue() the FMU must be in initialization mode.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmi2EnterInitializationMode(c)\n# getValue(c, params)\nfmi2ExitInitializationMode(c)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Now the FMU has been initialized correctly, the FMU can be simulated. The simulate() command is used for this purpose. It must be pointed out that the keywords instantiate=false, setup=false must be set. The keyword instantiate=false prevents the simulation command from creating a new FMU instance, otherwise our parameterization will be lost. The keyword setup=false prevents the FMU from calling the initialization mode again. The additionally listed keyword freeInstance=false prevents that the instance is removed after the simulation. This is only needed in this example, because we want to continue working on the created instance. Another keyword is the recordValues=parmas[1:3], which saves: p_real, p_boolean and p_integer as output. It should be noted that the simulate() function is not capable of outputting string values, so p_string is omitted.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"simData = simulate(c, (tStart, tStop); recordValues=params[1:3], saveat=tSave, \n                        instantiate=false, setup=false, freeInstance=false, terminate=false, reset=false)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Model name:\n\tIO\nSuccess:\n\ttrue\nf(x)-Evaluations:\n\tIn-place: 0\n\tOut-of-place: 0\nJacobian-Evaluations:\n\t∂ẋ_∂p: 0\n\t∂ẋ_∂x: 0\n\t∂ẋ_∂u: 0\n\t∂y_∂p: 0\n\t∂y_∂x: 0\n\t∂y_∂u: 0\n\t∂e_∂p: 0\n\t∂e_∂x: 0\n\t∂e_∂u: 0\n\t∂xr_∂xl: 0\nGradient-Evaluations:\n\t∂ẋ_∂t: 0\n\t∂y_∂t: 0\n\t∂e_∂t: 0\nCallback-Evaluations:\n\tCondition (event-indicators): 0\n\tTime-Choice (event-instances): 0\n\tAffect (event-handling): 0\n\tSave values: 0\n\tSteps completed: 0\nValues [2]:\n\t0.0\t(43.89793421294513, 1.0, 53.0)\n\t1.0\t(43.89793421294513, 1.0, 53.0)\nEvents [0]:","category":"page"},{"location":"examples/parameterize/#Second-variant","page":"Parameterize","title":"Second variant","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To show the second variant, it is necessary to terminate and reset the FMU instance. Then, as before, the setup command must be called for the FMU. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmi2Terminate(c)\nfmi2Reset(c)\nfmi2SetupExperiment(c, tStart, tStop)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To make sure that the functions work it is necessary to generate random numbers again. As shown already, we call the defined function generateRandomNumbers() and output the values.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"rndReal, rndBoolean, rndInteger, rndString = generateRandomNumbers()","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"(28.585492671149403, false, 2, \"Random number 37.00525465641722!\")","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the second variant, the value for each data type is set separately by the corresponding command. By this variant one has the maximum control and can be sure that also the correct data type is set. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmi2SetReal(c, \"p_real\", rndReal)\nfmi2SetBoolean(c, \"p_boolean\", rndBoolean)\nfmi2SetInteger(c, \"p_integer\", rndInteger)\nfmi2SetString(c, \"p_string\", rndString)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To illustrate the functionality of the parameterization with the separate functions, the corresponding get function can be also called separately for each data type:","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmi2SetReal() &#8660; fmi2GetReal()\nfmi2SetBoolean() &#8660; fmi2GetBoolean()\nfmi2SetInteger() &#8660; fmi2GetInteger()\nfmi2SetString() &#8660; fmi2GetString().","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"As before, the FMU must be in initialization mode.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmi2EnterInitializationMode(c)\n# fmi2GetReal(c, \"u_real\")\n# fmi2GetBoolean(c, \"u_boolean\")\n# fmi2GetInteger(c, \"u_integer\")\n# fmi2GetString(c, \"p_string\")\nfmi2ExitInitializationMode(c)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"From here on, you may want to simulate the FMU. Please note, that with the default executionConfig, it is necessary to prevent a new instantiation using the keyword instantiate=false. Otherwise, a new instance is allocated for the simulation-call and the parameters set for the previous instance are not transfered.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"simData = simulate(c, (tStart, tStop); recordValues=params[1:3], saveat=tSave, \n                        instantiate=false, setup=false)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Model name:\n\tIO\nSuccess:\n\ttrue\nf(x)-Evaluations:\n\tIn-place: 0\n\tOut-of-place: 0\nJacobian-Evaluations:\n\t∂ẋ_∂p: 0\n\t∂ẋ_∂x: 0\n\t∂ẋ_∂u: 0\n\t∂y_∂p: 0\n\t∂y_∂x: 0\n\t∂y_∂u: 0\n\t∂e_∂p: 0\n\t∂e_∂x: 0\n\t∂e_∂u: 0\n\t∂xr_∂xl: 0\nGradient-Evaluations:\n\t∂ẋ_∂t: 0\n\t∂y_∂t: 0\n\t∂e_∂t: 0\nCallback-Evaluations:\n\tCondition (event-indicators): 0\n\tTime-Choice (event-instances): 0\n\tAffect (event-handling): 0\n\tSave values: 0\n\tSteps completed: 0\nValues [2]:\n\t0.0\t(28.585492671149403, 0.0, 2.0)\n\t1.0\t(28.585492671149403, 0.0, 2.0)\nEvents [0]:","category":"page"},{"location":"examples/parameterize/#Unload-FMU","page":"Parameterize","title":"Unload FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The FMU will be unloaded and all unpacked data on disc will be removed.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"unloadFMU(fmu)","category":"page"},{"location":"examples/parameterize/#Summary","page":"Parameterize","title":"Summary","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Based on this tutorial it can be seen that there are two different variants to set and get parameters.These examples should make it clear to the user how parameters can also be set with different data types. As a small reminder, the sequence of commands for the manual parameterization of an FMU is summarized again. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"loadFMU() &#8594; fmiInstantiate!() &#8594; fmiSetupExperiment() &#8594; fmiSetXXX() &#8594; fmiEnterInitializationMode() &#8594; fmiGetXXX() &#8594; fmiExitInitializationMode() &#8594; simualte() &#8594; unloadFMU()","category":"page"}]
}
