var documenterSearchIndex = {"docs":
[{"location":"examples/multiprocessing/#Multiprocessing","page":"Multiprocessing","title":"Multiprocessing","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Tutorial by Jonas Wilfert, Tobias Thummerer","category":"page"},{"location":"examples/multiprocessing/#License","page":"Multiprocessing","title":"License","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar, Jonas Wilfert","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Licensed under the MIT license. See LICENSE file in the project root for details.","category":"page"},{"location":"examples/multiprocessing/#Motivation","page":"Multiprocessing","title":"Motivation","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/multiprocessing/#Introduction-to-the-example","page":"Multiprocessing","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"This example shows how to parallelize the computation of an FMU in FMI.jl. We can compute a batch of FMU-evaluations in parallel with different initial settings. Parallelization can be achieved using multithreading or using multiprocessing. This example shows multiprocessing, check multithreading.ipynb for multithreading. Advantage of multithreading is a lower communication overhead as well as lower RAM usage. However in some cases multiprocessing can be faster as the garbage collector is not shared.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"The model used is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"(Image: svg)  ","category":"page"},{"location":"examples/multiprocessing/#Target-group","page":"Multiprocessing","title":"Target group","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/multiprocessing/#Other-formats","page":"Multiprocessing","title":"Other formats","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/multiprocessing/#Getting-started","page":"Multiprocessing","title":"Getting started","text":"","category":"section"},{"location":"examples/multiprocessing/#Installation-prerequisites","page":"Multiprocessing","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install FMICore via add FMICore add \" https://github.com/ThummeTo/FMICore.jl \"\n5. Install BenchmarkTools via add BenchmarkTools ","category":"page"},{"location":"examples/multiprocessing/#Code-section","page":"Multiprocessing","title":"Code section","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Adding your desired amount of processes:","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"using Distributed\nn_procs = 4\naddprocs(n_procs; exeflags=`--project=$(Base.active_project()) --threads=auto`, restrict=false)","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"4-element Vector{Int64}:\n 2\n 3\n 4\n 5","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"# imports\n@everywhere using FMI\n@everywhere using FMIZoo\n@everywhere using BenchmarkTools","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Checking that we workers have been correctly initialized:","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"workers()\n\n@everywhere println(\"Hello World!\")\n\n# The following lines can be uncommented for more advanced informations about the subprocesses\n# @everywhere println(pwd())\n# @everywhere println(Base.active_project())\n# @everywhere println(gethostname())\n# @everywhere println(VERSION)\n# @everywhere println(Threads.nthreads())","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Hello World!\n      From worker 2:\tHello World!\n      From worker 4:\tHello World!\n      From worker 5:\tHello World!\n      From worker 3:\tHello World!","category":"page"},{"location":"examples/multiprocessing/#Simulation-setup","page":"Multiprocessing","title":"Simulation setup","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Next, the batch size and input values are defined.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"\n# Best if batchSize is a multiple of the threads/cores\nbatchSize = 16\n\n# Define an array of arrays randomly\ninput_values = collect(collect.(eachrow(rand(batchSize,2))))","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"16-element Vector{Vector{Float64}}:\n [0.8248221553629911, 0.8973168693926794]\n [0.8188814281273673, 0.43251439689134874]\n [0.7600392065690778, 0.8760647861576818]\n [0.33296226965519726, 0.6443864972863804]\n [0.9882861181846148, 0.04241263029769615]\n [0.6938311352249202, 0.8504821470514445]\n [0.9864083398779135, 0.4731735206674379]\n [0.7464700886539646, 0.03580939203675659]\n [0.6727978952451528, 0.41608393378760744]\n [0.36757431326443846, 0.33394303951645465]\n [0.04778453373860225, 0.8668782219757214]\n [0.7616698905725201, 0.6791827559784376]\n [0.1850878758742751, 0.3526283115198203]\n [0.020215449536198582, 0.25158514588605874]\n [0.43974258196626415, 0.8429912777587971]\n [0.8615485605165623, 0.3538985124487024]","category":"page"},{"location":"examples/multiprocessing/#Shared-Module","page":"Multiprocessing","title":"Shared Module","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"For Distributed we need to embed the FMU into its own module. This prevents Distributed from trying to serialize and send the FMU over the network, as this can cause issues. This module needs to be made available on all processes using @everywhere.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@everywhere module SharedModule\n    using FMIZoo\n    using FMI\n\n    t_start = 0.0\n    t_step = 0.1\n    t_stop = 10.0\n    tspan = (t_start, t_stop)\n    tData = collect(t_start:t_step:t_stop)\n\n    model_fmu = FMIZoo.fmiLoad(\"SpringPendulum1D\", \"Dymola\", \"2022x\")\nend","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"┌ Info: fmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_HmIjYZ/SpringPendulum1D`.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:76\n┌ Info: fmi2Load(...): FMU resources location is `file:////tmp/fmijl_HmIjYZ/SpringPendulum1D/resources`\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:192\n┌ Info: fmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:195\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mfmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_0rXxod/SpringPendulum1D`.\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mfmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_bCPKd9/SpringPendulum1D`.\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mfmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_PlEQLW/SpringPendulum1D`.\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mfmi2Load(...): FMU resources location is `file:////tmp/fmijl_bCPKd9/SpringPendulum1D/resources`\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mfmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mfmi2Load(...): FMU resources location is `file:////tmp/fmijl_0rXxod/SpringPendulum1D/resources`\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mfmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mfmi2Load(...): FMU resources location is `file:////tmp/fmijl_PlEQLW/SpringPendulum1D/resources`\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mfmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mfmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_Fa5323/SpringPendulum1D`.\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mfmi2Load(...): FMU resources location is `file:////tmp/fmijl_Fa5323/SpringPendulum1D/resources`\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mfmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"We define a helper function to calculate the FMU and combine it into an Matrix.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@everywhere function runCalcFormatted(fmu, x0, recordValues=[\"mass.s\", \"mass.v\"])\n    data = fmiSimulateME(fmu, SharedModule.t_start, SharedModule.t_stop; recordValues=recordValues, saveat=SharedModule.tData, x0=x0, showProgress=false, dtmax=1e-4)\n    return reduce(hcat, data.states.u)\nend","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Running a single evaluation is pretty quick, therefore the speed can be better tested with BenchmarkTools.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@benchmark data = runCalcFormatted(SharedModule.model_fmu, rand(2))","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"BenchmarkTools.Trial: 8 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m672.731 ms\u001b[22m\u001b[39m … \u001b[35m690.989 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m2.77% … 2.87%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m677.837 ms               \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m3.68%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m680.019 ms\u001b[22m\u001b[39m ± \u001b[32m  5.961 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m3.62% ± 0.69%\n\n  \u001b[39m▁\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m▁\u001b[34m▁\u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m▁\u001b[39m \u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m▁\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m▁\u001b[39m \u001b[39m \n  \u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m█\u001b[34m█\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[32m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m \u001b[39m▁\n  673 ms\u001b[90m           Histogram: frequency by time\u001b[39m          691 ms \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m155.95 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m3602373\u001b[39m.","category":"page"},{"location":"examples/multiprocessing/#Single-Threaded-Batch-Execution","page":"Multiprocessing","title":"Single Threaded Batch Execution","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"To compute a batch we can collect multiple evaluations. In a single threaded context we can use the same FMU for every call.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"println(\"Single Threaded\")\n@benchmark collect(runCalcFormatted(SharedModule.model_fmu, i) for i in input_values)","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Single Threaded\n\n\n\n\n\nBenchmarkTools.Trial: 1 sample with 1 evaluation.\n Single result which took \u001b[34m10.938 s\u001b[39m (3.80% GC) to evaluate,\n with a memory estimate of \u001b[33m2.44 GiB\u001b[39m, over \u001b[33m57637956\u001b[39m allocations.","category":"page"},{"location":"examples/multiprocessing/#Multithreaded-Batch-Execution","page":"Multiprocessing","title":"Multithreaded Batch Execution","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"In a multithreaded context we have to provide each thread it's own fmu, as they are not thread safe. To spread the execution of a function to multiple processes, the function pmap can be used.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"println(\"Multi Threaded\")\n@benchmark pmap(i -> runCalcFormatted(SharedModule.model_fmu, i), input_values)","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Multi Threaded\n\n\n\n\n\nBenchmarkTools.Trial: 1 sample with 1 evaluation.\n Single result which took \u001b[34m6.653 s\u001b[39m (0.00% GC) to evaluate,\n with a memory estimate of \u001b[33m84.48 KiB\u001b[39m, over \u001b[33m1301\u001b[39m allocations.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"As you can see, there is a significant speed-up in the median execution time. But: The speed-up is often much smaller than n_procs (or the number of physical cores of your CPU), this has different reasons. For a rule of thumb, the speed-up should be around n/2 on a n-core-processor with n Julia processes.","category":"page"},{"location":"examples/multiprocessing/#Unload-FMU","page":"Multiprocessing","title":"Unload FMU","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"After calculating the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@everywhere fmiUnload(SharedModule.model_fmu)","category":"page"},{"location":"examples/multiprocessing/#Summary","page":"Multiprocessing","title":"Summary","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"In this tutorial it is shown how multi processing with Distributed.jl can be used to improve the performance for calculating a Batch of FMUs.","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"Depth = 2","category":"page"},{"location":"examples/manipulation/#Manipulate-a-function","page":"Manipulate a function","title":"Manipulate a function","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/manipulation/#License","page":"Manipulate a function","title":"License","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"Licensed under the MIT license. See LICENSE file in the project root for details.","category":"page"},{"location":"examples/manipulation/#Motivation","page":"Manipulate a function","title":"Motivation","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/manipulation/#Introduction-to-the-example","page":"Manipulate a function","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"This example shows how to overwrite a library function with an own function. For this the FMU model is simulated first without changes. Then the function fmi2GetReal() is overwritten and simulated again. Both simulations are displayed in a graph to show the change caused by overwriting the function. The model used is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"(Image: svg)  ","category":"page"},{"location":"examples/manipulation/#Target-group","page":"Manipulate a function","title":"Target group","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/manipulation/#Other-formats","page":"Manipulate a function","title":"Other formats","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/manipulation/#Getting-started","page":"Manipulate a function","title":"Getting started","text":"","category":"section"},{"location":"examples/manipulation/#Installation-prerequisites","page":"Manipulate a function","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install FMICore via add FMICore add \" https://github.com/ThummeTo/FMICore.jl \"\n5. Install Plots via add Plots ","category":"page"},{"location":"examples/manipulation/#Code-section","page":"Manipulate a function","title":"Code section","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"# imports\nusing FMI\nusing FMIZoo\nusing FMICore\nusing Plots","category":"page"},{"location":"examples/manipulation/#Simulation-setup","page":"Manipulate a function","title":"Simulation setup","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"Next, the start time and end time of the simulation are set.","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"tStart = 0.0\ntStop = 8.0","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"8.0","category":"page"},{"location":"examples/manipulation/#Import-FMU","page":"Manipulate a function","title":"Import FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\")\n\nmyFMU = fmiLoad(pathToFMU)\n\nfmiInfo(myFMU)","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"┌ Info: fmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_xIGKTW/SpringFrictionPendulum1D`.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:76\n┌ Info: fmi2Load(...): FMU resources location is `file:////tmp/fmijl_xIGKTW/SpringFrictionPendulum1D/resources`\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:192\n┌ Info: fmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:195\n\n\n#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringFrictionPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{2e178ad3-5e9b-48ec-a7b2-baa5669efc0c}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:12Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t24\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\tStates:\t\t\t\t2\n\t\t33554432 [\"mass.s\"]\n\t\t33554433 [\"mass.v\", \"mass.v_relfric\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/manipulation/#Simulate-FMU","page":"Manipulate a function","title":"Simulate FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"In the next steps the recorded value is defined. The recorded value is the position of the mass. In the function fmiSimulateME() the FMU is simulated in model-exchange mode (ME) with an adaptive step size. In addition, the start and end time and the recorded variables are specified.","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"vrs = [\"mass.s\"]\n\nsimData = fmiSimulateME(myFMU, tStart, tStop; recordValues=vrs)","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"\u001b[34mSimulating ME-FMU ... 100%|██████████████████████████████| Time: 0:00:15\u001b[39m\n\n\n\n\n\nModel name:\n\tSpringFrictionPendulum1D\nSuccess:\n\ttrue\nStates [110]:\n\t0.0\t[0.5, 0.0]\n\t2.3529411764719727e-11\t[0.5, 1.0e-10]\n\t1.0000023529411766e-5\t[0.5000000002125017, 4.250030186348503e-5]\n\t0.00011000002352941177\t[0.5000000257134062, 0.0004675245102952289]\n\t0.0011100000235294118\t[0.5000026191281834, 0.004719970360497647]\n\t0.011110000023529413\t[0.5002631686645611, 0.047449647283752144]\n\t0.03982466736770743\t[0.5034050123596227, 0.17168075110950387]\n\t0.09972054285078226\t[0.5215006197560228, 0.43204954153497455]\n\t0.16481836271111422\t[0.5585747156842935, 0.703758265932321]\n\t...\n\t8.0\t[1.0668213438183276, -1.0000099359121942e-10]\nValues [110]:\n\t0.0\t(0.5,)\n\t2.3529411764719727e-11\t(0.5,)\n\t1.0000023529411766e-5\t(0.5000000002125017,)\n\t0.00011000002352941177\t(0.5000000257134062,)\n\t0.0011100000235294118\t(0.5000026191281834,)\n\t0.011110000023529413\t(0.5002631686645611,)\n\t0.03982466736770743\t(0.5034050123596227,)\n\t0.09972054285078226\t(0.5215006197560228,)\n\t0.16481836271111422\t(0.5585747156842935,)\n\t...\n\t8.0\t(1.0668213438183276,)\nEvents [6]:\n\tState-Event #11 @ 0.0s\n\tState-Event #11 @ 0.9939s\n\tState-Event #19 @ 1.9881s\n\tState-Event #11 @ 2.9829s\n\tState-Event #19 @ 3.9787s\n\tState-Event #11 @ 4.9768s","category":"page"},{"location":"examples/manipulation/#Plotting-FMU","page":"Manipulate a function","title":"Plotting FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"After the simulation is finished, the result of the FMU for the model-exchange mode can be plotted. In the plot for the FMU it can be seen that the oscillation continues to decrease due to the effect of the friction. If you simulate long enough, the oscillation comes to a standstill in a certain time.","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"fig = fmiPlot(simData, states=false)","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"(Image: svg)","category":"page"},{"location":"examples/manipulation/#Override-Function","page":"Manipulate a function","title":"Override Function","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"After overwriting a function, the previous one is no longer accessible. The original function fmi2GetReal() is cached by storing the address of the pointer. The addresses of the pointers are kept in the FMU and are thus accessible.","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"# save, where the original `fmi2GetReal` function was stored, so we can access it in our new function\noriginalGetReal = myFMU.cGetReal","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"Ptr{Nothing} @0x00007faafdc3cfaf","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"To overwrite the function fmi2GetReal!(), the function header of the new custom function must be identical to the previous one. The function header looks like fmi2GetReal!(cfunc::Ptr{Nothing}, c::fmi2Component, vr::Union{Array{fmi2ValueReference}, Ptr{fmi2ValueReference}}, nvr::Csize_t, value::Union{Array{fmi2Real}, Ptr{fmi2Real}})::fmi2Status. The information how the FMI2 function are structured can be seen from FMICore.jl or the FMI2.0.3-specification.","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"In the new implementation the original function is called by the previously stored pointer. Next there is a special handling if value is a pointer to an array. In this case the pointer is treated as an array, so that the entries are accessible. Otherwise, each value in value is multiplied by two. Finally, the original state of the original function is output.","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"function myGetReal!(c::fmi2Component, vr::Union{Array{fmi2ValueReference}, Ptr{fmi2ValueReference}}, \n                    nvr::Csize_t, value::Union{Array{fmi2Real}, Ptr{fmi2Real}})\n    # first, we do what the original function does\n    status = fmi2GetReal!(originalGetReal, c, vr, nvr, value)\n\n    # if we have a pointer to an array, we must interprete it as array to access elements\n    if isa(value, Ptr{fmi2Real})\n        value = unsafe_wrap(Array{fmi2Real}, value, nvr, own=false)\n    end\n\n    # now, we multiply every value by two (just for fun!)\n    for i in 1:nvr \n        value[i] *= 2.0 \n    end \n\n    # return the original status\n    return status\nend","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"myGetReal! (generic function with 1 method)","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"In the next command the original function is overwritten with the new defined function, for which the command fmiSetFctGetReal() is called.","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"# no we overwrite the original function\nfmiSetFctGetReal(myFMU, myGetReal!)","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"Ptr{Nothing} @0x00007fab4e89ffc0","category":"page"},{"location":"examples/manipulation/#Simulate-and-Plot-FMU-with-modified-function","page":"Manipulate a function","title":"Simulate and Plot FMU with modified function","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"As before, the identical command is called here for simulation. This is also a model exchange simulation. Immediately afterwards, the results are added to the previous graph as a dashed line.","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"simData = fmiSimulateME(myFMU, tStart, tStop; recordValues=vrs)\nfmiPlot!(fig, simData; states=false, style=:dash)","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"(Image: svg)","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"As expected by overwriting the function, all values are doubled.","category":"page"},{"location":"examples/manipulation/#Unload-FMU","page":"Manipulate a function","title":"Unload FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"fmiUnload(myFMU)","category":"page"},{"location":"examples/manipulation/#Summary","page":"Manipulate a function","title":"Summary","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulate a function","title":"Manipulate a function","text":"In this tutorial it is shown how an existing function of the library can be replaced by an own implementation. Through this possibility, there are almost no limits for the user, whereby the user can customize the function to his liking.","category":"page"},{"location":"features/#Features","page":"Features","title":"Features","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Please note, that this guide focuses also on users, that are not familiar with FMI. The following feature explanations are written in an easy-to-read-fashion, so there might be some points that are scientifically only 95% correct. For further information on FMI and FMUs, see fmi-standard.org.","category":"page"},{"location":"features/#Execution-Configuration","page":"Features","title":"Execution Configuration","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Not all FMUs support all features they should according to the FMI-standard, so FMI.jl provides a so called execution configuration.  This configuration is also respected by FMIFlux.jl. The content of the execution configuration may change in future (together with new or deprecated features of linked libraries), but the most important core features will be kept over time. Because not all users need the full potential of this configuration tool, there are three presets given: ","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"myFMU.executionConfig = FMU2_EXECUTION_CONFIGURATION_NO_RESET is the default operation mode for FMUs. FMUs are not reset via fmi2Reset, but new instantiated for every simulation run (or training step). This is not the most efficient way, but many FMUs have problems with resetting.\nmyFMU.executionConfig = FMU2_EXECUTION_CONFIGURATION_RESET is faster for well-implemented FMUs, but needs a fully working fmi2Reset-function. So if you know you have a fully working fmi2Reset, you may be faster with that option.\nmyFMU.executionConfig = FMU2_EXECUTION_CONFIGURATION_NO_FREEING should only be the very last choice. If your FMU neither supports fmi2Reset nor a proper fmi2FreeInstance, you could use this configuration as a last way out. Keep in mind, that new FMU instances are allocated but not freed, as long as your Julia instance is running (memory leak). In general, the amount of leaked memory is small, but you need to know what you are doing, if you do thousands or ten-thousands of simulation runs with such a FMU.","category":"page"},{"location":"features/#Debugging-/-Logging","page":"Features","title":"Debugging / Logging","text":"","category":"section"},{"location":"features/#Logging-FMI-calls","page":"Features","title":"Logging FMI-calls","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"To log all FMI-calls that happen (including \"hidden\" calls e.g. if you are using fmiSimulate) you can enable debugging for FMICore.jl using ENV[\"JULIA_DEBUG\"] = \"FMICore\". This will log any fmi2xxx-call, including the given parameters and return value.","category":"page"},{"location":"features/#Printing-internal-FMU-messages","page":"Features","title":"Printing internal FMU messages","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Many FMUs support for printing debugging messages. To force message printing, you can use the keyword logginOn=true either ...","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"in the call fmiInstantiate, for example fmiInstantiate(myFMU; loggingOn=true) or\nas part of the executionConfig, for example myFMU.executionConfig.loggingOn=true","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"You can further control which message types - like OK, Warning, Discard, Error, Fatal, Pending - should be logged by using the keywords logStatus{TYPE}=true as part of fmiInstantiate or (soon) the execution configuration. By default, all are activated. If the FMU uses a variadic callback function for messages (this is not supported by Julia at this time), you may need to activate external callbacks with the keyword externalCallbacks=true either ...","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"in the call fmiInstantiate!, for example fmiInstantiate!(myFMU; loggingOn=true, externalCallbacks=true) or\nas part of the executionConfig, for example myFMU.executionConfig.loggingOn=true; myFMU.executionConfig.externalCallbacks=true","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Note, that external callbacks are currently only supported on Windows.","category":"page"},{"location":"features/#Model-variable-identification","page":"Features","title":"Model variable identification","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"FMI.jl offers multiple ways to retrieve your model variables. Any function that accepts a variable identifier can handle the following argument types:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"UInt32 or fmi2ValueReference for example 1610612742 or 0x16000001: This is the most performant way of passing a variable identifier, but you need to know the value reference (you can determine them by having a look in the modelDescription.xml).\nArray{UInt32} or Array{fmi2ValueReference} for example [1610612742, 1610612743] or [0x16000001, 0x16000002]: This is the most performant way of passing multiple variable identifiers, but you need to know the value references.\nString for example \"ball.s\": This is the most intuitive way, because you might already know the variable name from your modelling environment or model documentation.\nArray{String} for example [\"ball.s\", \"der(ball.s)\"]: This is the most intuitive way for multiple variable identifiers, because you might already know the variable names from your modelling environment or model documentation.\nSymbol for example :states: There are multiple symbol-wildcards for interesting variable groups like :all, :none, :states, :derivatives, :inputs and :outputs.\nnothing: If you don't want to record anything (same as :none)","category":"page"},{"location":"features/#Event-handling","page":"Features","title":"Event handling","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"In FMI2, there are basically two types of events: state and time.  State events are triggered, as soon as one or more event indicators - scalar values that describe the \"distance\" in state space to the next state event - crossing zero.  Time events are triggered at known time points during the simulation.  If your model has state and/or time events is detected automatically by FMI.jl and the event handling happens automatically in the background.","category":"page"},{"location":"features/#Model-exchange-(ME)-and-co-simulation-(CS)","page":"Features","title":"Model exchange (ME) and co-simulation (CS)","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"There are two different model types for FMUs in FMI2: Model exchange (ME) and co-simulation (CS).  If you have a FMU and are only interested in getting it simulated, use fmiSimulate so FMI.jl will automatically pick CS if available and otherwise ME. If you want to force a specific simulation mode, you can use fmiSimulateME (for ME) or fmiSimulateCS (for CS).","category":"page"},{"location":"features/#Simulate-arbitrary-time-intervals","page":"Features","title":"Simulate arbitrary time intervals","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"You can simply simulate arbitrary time intervals by passing a startTime unequal zero to fmi2SetupExperiment.  Because many FMUs don't support startTime != 0.0 and will throw an error or warning, a time shifting feature inside FMI.jl performs all necessary steps in the background - all corresponding commands like e.g. fmi2SetTime or fmi2NewDiscreteStates act like the desired time interval is simulated. If you don't want this feature (maybe because you are simulating time-dependent systems), you may use the execution configuration myFMU.executionConfig.autoTimeShift=false while providing a startTime != 0.0.","category":"page"},{"location":"features/#Performance","page":"Features","title":"Performance","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"In- and Out-of-Place: Many commands in FMI.jl are available in in-place and out-of-place semantics. Of course, in-place-calls are faster, because they don't need to allocate new memory at every call (for the return values). So if you have an eye on performance (or must have), a good starting point is to substitute out-of-place- with in-place-calls. Typical improvements are:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"valueArray = fmi2GetReal(args...) -> fmi2GetReal!(args..., valueArray)\nvalueArray = fmi2GetDerivatives(args...) -> fmi2GetDerivatives!(args..., valueArray)\nvalueArray = fmi2NewDiscreteStates(args...) -> fmi2NewDiscreteStates!(args..., valueArray)","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Of course, you have to use the same piece of memory (to write your return values in) for multiple calls - otherwise there will be no improvement because the number of allocations stays the same.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Views: You can use array-views instead of array-slices as input for in-place-functions, which further reduces memory allocations.","category":"page"},{"location":"features/#Watch-your-progress","page":"Features","title":"Watch your progress","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"When simulating FMUs with FMI.jl, a progress meter is shown per default. You can control the appearance via the keyword argument showProgress for fmiSimulate, fmiSimulateME and fmiSimulateCS.  Progress meters are also available for FMIFlux.jl, but deactivated by default (during training, this can be a bit too much). When evaluating a NeuralFMU, you can use the same keyword with showProgress=true to show a progress bar during training, too. The simulation trajectory (also called the solution of your FMU's ODE system) can be plotted using fmiPlot(myFMU, solution), all axis will be labeled automatically.","category":"page"},{"location":"features/#Parallelization","page":"Features","title":"Parallelization","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"A native integrated support for multi-threaded and multi-process FMU-simulation will be deployed soon. ","category":"page"},{"location":"related/#Related-Publications","page":"Related Publication","title":"Related Publications","text":"","category":"section"},{"location":"related/","page":"Related Publication","title":"Related Publication","text":"Tobias Thummerer, Josef Kircher, Lars Mikelsons 2021 NeuralFMU: Towards Structural Integration of FMUs into Neural Networks (14th Modelica Conference, Preprint, Accepted) arXiv:2109.04351","category":"page"},{"location":"related/","page":"Related Publication","title":"Related Publication","text":"Tobias Thummerer, Johannes Tintenherr, Lars Mikelsons 2021 Hybrid modeling of the human cardiovascular system using NeuralFMUs (10th International Conference on Mathematical Modeling in Physical Sciences, Preprint, Accepted) arXiv:2109.04880","category":"page"},{"location":"examples/multiple_instances/#Multiple-Instances-of-an-FMU","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/multiple_instances/#License","page":"Multiple Instances of an FMU","title":"License","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"Licensed under the MIT license. See LICENSE file in the project root for details.","category":"page"},{"location":"examples/multiple_instances/#Motivation","page":"Multiple Instances of an FMU","title":"Motivation","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/multiple_instances/#Introduction-to-the-example","page":"Multiple Instances of an FMU","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"In this example we want to show that it is possible to create different instances of an FMU. The different instances can then be used to run independent simulations. After the FMU has been simulated, the simulation results are displayed in a graph. The used model is a one-dimensional spring pendulum without friction. The object-orientated structure of the SpringPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"(Image: svg)  ","category":"page"},{"location":"examples/multiple_instances/#Target-group","page":"Multiple Instances of an FMU","title":"Target group","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/multiple_instances/#Other-formats","page":"Multiple Instances of an FMU","title":"Other formats","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/multiple_instances/#Getting-started","page":"Multiple Instances of an FMU","title":"Getting started","text":"","category":"section"},{"location":"examples/multiple_instances/#Installation-prerequisites","page":"Multiple Instances of an FMU","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install Plots via add Plots ","category":"page"},{"location":"examples/multiple_instances/#Code-section","page":"Multiple Instances of an FMU","title":"Code section","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots","category":"page"},{"location":"examples/multiple_instances/#Simulation-setup","page":"Multiple Instances of an FMU","title":"Simulation setup","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"Next, the start time and end time of the simulation are set. Finally, the recorded values are specified to store the results of the simulation.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"tStart = 0.0\ntStop = 8.0\n\nvrs = [\"mass.s\"]","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"1-element Vector{String}:\n \"mass.s\"","category":"page"},{"location":"examples/multiple_instances/#Import-FMU","page":"Multiple Instances of an FMU","title":"Import FMU","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"SpringPendulum1D\", \"Dymola\", \"2022x\")\n\nmyFMU = fmiLoad(pathToFMU)\nfmiInfo(myFMU)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"┌ Info: fmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_ZhifPG/SpringPendulum1D`.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:76\n┌ Info: fmi2Load(...): FMU resources location is `file:////tmp/fmijl_ZhifPG/SpringPendulum1D/resources`\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:192\n┌ Info: fmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:195\n\n\n#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{fc15d8c4-758b-48e6-b00e-5bf47b8b14e5}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:23Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t0\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\tStates:\t\t\t\t2\n\t\t33554432 [\"mass.s\"]\n\t\t33554433 [\"mass.v\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/multiple_instances/#First-Instance","page":"Multiple Instances of an FMU","title":"First Instance","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"To create an instance of the FMU it is necessary to call the command fmiInstantiate!(). With the component address you now have a unique instance of the FMU.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"comp1 = fmiInstantiate!(myFMU; loggingOn=true)\ncomp1Address= comp1.compAddr\nprintln(comp1)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"FMU:            SpringPendulum1D\nInstanceName:   SpringPendulum1D\nAddress:        Ptr{Nothing} @0x0000000002850ae0\nState:          fmi2ComponentStateInstantiated\nLogging:        true\nFMU time:       -Inf\nFMU states:     nothing","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"Next, a dictionary for the parameters is created. With this dictionary you can set the initial states of the variables of the FMU. For the spring constant spring.c a value of 100 fracNm and for the position of the mass mass.s a value of 10 m is set. The created dictionary with the specified variables for recording are passed to the command for simulation. In addition, other keywords are set. On the one hand the keyword instantiate=false is set, which prevents that in the simulation command a new instance is created. On the other hand the keyword freeInstance=false is set, this prevents that after the simulation command the instance is released. ","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"param1 = Dict(\"spring.c\"=>10.0, \"mass_s0\"=>1.0)\ndata1 = fmiSimulate(comp1, tStart, tStop; parameters=param1, recordValues=vrs, instantiate=false, freeInstance=false)\nfig = fmiPlot(data1)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"(Image: svg)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"For control, you can compare again the address of the instance to the previous address, and it should be the same address. As soon as this is not the case an error would be thrown by the macro @assert.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"@assert comp1.compAddr === comp1Address","category":"page"},{"location":"examples/multiple_instances/#Second-Instance","page":"Multiple Instances of an FMU","title":"Second Instance","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"To create a second instance of the FMU it is necessary to call the command fmiInstantiate!(). With the component address you now have a unique instance of the FMU.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"comp2 = fmiInstantiate!(myFMU; loggingOn=true)\ncomp2Address= comp2.compAddr\nprintln(comp2)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"FMU:            SpringPendulum1D\nInstanceName:   SpringPendulum1D\nAddress:        Ptr{Nothing} @0x000000000480ca30\nState:          fmi2ComponentStateInstantiated\nLogging:        false\nFMU time:       -Inf\nFMU states:     nothing","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"The addresses of the instantiated FMUs must differ, and you can see that in the comparison below.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"@assert comp1Address !== comp2Address","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"Again, a dictionary for the parameters is created. With this dictionary you can set the initial states of the variables of the FMU. For the spring constant spring.c a value of 10 fracNm and for the position of the mass mass.s a value of 20 m is set. The created dictionary with the specified variables for recording are passed to the command for simulation. As before, the two keywords instantiate=false and freeInstance=false are set.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"param2 = Dict(\"spring.c\"=>1.0, \"mass.s\"=>2.0)\ndata2 = fmiSimulateCS(comp2, tStart, tStop;  parameters=param2, recordValues=vrs, instantiate=false, freeInstance=false)\nfmiPlot!(fig, data2)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"(Image: svg)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"For control, you can compare again the address of the instance comp2 to the previous address comp2Address and it should be the same address.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"@assert comp2.compAddr === comp2Address","category":"page"},{"location":"examples/multiple_instances/#Unload-FMU","page":"Multiple Instances of an FMU","title":"Unload FMU","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"fmiUnload(myFMU)","category":"page"},{"location":"examples/multiple_instances/#Summary","page":"Multiple Instances of an FMU","title":"Summary","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple Instances of an FMU","title":"Multiple Instances of an FMU","text":"Based on the example it can be seen that it is possible to create different instances of an FMU. The different instances can then be used to perform different simulations.","category":"page"},{"location":"examples/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"This section discusses the included examples of the FMI.jl library. So you can execute them on your machine and get detailed information about all the steps. If you require further information about the function calls, see library or fmu2 function sections.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"The examples are:","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Simulate: Showing how you can simulate a CS-FMU and a ME-FMU.\nParameterize: A short example explaining how to parameterize a FMU before simulation.\nMultiple instances: Showing the use of multiple instances.\nModelica conference 2021: Showing the different variants of simulating an FMU.\nManipulation: Showing how to redefine a library function.\nMultithreading: Shows how to use multithreading to simulate multiple FMUs.\nMultiprocessing: Shows how to use multiprocessing to simulate multiple FMUs.","category":"page"},{"location":"examples/multithreading/#Multithreading","page":"Multithreading","title":"Multithreading","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Tutorial by Jonas Wilfert, Tobias Thummerer","category":"page"},{"location":"examples/multithreading/#License","page":"Multithreading","title":"License","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar, Jonas Wilfert","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Licensed under the MIT license. See LICENSE file in the project root for details.","category":"page"},{"location":"examples/multithreading/#Motivation","page":"Multithreading","title":"Motivation","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/multithreading/#Introduction-to-the-example","page":"Multithreading","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"This example shows how to parallelize the computation of an FMU in FMI.jl. We can compute a batch of FMU-evaluations in parallel with different initial settings. Parallelization can be achieved using multithreading or using multiprocessing. This example shows multithreading, check multiprocessing.ipynb for multiprocessing. Advantage of multithreading is a lower communication overhead as well as lower RAM usage. However in some cases multiprocessing can be faster as the garbage collector is not shared.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"The model used is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"(Image: svg)  ","category":"page"},{"location":"examples/multithreading/#Target-group","page":"Multithreading","title":"Target group","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/multithreading/#Other-formats","page":"Multithreading","title":"Other formats","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/multithreading/#Getting-started","page":"Multithreading","title":"Getting started","text":"","category":"section"},{"location":"examples/multithreading/#Installation-prerequisites","page":"Multithreading","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install FMICore via add FMICore add \" https://github.com/ThummeTo/FMICore.jl \"\n5. Install Folds via add Folds \n6. Install BenchmarkTools via add BenchmarkTools ","category":"page"},{"location":"examples/multithreading/#Code-section","page":"Multithreading","title":"Code section","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"# imports\nusing FMI\nusing FMIZoo\nusing Folds\nusing BenchmarkTools","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"First, check the amount of available threads:","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Threads.nthreads()","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"1","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"If the number of available threads doesn't match your expections, you can increase the number of threads available to the Julia process like described here.","category":"page"},{"location":"examples/multithreading/#Simulation-setup","page":"Multithreading","title":"Simulation setup","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Next, the start time and end time of the simulation are set. Here we also decide the size of the batch.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"t_start = 0.0\nt_step = 0.1\nt_stop = 10.0\ntspan = (t_start, t_stop)\ntData = collect(t_start:t_step:t_stop)\n\n# Best if batchSize is a multiple of the threads/cores\nbatchSize = Threads.nthreads()\n\n# Define an array of arrays randomly\ninput_values = collect(collect.(eachrow(rand(batchSize,2))))\n","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"1-element Vector{Vector{Float64}}:\n [0.27784361269801616, 0.701262314292934]","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"We need to instantiate one FMU for each parallel execution, as they cannot be easily shared among different threads.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"# a single FMU to compare the performance\nrealFMU = fmiLoad(\"SpringPendulum1D\", \"Dymola\", \"2022x\")\n\n# the FMU batch\nrealFMUBatch = [fmiLoad(\"SpringPendulum1D\", \"Dymola\", \"2022x\") for _ in 1:batchSize]","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"┌ Info: fmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_woQ6Hq/SpringPendulum1D`.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:76\n┌ Info: fmi2Load(...): FMU resources location is `file:////tmp/fmijl_woQ6Hq/SpringPendulum1D/resources`\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:192\n┌ Info: fmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:195\n┌ Info: fmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_lmIxor/SpringPendulum1D`.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:76\n┌ Info: fmi2Load(...): FMU resources location is `file:////tmp/fmijl_lmIxor/SpringPendulum1D/resources`\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:192\n┌ Info: fmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:195\n\n\n\n\n\n1-element Vector{FMU2}:\n Model name:        SpringPendulum1D\nType:              1","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"We define a helper function to calculate the FMU solution and combine it into an Matrix.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"function runCalcFormatted(fmu::FMU2, x0::Vector{Float64}, recordValues::Vector{String}=[\"mass.s\", \"mass.v\"])\n    data = fmiSimulateME(fmu, t_start, t_stop; recordValues=recordValues, saveat=tData, x0=x0, showProgress=false, dtmax=1e-4)\n    return reduce(hcat, data.states.u)\nend","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"runCalcFormatted (generic function with 2 methods)","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Running a single evaluation is pretty quick, therefore the speed can be better tested with BenchmarkTools.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"@benchmark data = runCalcFormatted(realFMU, rand(2))","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"BenchmarkTools.Trial: 7 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m709.976 ms\u001b[22m\u001b[39m … \u001b[35m797.016 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m3.01% … 2.34%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m733.595 ms               \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m2.90%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m737.032 ms\u001b[22m\u001b[39m ± \u001b[32m 28.669 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m3.17% ± 0.83%\n\n  \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[34m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m█\u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \n  \u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[34m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m█\u001b[32m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m \u001b[39m▁\n  710 ms\u001b[90m           Histogram: frequency by time\u001b[39m          797 ms \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m155.95 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m3602373\u001b[39m.","category":"page"},{"location":"examples/multithreading/#Single-Threaded-Batch-Execution","page":"Multithreading","title":"Single Threaded Batch Execution","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"To compute a batch we can collect multiple evaluations. In a single threaded context we can use the same FMU for every call.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"println(\"Single Threaded\")\n@benchmark collect(runCalcFormatted(realFMU, i) for i in input_values)","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Single Threaded\n\n\n\n\n\nBenchmarkTools.Trial: 7 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m711.274 ms\u001b[22m\u001b[39m … \u001b[35m748.802 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m3.11% … 4.25%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m733.802 ms               \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m2.86%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m731.344 ms\u001b[22m\u001b[39m ± \u001b[32m 12.250 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m3.38% ± 0.86%\n\n  \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[34m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \n  \u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[34m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[32m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m \u001b[39m▁\n  711 ms\u001b[90m           Histogram: frequency by time\u001b[39m          749 ms \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m155.95 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m3602376\u001b[39m.","category":"page"},{"location":"examples/multithreading/#Multithreaded-Batch-Execution","page":"Multithreading","title":"Multithreaded Batch Execution","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"In a multithreaded context we have to provide each thread it's own fmu, as they are not thread safe. To spread the execution of a function to multiple threads, the library Folds can be used.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"println(\"Multi Threaded\")\n@benchmark Folds.collect(runCalcFormatted(fmu, i) for (fmu, i) in zip(realFMUBatch, input_values))","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Multi Threaded\n\n\n\n\n\nBenchmarkTools.Trial: 8 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m675.088 ms\u001b[22m\u001b[39m … \u001b[35m719.438 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m3.32% … 4.67%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m688.843 ms               \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m3.25%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m691.050 ms\u001b[22m\u001b[39m ± \u001b[32m 14.338 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m3.66% ± 0.75%\n\n  \u001b[39m█\u001b[39m \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[34m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[32m \u001b[39m\u001b[39m \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \n  \u001b[39m█\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[34m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[32m▁\u001b[39m\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m \u001b[39m▁\n  675 ms\u001b[90m           Histogram: frequency by time\u001b[39m          719 ms \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m155.95 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m3602380\u001b[39m.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"As you can see, there is a significant speed-up in the median execution time. But: The speed-up is often much smaller than Threads.nthreads(), this has different reasons. For a rule of thumb, the speed-up should be around n/2 on a n-core-processor with n threads for the Julia process.","category":"page"},{"location":"examples/multithreading/#Unload-FMU","page":"Multithreading","title":"Unload FMU","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"After calculating the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"fmiUnload(realFMU)\nfmiUnload.(realFMUBatch)","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"1-element Vector{Nothing}:\n nothing","category":"page"},{"location":"examples/multithreading/#Summary","page":"Multithreading","title":"Summary","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"In this tutorial it is shown how multi threading with Folds.jl can be used to improve the performance for calculating a Batch of FMUs.","category":"page"},{"location":"examples/simulate/#Simulate-an-FMU-in-different-modes","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/simulate/#License","page":"Simulate an FMU in different modes","title":"License","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"Licensed under the MIT license. See LICENSE file in the project root for details.","category":"page"},{"location":"examples/simulate/#Motivation","page":"Simulate an FMU in different modes","title":"Motivation","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/simulate/#Introduction-to-the-example","page":"Simulate an FMU in different modes","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"In this example we want to show how fast and easy the simulation for an FMU is. For this purpose, the FMU is simulated in co-simulation mode and in model-exchange mode. After the FMU has been simulated, the simulation results are displayed in a graph. The graphs of the different modes are compared with each other. The used model is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"(Image: svg)  ","category":"page"},{"location":"examples/simulate/#Target-group","page":"Simulate an FMU in different modes","title":"Target group","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/simulate/#Other-formats","page":"Simulate an FMU in different modes","title":"Other formats","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/simulate/#Getting-started","page":"Simulate an FMU in different modes","title":"Getting started","text":"","category":"section"},{"location":"examples/simulate/#Installation-prerequisites","page":"Simulate an FMU in different modes","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install Plots via add Plots ","category":"page"},{"location":"examples/simulate/#Code-section","page":"Simulate an FMU in different modes","title":"Code section","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots","category":"page"},{"location":"examples/simulate/#Simulation-setup","page":"Simulate an FMU in different modes","title":"Simulation setup","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"Next, the start time and end time of the simulation are set. Finally, a step size is specified to store the results of the simulation at these time steps.","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"tStart = 0.0\ntStep = 0.01\ntStop = 8.0\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"0.0:0.01:8.0","category":"page"},{"location":"examples/simulate/#Import-FMU","page":"Simulate an FMU in different modes","title":"Import FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\")\n\nmyFMU = fmiLoad(pathToFMU)\n# fmiLoad(\"path/to/myFMU.fmu\"; unpackPath = \"path/to/unpacked/fmu/\")\n\nfmiInfo(myFMU)","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"┌ Info: fmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_yDnsDJ/SpringFrictionPendulum1D`.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:76\n┌ Info: fmi2Load(...): FMU resources location is `file:////tmp/fmijl_yDnsDJ/SpringFrictionPendulum1D/resources`\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:192\n┌ Info: fmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:195\n\n\n#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringFrictionPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{2e178ad3-5e9b-48ec-a7b2-baa5669efc0c}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:12Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t24\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\tStates:\t\t\t\t2\n\t\t33554432 [\"mass.s\"]\n\t\t33554433 [\"mass.v\", \"mass.v_relfric\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/simulate/#Simulate-FMU","page":"Simulate an FMU in different modes","title":"Simulate FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"In the following, the FMU is simulated in the two different simulation modes.","category":"page"},{"location":"examples/simulate/#Simulate-as-Co-Simulation","page":"Simulate an FMU in different modes","title":"Simulate as Co-Simulation","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"In the next steps the recorded values are defined. The first state is the position of the mass and the second state is the velocity. In the function fmiSimulateCS() the FMU is simulated in co-simulation mode (CS) with an adaptive step size but with fixed save points tSave. In addition, the start and end time and the recorded variables are specified.","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"vrs = [\"mass.s\", \"mass.v\"]\n\ndataCS = fmiSimulateCS(myFMU, tStart, tStop; recordValues=vrs, saveat=tSave)","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"Model name:\n\tSpringFrictionPendulum1D\nSuccess:\n\ttrue\nValues [801]:\n\t0.0\t(0.5, 0.0)\n\t0.01\t(0.5002235448486548, 0.042692491939260585)\n\t0.02\t(0.5008715291319449, 0.08568000508550636)\n\t0.03\t(0.5019478597521578, 0.12892136998736314)\n\t0.04\t(0.5034570452098334, 0.17232325681284336)\n\t0.05\t(0.5053993458877354, 0.2158440857658765)\n\t0.06\t(0.5077764240578201, 0.259420181133082)\n\t0.07\t(0.5105886522837868, 0.30295578207463486)\n\t0.08\t(0.5138351439717114, 0.3464184707972189)\n\t...\n\t8.0\t(1.071367253976742, -1.000814138594347e-10)\nEvents [0]:","category":"page"},{"location":"examples/simulate/#Simulate-as-Model-Exchange","page":"Simulate an FMU in different modes","title":"Simulate as Model-Exchange","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"In the function fmiSimulateME() the FMU is simulated in model-exchange mode (ME) with an adaptive step size but with fixed save points tSave. In addition, the start and end time are specified. In contrast to the co-simulation, the values to be stored are not specified here, since the states and events of the FMU are always output as well. The identifiers given above just correspond to the states of the FMU.","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"dataME = fmiSimulateME(myFMU, tStart, tStop; saveat=tSave)","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"\u001b[34mSimulating ME-FMU ... 100%|██████████████████████████████| Time: 0:00:12\u001b[39m\n\n\n\n\n\nModel name:\n\tSpringFrictionPendulum1D\nSuccess:\n\ttrue\nStates [801]:\n\t0.0\t[0.5, 0.0]\n\t0.01\t[0.5002131418344649, 0.042689450666241]\n\t0.02\t[0.5008548874805565, 0.08570846215523381]\n\t0.03\t[0.5019281653120716, 0.12898389312495082]\n\t0.04\t[0.5034351805057593, 0.17244393475170294]\n\t0.05\t[0.5053774287967188, 0.2160182432854046]\n\t0.06\t[0.5077556967622916, 0.25963796675862466]\n\t0.07\t[0.5105701003205937, 0.3032358690888718]\n\t0.08\t[0.5138201049458624, 0.34674641820324037]\n\t...\n\t8.0\t[1.0668213438183276, -1.0000099359121942e-10]\nEvents [6]:\n\tState-Event #11 @ 0.0s\n\tState-Event #11 @ 0.9939s\n\tState-Event #19 @ 1.9881s\n\tState-Event #11 @ 2.9829s\n\tState-Event #19 @ 3.9787s\n\tState-Event #11 @ 4.9768s","category":"page"},{"location":"examples/simulate/#Plotting-FMU","page":"Simulate an FMU in different modes","title":"Plotting FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"After the simulation is finished the results of the FMU for the co-simulation and model-exchange mode can be plotted. In the plot for the FMU it can be seen that the oscillation continues to decrease due to the effect of the friction. If you simulate long enough, the oscillation comes to a standstill in a certain time.","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"fmiPlot(dataCS)","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"(Image: svg)","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"fmiPlot(dataME)","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"(Image: svg)","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"From both graphs it can be seen that the simulation calculates exactly the same results.","category":"page"},{"location":"examples/simulate/#Unload-FMU","page":"Simulate an FMU in different modes","title":"Unload FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"fmiUnload(myFMU)","category":"page"},{"location":"examples/simulate/#Summary","page":"Simulate an FMU in different modes","title":"Summary","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate an FMU in different modes","title":"Simulate an FMU in different modes","text":"Based on this tutorial it can be seen that simulating in the different mode is very easy, and it only takes a few commands to simulate the FMU. ","category":"page"},{"location":"examples/modelica_conference_2021/#Advanced-Simulation-of-an-FMU","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/modelica_conference_2021/#License","page":"Advanced Simulation of an FMU","title":"License","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"Licensed under the MIT license. See LICENSE file in the project root for details.","category":"page"},{"location":"examples/modelica_conference_2021/#Motivation","page":"Advanced Simulation of an FMU","title":"Motivation","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/modelica_conference_2021/#Introduction-to-the-example","page":"Advanced Simulation of an FMU","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"In this example we would like to show that besides the simple simulation of an FMU there is also a more advanced version of the simulation. The advantage of the more advanced variant is that there are more possibilities to intervene in the simulation to make changes. After the FMU has been simulated, the simulation results are displayed in a graph. The used model is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"(Image: svg)  ","category":"page"},{"location":"examples/modelica_conference_2021/#Target-group","page":"Advanced Simulation of an FMU","title":"Target group","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/modelica_conference_2021/#Other-formats","page":"Advanced Simulation of an FMU","title":"Other formats","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/modelica_conference_2021/#Getting-started","page":"Advanced Simulation of an FMU","title":"Getting started","text":"","category":"section"},{"location":"examples/modelica_conference_2021/#Installation-prerequisites","page":"Advanced Simulation of an FMU","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install Plots via add Plots ","category":"page"},{"location":"examples/modelica_conference_2021/#Code-section","page":"Advanced Simulation of an FMU","title":"Code section","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots","category":"page"},{"location":"examples/modelica_conference_2021/#Simulation-setup","page":"Advanced Simulation of an FMU","title":"Simulation setup","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"Next, the start time and end time of the simulation are set. Finally, a step size is specified to store the results of the simulation at these time steps.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"tStart = 0.0\ntStep = 0.1\ntStop = 8.0\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"0.0:0.1:8.0","category":"page"},{"location":"examples/modelica_conference_2021/#Simple-FMU-Simulation","page":"Advanced Simulation of an FMU","title":"Simple FMU Simulation","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\")\n\nmyFMU = fmiLoad(pathToFMU)\nfmiInfo(myFMU)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"┌ Info: fmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_24jWrX/SpringFrictionPendulum1D`.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:76\n┌ Info: fmi2Load(...): FMU resources location is `file:////tmp/fmijl_24jWrX/SpringFrictionPendulum1D/resources`\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:192\n┌ Info: fmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:195\n\n\n#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringFrictionPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{2e178ad3-5e9b-48ec-a7b2-baa5669efc0c}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:12Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t24\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\tStates:\t\t\t\t2\n\t\t33554432 [\"mass.s\"]\n\t\t33554433 [\"mass.v\", \"mass.v_relfric\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"In the next commands the FMU is simulated, for which the start and end time and recorded variables are declared. Afterwards the simulation result is shown in a graph. In the plot for the FMU, it can be seen that the oscillation keeps decreasing due to the effect of friction. If one simulates long enough, the oscillation comes to a standstill after a certain time.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"simData = fmiSimulate(myFMU, tStart, tStop; recordValues=[\"mass.s\"], saveat=tSave)\nfmiPlot(simData)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"(Image: svg)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"fmiUnload(myFMU)","category":"page"},{"location":"examples/modelica_conference_2021/#Advanced-FMU-Simulation","page":"Advanced Simulation of an FMU","title":"Advanced FMU Simulation","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"In the following type of simulation a more advanced variant is presented, which allows intervening more in the simulation process. Analogous to the simple variant, an FMU model must be loaded.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"myFMU = fmiLoad(pathToFMU);","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"┌ Info: fmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_uyXFBT/SpringFrictionPendulum1D`.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:76\n┌ Info: fmi2Load(...): FMU resources location is `file:////tmp/fmijl_uyXFBT/SpringFrictionPendulum1D/resources`\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:192\n┌ Info: fmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:195","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"Next, it is necessary to create an instance of the FMU, this is achieved by the command fmiInstantiate!().  ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"instanceFMU = fmiInstantiate!(myFMU)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"FMU:            SpringFrictionPendulum1D\nInstanceName:   SpringFrictionPendulum1D\nAddress:        Ptr{Nothing} @0x00000000065ee110\nState:          fmi2ComponentStateInstantiated\nLogging:        true\nFMU time:       -Inf\nFMU states:     nothing","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"In the following code block, start and end time for the simulation is set by the fmiSetupExperiment() command. Next, the FMU is initialized by the calls of fmiEnterInitializationMode() and fmiExitInitializationMode(). It would also be possible to set initial states for the FMU before these two commands. ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"fmiSetupExperiment(instanceFMU, tStart, tStop)\n# set initial model states\nfmiEnterInitializationMode(instanceFMU)\n# get initial model states\nfmiExitInitializationMode(instanceFMU)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"0x00000000","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"The actual simulation loop is shown in the following block. Here a simulation step fmiDoStep() with the fixed step size tStep is executed. As indicated in the code by the comments, the input values and output values of the FMU could be changed in the simulation loop as desired, whereby the higher possibility of adjustments arises.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"for t in tSave\n    # set model inputs \n    # ...\n    fmiDoStep(instanceFMU, tStep)\n    # get model outputs\n    # ...\nend","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"The instantiated FMU must be terminated and then the memory area for the instance can also be deallocated. The last step is to unload the FMU to remove all unpacked data on disc. ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"fmiTerminate(instanceFMU)\nfmiFreeInstance!(instanceFMU)\nfmiUnload(myFMU)","category":"page"},{"location":"examples/modelica_conference_2021/#Summary","page":"Advanced Simulation of an FMU","title":"Summary","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Advanced Simulation of an FMU","title":"Advanced Simulation of an FMU","text":"The tutorial has shown that besides the usual simple variant of simulating an FMU, there is another way to make more adjustments.","category":"page"},{"location":"library/fmu/#Version-independent-FMU-functions","page":"FMU version independent functions","title":"Version independent FMU functions","text":"","category":"section"},{"location":"library/fmu/#Parsing-variable-names-to-ValueReferences","page":"FMU version independent functions","title":"Parsing variable names to ValueReferences","text":"","category":"section"},{"location":"library/fmu/","page":"FMU version independent functions","title":"FMU version independent functions","text":"fmiStringToValueReference","category":"page"},{"location":"library/fmu/#FMI.fmiStringToValueReference","page":"FMU version independent functions","title":"FMI.fmiStringToValueReference","text":"fmiStringToValueReference(dataStruct::Union{FMU2, fmi2ModelDescription, FMU3, fmmi3ModelDescription}, identifier::Union{String, AbstractArray{String}})\n\nReturns the ValueReference coresponding to the variable identifier.\n\nArguments\n\ndataStruct::Union{FMU2, fmi2ModelDescription, FMU3, fmmi3ModelDescription}: Model of the type FMU2/FMU3 or the Model Description of fmi2/fmi3. Same for Model of type FMU3 or the Model Description of fmi3\nidentifier::Union{String, AbstractArray{String}}: Variable identifier in type String or as a 1-dimensional AbstractArray containing elements of type String\n\nSee also fmi2StringToValueReference, fmi3StringToValueReference.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#Opening-and-closing-FMUs","page":"FMU version independent functions","title":"Opening and closing FMUs","text":"","category":"section"},{"location":"library/fmu/","page":"FMU version independent functions","title":"FMU version independent functions","text":"fmiLoad\nfmiUnload","category":"page"},{"location":"library/fmu/#FMI.fmiLoad","page":"FMU version independent functions","title":"FMI.fmiLoad","text":"fmiLoad(pathToFMU::String; unpackPath=nothing, type=nothing)\n\nLoad FMUs independent of the FMI version, currently supporting version 2.0.X.\n\nArguments\n\npathToFMU::String: String that contains the paths of ziped and unziped FMU folders.\n\nKeywords\n\nunpackPath=nothing: Via optional argument unpackPath, a path to unpack the FMU can be specified (default: system temporary directory).\ntype::Union{CS, ME} = nothing:  Via type, a FMU type can be selected. If none of the unified type set is used, the default value type = nothing will be used.\n\nReturns\n\nReturns the instance of the FMU struct.\n\nSee also fmi2Load.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiUnload","page":"FMU version independent functions","title":"FMI.fmiUnload","text":"fmiUnload(fmu::FMU2)\n\nUnloads the FMU and all its instances and frees the allocated memory.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nSee also fmi2Unload.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#Reading-the-model-description","page":"FMU version independent functions","title":"Reading the model description","text":"","category":"section"},{"location":"library/fmu/","page":"FMU version independent functions","title":"FMU version independent functions","text":"fmiGetModelName\nfmiGetGUID\nfmiGetGenerationTool\nfmiGetGenerationDateAndTime\nfmiGetVariableNamingConvention\nfmiGetNumberOfEventIndicators\nfmiCanGetSetState\nfmiCanSerializeFMUstate\nfmiProvidesDirectionalDerivative\nfmiIsCoSimulation\nfmiIsModelExchange\nfmiInfo","category":"page"},{"location":"library/fmu/#FMI.fmiGetModelName","page":"FMU version independent functions","title":"FMI.fmiGetModelName","text":"fmiGetModelName(str::Union{fmi2StructMD, fmi3StructMD})\n\nReturns the tag 'modelName' from the model description.\n\nArguments\n\nstr::Union{fmi2StructMD, fmi3StructMD}:  Representative for an FMU in the FMI 2.0.2 Standard or FMI 3.0 Standard. Other notation:\n\nUnion{fmi2StructMD, fmi3StructMD} = Union{FMU2, FMU2Component, fmi2ModelDescription, FMU3, FMU3Component, fmi3ModelDescription}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::fmi2ModelDescription: Struct wich provides the static information of ModelVariables.\nstr::FMU3: Mutable struct representing an FMU in the FMI 3.0 Standard.\nstr::FMU3Component:  Mutable struct represents a pointer to an FMU specific data structure that contains the information needed. Also in FMI 3.0 Standard.\nstr::fmi3ModelDescription: Struct witch provides the static information of ModelVariables.\n\nSee also FMU2, FMU2Component, fmi2ModelDescription, FMU3, FMU3Component, fmi3ModelDescription.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiGetGUID","page":"FMU version independent functions","title":"FMI.fmiGetGUID","text":"fmiGetGUID(str::fmi2StructMD)\n\nReturns the tag 'guid' from the model description.\n\nArguments\n\nstr::fmi2StructMD:  Representative for an FMU in the FMI 2.0.2 Standard. More detailed:  fmi2StructMD =  Union{FMU2, FMU2Component, fmi2ModelDescription}\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::fmi2ModelDescription: Struct wich provides the static information of ModelVariables.\n\nSee also fmi2GetGUID, fmi2StructMD, FMU2, FMU2Component, fmi2ModelDescription.  \n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiGetGenerationTool","page":"FMU version independent functions","title":"FMI.fmiGetGenerationTool","text":"fmiGetGenerationTool(str::fmi2StructMD)\n\nReturns the tag 'generationtool' from the model description.\n\nArguments\n\nstr::fmi2StructMD:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed:  fmi2StructMD =  Union{FMU2, FMU2Component, fmi2ModelDescription}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::fmi2ModelDescription: Struct wich provides the static information of ModelVariables.\n\nReturns\n\nstr.generationtool: The function fmi2GetGenerationTool returns the tag 'generationtool' from the struct, representing a FMU (str).\n\nSee also fmi2GetGenerationTool, fmi2StructMD, FMU2, FMU2Component, fmi2ModelDescription.  \n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiGetGenerationDateAndTime","page":"FMU version independent functions","title":"FMI.fmiGetGenerationDateAndTime","text":"fmiGetGenerationDateAndTime(str::fmi2StructMD)\n\nReturns the tag 'generationdateandtime' from the model description.\n\nArguments\n\nstr::fmi2StructMD:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed:  fmi2StructMD =  Union{FMU2, FMU2Component, fmi2ModelDescription}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::fmi2ModelDescription: Struct witch provides the static information of ModelVariables.\n\nReturns\n\nstr.generationDateAndTime: The function fmi2GetGenerationDateAndTime returns the tag 'generationDateAndTime' from the struct, representing a FMU (str).\n\nSee also fmi2GetGenerationDateAndTime, fmi2StructMD, FMU2, FMU2Component, fmi2ModelDescription.  \n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiGetVariableNamingConvention","page":"FMU version independent functions","title":"FMI.fmiGetVariableNamingConvention","text":"fmiGetVariableNamingConvention(str::fmi2StructMD)\n\nReturns the tag 'varaiblenamingconvention' from the model description.\n\nArguments\n\nstr::fmi2StructMD:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed:  fmi2StructMD =  Union{FMU2, FMU2Component, fmi2ModelDescription}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::fmi2ModelDescription: Struct witch provides the static information of ModelVariables.\n\nReturns\n\nstr.variableNamingConvention: The function fmi2GetVariableNamingConvention returns the tag 'variableNamingConvention' from the struct, representing a FMU (str).\n\nSee also fmi2GetVariableNamingConvention, fmi2StructMD, FMU2, FMU2Component, fmi2ModelDescription.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiGetNumberOfEventIndicators","page":"FMU version independent functions","title":"FMI.fmiGetNumberOfEventIndicators","text":"fmiGetNumberOfEventIndicators(str::fmi2StructMD)\n\nReturns the tag 'numberOfEventIndicators' from the model description.\n\nArguments\n\nstr::fmi2StructMD:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2StructMD =  Union{FMU2, FMU2Component, fmi2ModelDescription}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::fmi2ModelDescription: Struct witch provides the static information of ModelVariables.\n\nReturns\n\nstr.numberOfEventIndicators: The function fmi2GetNumberOfEventIndicators returns the tag 'numberOfEventIndicators' from the struct, representing a FMU (str).\n\nSee also fmi2GetNumberOfEventIndicators, fmi2StructMD, FMU2, FMU2Component, fmi2ModelDescription.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiCanGetSetState","page":"FMU version independent functions","title":"FMI.fmiCanGetSetState","text":"fmiCanGetSetState(str::fmi2StructMD)\n\nReturns true, if the FMU supports the getting/setting of states\n\nArguments\n\nstr::fmi2StructMD:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2StructMD =  Union{FMU2, FMU2Component, fmi2ModelDescription}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::fmi2ModelDescription: Struct witch provides the static information of ModelVariables.\n\nReturns\n\n::Bool: The function fmi2CanGetSetState returns True, if the FMU supports the getting/setting of states.\n\nSee also fmi2CanGetSetState, fmi2StructMD, FMU2, FMU2Component, fmi2ModelDescription.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiCanSerializeFMUstate","page":"FMU version independent functions","title":"FMI.fmiCanSerializeFMUstate","text":"fmiCanSerializeFMUstate(str::fmi2StructMD)\n\nReturns true, if the FMU state can be serialized\n\nArguments\n\nstr::fmi2StructMD:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2StructMD =  Union{FMU2, FMU2Component, fmi2ModelDescription}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::fmi2ModelDescription: Struct wich provides the static information of ModelVariables.\n\nReturns\n\n::Bool: The function fmi2CanSerializeFMUstate returns True, if the FMU state can be serialized.\n\nSee also fmi2CanSerializeFMUstate, fmi2StructMD, FMU2, FMU2Component, fmi2ModelDescription.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiProvidesDirectionalDerivative","page":"FMU version independent functions","title":"FMI.fmiProvidesDirectionalDerivative","text":"fmiProvidesDirectionalDerivative(str::fmi2StructMD)\n\nReturns true, if the FMU provides directional derivatives\n\nArguments\n\nstr::fmi2StructMD:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2StructMD =  Union{FMU2, FMU2Component, fmi2ModelDescription}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::fmi2ModelDescription: Struct witch provides the static information of ModelVariables.\n\nReturns\n\n::Bool: The function fmi2ProvidesDirectionalDerivative returns True, if the FMU provides directional derivatives.\n\nSee also fmi2ProvidesDirectionalDerivative, fmi2StructMD, FMU2, FMU2Component, fmi2ModelDescription.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiIsCoSimulation","page":"FMU version independent functions","title":"FMI.fmiIsCoSimulation","text":"fmiIsCoSimulation(str::fmi2StructMD)\n\nReturns true, if the FMU supports co simulation\n\nArguments\n\nstr::fmi2StructMD:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2StructMD =  Union{FMU2, FMU2Component, fmi2ModelDescription}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::fmi2ModelDescription: Struct witch provides the static information of ModelVariables.\n\nReturns\n\n::Bool: The function fmi2IsCoSimulation returns True, if the FMU supports co simulation\n\nSee also fmi2IsCoSimulation, fmi2StructMD, FMU2, FMU2Component, fmi2ModelDescription.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiIsModelExchange","page":"FMU version independent functions","title":"FMI.fmiIsModelExchange","text":"fmiIsModelExchange(str::fmi2StructMD)\n\nReturns true, if the FMU supports model exchange\n\nArguments\n\nstr::fmi2StructMD:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2StructMD =  Union{FMU2, FMU2Component, fmi2ModelDescription}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::fmi2ModelDescription: Struct witch provides the static information of ModelVariables.\n\nReturns\n\n::Bool: The function fmi2IsCoSimulation returns True, if the FMU supports model exchange.\n\nSee also fmi2IsModelExchange, fmi2StructMD, FMU2, FMU2Component, fmi2ModelDescription.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiInfo","page":"FMU version independent functions","title":"FMI.fmiInfo","text":"fmiInfo(str::fmi2Struct)\n\nPrints FMU-specific information into the REPL.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\n\nSee also fmi2Info, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#Simulate-FMU","page":"FMU version independent functions","title":"Simulate FMU","text":"","category":"section"},{"location":"library/fmu/","page":"FMU version independent functions","title":"FMU version independent functions","text":"fmiSimulate\nfmiSimulateCS\nfmiSimulateME\n","category":"page"},{"location":"library/fmu/#FMI.fmiSimulate","page":"FMU version independent functions","title":"FMI.fmiSimulate","text":"fmiSimulate(str::fmi2Struct, t_start::Union{Real, Nothing} = nothing, t_stop::Union{Real, Nothing} = nothing;\n            tolerance::Union{Real, Nothing} = nothing,\n            dt::Union{Real, Nothing} = nothing,\n            solver = nothing,\n            customFx = nothing,\n            recordValues::fmi2ValueReferenceFormat = nothing,\n            saveat = [],\n            setup::Bool = true,\n            reset::Union{Bool, Nothing} = nothing, # nothing = auto\n            inputValueReferences::fmi2ValueReferenceFormat = nothing,\n            inputFunction = nothing,\n            parameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing,\n            dtmax::Union{Real, Nothing} = nothing,\n            kwargs...)\n\nStarts a simulation of the FMU instance for the matching FMU type, if both types are available, CS is preferred.\n\nArguments\n\nstr::fmi2Struct: Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nt_start::Union{Real, Nothing} = nothing: Set the start time to a value of type Real or the default value from the model description is used.\nt_stop::Union{Real, Nothing} = nothing: Set the end time to a value of type Real or the default value from the model description is used.\n\nKeywords\n\ntolerance::Union{Real, Nothing} = nothing: Real number to set the tolerance for any OED-solver\ndt::Union{Real, Nothing} = nothing: Real number to set the step size of the OED-solver. Defaults to an automatic choice if the method is adaptive. More Info: DifferentialEquations.jl Documentation\nsolver = nothing: Any Julia-supported OED-solver  (default is Tsit5). More Info: DifferentialEquations.jl Documentation\ncustomFx = nothing: [deperecated] Ability to give a custom state derivative function ẋ=f(x,t)\nrecordValues::fmi2ValueReferenceFormat = nothing: AbstractArray of variables (strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues\nsaveat = []: Time points to save values at (interpolated). More Info: DifferentialEquations.jl Documentation\nsetup::Bool = true: Boolean, if FMU should be setup (default: setup=true)\nreset::Union{Bool, Nothing} = nothing: Boolean, if FMU should be reset before simulation (default: reset:=auto)\ninputValueReferences::fmi2ValueReferenceFormat = nothing: AbstractArray of input variables (strings or variableIdentifiers) to set at every simulation step\ninputFunction = nothing: Function to retrieve the values to set the inputs to\nparameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing: Dictionary of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization\ndtmax::Union{Real, Nothing} = nothing: Real number for setting maximum dt for adaptive timestepping for the ODE solver. The default values are package dependent. More Info: DifferentialEquations.jl Documentation\nkwargs...: Further parameters of already defined functions solve(args..., kwargs...) from the library DifferentialEquations.jl\n\nReturns\n\nsuccess::Bool for CS-FMUs  \nODESolution for ME-FMUs  \nif keyword recordValues is set, a tuple of type (success::Bool, DiffEqCallbacks.SavedValues) for CS-FMUs  \nif keyword recordValues is set, a tuple of type (ODESolution, DiffEqCallbacks.SavedValues) for ME-FMUs  \n\nSee also fmi2Simulate, fmi2SimulateME, fmi2SimulateCS, fmi2Struct, FMU2, FMU2Component.   \n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiSimulateCS","page":"FMU version independent functions","title":"FMI.fmiSimulateCS","text":"fmiSimulateCS(str::fmi2Struct, t_start::Union{Real, Nothing} = nothing, t_stop::Union{Real, Nothing} = nothing;\n            tolerance::Union{Real, Nothing} = nothing,\n            dt::Union{Real, Nothing} = nothing,\n            solver = nothing,\n            customFx = nothing,\n            recordValues::fmi2ValueReferenceFormat = nothing,\n            saveat = [],\n            setup::Bool = true,\n            reset::Union{Bool, Nothing} = nothing, # nothing = auto\n            inputValueReferences::fmi2ValueReferenceFormat = nothing,\n            inputFunction = nothing,\n            parameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing,\n            dtmax::Union{Real, Nothing} = nothing,\n            kwargs...)\n\nStarts a simulation of the Co-Simulation FMU instance.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nt_start::Union{Real, Nothing} = nothing: Set the start time to a value of type Real or the default value from the model description is used.\nt_stop::Union{Real, Nothing} = nothing: Set the end time to a value of type Real or the default value from the model description is used.\n\nKeywords\n\ntolerance::Union{Real, Nothing} = nothing: Real number to set the tolerance for any OED-solver\ndt::Union{Real, Nothing} = nothing: Real number to set the step size of the OED-solver. Defaults to an automatic choice if the method is adaptive. More Info: DifferentialEquations.jl Documentation\nsolver = nothing: Any Julia-supported OED-solver  (default is Tsit5). More Info: DifferentialEquations.jl Documentation\ncustomFx = nothing: [deperecated] Ability to give a custom state derivative function ẋ=f(x,t)\nrecordValues::fmi2ValueReferenceFormat = nothing: AbstractArray of variables (strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues\nsaveat = []: Time points to save values at (interpolated). More Info: DifferentialEquations.jl Documentation\nsetup::Bool = true: Boolean, if FMU should be setup (default: setup=true)\nreset::Union{Bool, Nothing} = nothing: Boolean, if FMU should be reset before simulation (default: reset:=auto)\ninputValueReferences::fmi2ValueReferenceFormat = nothing: AbstractArray of input variables (strings or variableIdentifiers) to set at every simulation step\ninputFunction = nothing: Function to retrieve the values to set the inputs to\nparameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing: Dictionary of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization\ndtmax::Union{Real, Nothing} = nothing: Real number for setting maximum dt for adaptive timestepping for the ODE solver. The default values are package dependent. More Info: DifferentialEquations.jl Documentation\nkwargs...: Further parameters of already defined functions solve(args..., kwargs...) from the library DifferentialEquations.jl\n\nReturns\n\nIf keyword recordValues is not set, a boolean success is returned (simulation success).\nIf keyword recordValues is set, a tuple of type (true, DiffEqCallbacks.SavedValues) or (false, nothing).  \n\nSee also fmi2SimulateCS, fmi2Simulate, fmi2SimulateME, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#FMI.fmiSimulateME","page":"FMU version independent functions","title":"FMI.fmiSimulateME","text":"fmiSimulateME(str::fmi2Struct, t_start::Union{Real, Nothing} = nothing, t_stop::Union{Real, Nothing} = nothing;\n            tolerance::Union{Real, Nothing} = nothing,\n            dt::Union{Real, Nothing} = nothing,\n            solver = nothing,\n            customFx = nothing,\n            recordValues::fmi2ValueReferenceFormat = nothing,\n            saveat = [],\n            setup::Bool = true,\n            reset::Union{Bool, Nothing} = nothing, # nothing = auto\n            inputValueReferences::fmi2ValueReferenceFormat = nothing,\n            inputFunction = nothing,\n            parameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing,\n            dtmax::Union{Real, Nothing} = nothing,\n            kwargs...)\n\nSimulates a FMU instance for the given simulation time interval.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nt_start::Union{Real, Nothing} = nothing: Set the start time to a value of type Real or the default value from the model description is used.\nt_stop::Union{Real, Nothing} = nothing: Set the end time to a value of type Real or the default value from the model description is used.\n\nKeywords\n\ntolerance::Union{Real, Nothing} = nothing: Real number to set the tolerance for any OED-solver\ndt::Union{Real, Nothing} = nothing: Real number to set the step size of the OED-solver. Defaults to an automatic choice if the method is adaptive. More Info: DifferentialEquations.jl Documentation\nsolver = nothing: Any Julia-supported OED-solver  (default is Tsit5). More Info: DifferentialEquations.jl Documentation\ncustomFx = nothing: [deperecated] Ability to give a custom state derivative function ẋ=f(x,t)\nrecordValues::fmi2ValueReferenceFormat = nothing: AbstractArray of variables (strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues\nsaveat = []: Time points to save values at (interpolated). More Info: DifferentialEquations.jl Documentation\nsetup::Bool = true: Boolean, if FMU should be setup (default: setup=true)\nreset::Union{Bool, Nothing} = nothing: Boolean, if FMU should be reset before simulation (default: reset:=auto)\ninputValueReferences::fmi2ValueReferenceFormat = nothing: AbstractArray of input variables (strings or variableIdentifiers) to set at every simulation step\ninputFunction = nothing: Function to retrieve the values to set the inputs to\nparameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing: Dictionary of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization\ndtmax::Union{Real, Nothing} = nothing: Real number for setting maximum dt for adaptive timestepping for the ODE solver. The default values are package dependent. More Info: DifferentialEquations.jl Documentation\nkwargs...: Further parameters of already defined functions solve(args..., kwargs...) from the library DifferentialEquations.jl\n\nReturns\n\nIf keyword recordValues is not set, a struct of type ODESolution.\nIf keyword recordValues is set, a tuple of type (ODESolution, DiffEqCallbacks.SavedValues).\n\nSee also fmi2SimulateME fmi2SimulateCS, fmi2Simulate, fmi2Struct, FMU2, FMU2Component.  \n\n\n\n\n\n","category":"function"},{"location":"library/fmu/#Visualize-simulation-results","page":"FMU version independent functions","title":"Visualize simulation results","text":"","category":"section"},{"location":"library/fmu/","page":"FMU version independent functions","title":"FMU version independent functions","text":"fmiPlot","category":"page"},{"location":"examples/parameterize/#Manually-parameterize-an-FMU","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/parameterize/#License","page":"Manually parameterize an FMU","title":"License","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"Licensed under the MIT license. See LICENSE file in the project root for details.","category":"page"},{"location":"examples/parameterize/#Motivation","page":"Manually parameterize an FMU","title":"Motivation","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/parameterize/#Introduction-to-the-example","page":"Manually parameterize an FMU","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"This example shows how the manually parameterization of an FMU works if very specific adjustments during system initialization is needed. For this purpose, an IO-FMU model is loaded and the various commands for parameterization are shown on the basis of this model. With this example the user shall be guided how to make certain settings at an FMU. Please note, that parameterization of a simulation is possible in a much easier fashion: Using fmiSimulate, fmiSimulateME or fmiSimulateCS together with a parameter dictionary for the keyword parameters.","category":"page"},{"location":"examples/parameterize/#Target-group","page":"Manually parameterize an FMU","title":"Target group","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"The example is primarily intended for users who work in the field of simulation exchange. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/parameterize/#Other-formats","page":"Manually parameterize an FMU","title":"Other formats","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/parameterize/#Getting-started","page":"Manually parameterize an FMU","title":"Getting started","text":"","category":"section"},{"location":"examples/parameterize/#Installation-prerequisites","page":"Manually parameterize an FMU","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"","category":"page"},{"location":"examples/parameterize/#Code-section","page":"Manually parameterize an FMU","title":"Code section","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"# imports\nusing FMI\nusing FMIZoo","category":"page"},{"location":"examples/parameterize/#Simulation-setup","page":"Manually parameterize an FMU","title":"Simulation setup","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"Next, the start time and end time of the simulation are set.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"tStart = 0.0\ntStop = 1.0\ntSave = collect(tStart:tStop)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"2-element Vector{Float64}:\n 0.0\n 1.0","category":"page"},{"location":"examples/parameterize/#Import-FMU","page":"Manually parameterize an FMU","title":"Import FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"IO\", \"Dymola\", \"2022x\")\n\nmyFMU = fmiLoad(pathToFMU)\nfmiInfo(myFMU)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"┌ Info: fmi2Unzip(...): Successfully unzipped 153 files at `/tmp/fmijl_OhJGVC/IO`.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:76\n┌ Info: fmi2Load(...): FMU resources location is `file:////tmp/fmijl_OhJGVC/IO/resources`\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:192\n┌ Info: fmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.\n└ @ FMIImport /home/runner/.julia/packages/FMIImport/oQYco/src/FMI2_ext.jl:195\n\n\n#################### Begin information for FMU ####################\n\tModel name:\t\t\tIO\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{889089a6-481b-41a6-a282-f6ce02a33aa6}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:53:52Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t4\n\tInputs:\t\t\t\t3\n\t\t352321536 [\"u_real\"]\n\t\t352321537 [\"u_boolean\"]\n\t\t352321538 [\"u_integer\"]\n\tOutputs:\t\t\t3\n\t\t335544320 [\"y_real\"]\n\t\t335544321 [\"y_boolean\"]\n\t\t335544322 [\"y_integer\"]\n\tStates:\t\t\t\t0\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tIO\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tIO\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/parameterize/#Instantiate-and-Setup-FMU","page":"Manually parameterize an FMU","title":"Instantiate and Setup FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"Next it is necessary to create an instance of the FMU. This is achieved by the command fmiInstantiate!().","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiInstantiate!(myFMU; loggingOn=true)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"FMU:            IO\nInstanceName:   IO\nAddress:        Ptr{Nothing} @0x0000000005740720\nState:          fmi2ComponentStateInstantiated\nLogging:        false\nFMU time:       -Inf\nFMU states:     nothing","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"In the following code block, start and end time for the simulation is set by the fmiSetupExperiment() command.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiSetupExperiment(myFMU, tStart, tStop)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"0x00000000","category":"page"},{"location":"examples/parameterize/#Parameterize-FMU","page":"Manually parameterize an FMU","title":"Parameterize FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"In this example, for each data type (real, boolean, integer and string) a corresponding input or parameter is selected. From here on, the inputs and parameters will be referred to as parameters for simplicity.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"params = [\"p_real\", \"p_boolean\", \"p_integer\", \"p_string\"]","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"4-element Vector{String}:\n \"p_real\"\n \"p_boolean\"\n \"p_integer\"\n \"p_string\"","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"At the beginning we want to display the initial state of these parameters, for which the FMU must be in initialization mode. The next function fmiEnterInitializationMode() informs the FMU to enter the initialization mode. Before calling this function, the variables can be set. Furthermore, fmiSetupExperiment() must be called at least once before calling fmiEnterInitializationMode(), in order that the start time is defined.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiEnterInitializationMode(myFMU)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"The initial state of these parameters are displayed with the function fmiGet().","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiGet(myFMU, params)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"4-element Vector{Any}:\n 0.0\n 0\n 0\n  \"Hello World!\"","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"The initialization mode is terminated with the function fmiExitInitializationMode(). (For the model exchange FMU type, this function switches off all initialization equations, and enters the event mode implicitly.)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiExitInitializationMode(myFMU)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"In the next step, a function is defined that generates a random value for each parameter. For the parameter p_string a random number is inserted into the string. All parameters are combined to a tuple and output.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"function generateRandomNumbers()\n    rndReal = 100 * rand()\n    rndBoolean = rand() > 0.5\n    rndInteger = round(Integer, 100 * rand())\n    rndString = \"Random number $(100 * rand())!\"\n\n    return rndReal, rndBoolean, rndInteger, rndString\nend","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"generateRandomNumbers (generic function with 1 method)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"The previously defined function is called and the results are displayed in the console.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"paramsVal = generateRandomNumbers()","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"(35.100744319151445, false, 27, \"Random number 90.58563651085001!\")","category":"page"},{"location":"examples/parameterize/#First-variant","page":"Manually parameterize an FMU","title":"First variant","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"To show the first variant, it is necessary to terminate and reset the FMU instance. Then, as before, the setup command must be called for the FMU. ","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiTerminate(myFMU)\nfmiReset(myFMU)\nfmiSetupExperiment(myFMU, tStart, tStop)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"In the next step it is possible to set the parameters for the FMU. With the first variant it is quickly possible to set all parameters at once. Even different data types can be set with only one command. The command fmiSet() selects itself which function is chosen for which data type.  As long as the output of the function gives the status code 0, setting the parameters has worked.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiSet(myFMU, params, collect(paramsVal))","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"4-element Vector{UInt32}:\n 0x00000000\n 0x00000000\n 0x00000000\n 0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"After setting the parameters, it can be checked whether the corresponding parameters were set correctly. For this the function fmiGet() can be used as above. To be able to call the function fmiGet() the FMU must be in initialization mode.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiEnterInitializationMode(myFMU)\n# fmiGet(myFMU, params)\nfmiExitInitializationMode(myFMU)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"Now the FMU has been initialized correctly, the FMU can be simulated. The fmiSimulate() command is used for this purpose. It must be pointed out that the keywords instantiate=false, setup=false must be set. The keyword instantiate=false prevents the simulation command from creating a new FMU instance, otherwise our parameterization will be lost. The keyword setup=false prevents the FMU from calling the initialization mode again. The additionally listed keyword freeInstance=false prevents that the instance is removed after the simulation. This is only needed in this example, because we want to continue working on the created instance. Another keyword is the recordValues=parmas[1:3], which saves: p_real, p_boolean and p_integer as output. It should be noted that the fmiSimulate() function is not capable of outputting string values, so p_string is omitted.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"simData = fmiSimulate(myFMU, tStart, tStop; recordValues=params[1:3], saveat=tSave, \n                        instantiate=false, setup=false, freeInstance=false, terminate=false, reset=false)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"Model name:\n\tIO\nSuccess:\n\ttrue\nValues [2]:\n\t0.0\t(35.100744319151445, 0.0, 27.0)\n\t1.0\t(35.100744319151445, 0.0, 27.0)\nEvents [0]:","category":"page"},{"location":"examples/parameterize/#Second-variant","page":"Manually parameterize an FMU","title":"Second variant","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"To show the second variant, it is necessary to terminate and reset the FMU instance. Then, as before, the setup command must be called for the FMU. ","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiTerminate(myFMU)\nfmiReset(myFMU)\nfmiSetupExperiment(myFMU, tStart, tStop)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"To make sure that the functions work it is necessary to generate random numbers again. As shown already, we call the defined function generateRandomNumbers() and output the values.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"rndReal, rndBoolean, rndInteger, rndString = generateRandomNumbers()","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"(4.320990226531696, false, 99, \"Random number 30.65088975468737!\")","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"In the second variant, the value for each data type is set separately by the corresponding command. By this variant one has the maximum control and can be sure that also the correct data type is set. ","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiSetReal(myFMU, \"p_real\", rndReal)\nfmiSetBoolean(myFMU, \"p_boolean\", rndBoolean)\nfmiSetInteger(myFMU, \"p_integer\", rndInteger)\nfmiSetString(myFMU, \"p_string\", rndString)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"To illustrate the functionality of the parameterization with the separate functions, the corresponding get function can be also called separately for each data type:","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiSetReal() &#8660; fmiGetReal()\nfmiSetBoolean() &#8660; fmiGetBoolean()\nfmiSetInteger() &#8660; fmiGetInteger()\nfmiSetString() &#8660; fmiGetString().","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"As before, the FMU must be in initialization mode.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiEnterInitializationMode(myFMU)\n# fmiGetReal(myFMU, \"u_real\")\n# fmiGetBoolean(myFMU, \"u_boolean\")\n# fmiGetInteger(myFMU, \"u_integer\")\n# fmiGetString(myFMU, \"p_string\")\nfmiExitInitializationMode(myFMU)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"From here on, you may want to simulate the FMU. Please note, that with the default executionConfig, it is necessary to prevent a new instantiation using the keyword instantiate=false. Otherwise, a new instance is allocated for the simulation-call and the parameters set for the previous instance are not transfered.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"simData = fmiSimulate(myFMU, tStart, tStop; recordValues=params[1:3], saveat=tSave, \n                        instantiate=false, setup=false)","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"Model name:\n\tIO\nSuccess:\n\ttrue\nValues [2]:\n\t0.0\t(4.320990226531696, 0.0, 99.0)\n\t1.0\t(4.320990226531696, 0.0, 99.0)\nEvents [0]:","category":"page"},{"location":"examples/parameterize/#Unload-FMU","page":"Manually parameterize an FMU","title":"Unload FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"The FMU will be unloaded and all unpacked data on disc will be removed.","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiUnload(myFMU)","category":"page"},{"location":"examples/parameterize/#Summary","page":"Manually parameterize an FMU","title":"Summary","text":"","category":"section"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"Based on this tutorial it can be seen that there are two different variants to set and get parameters.These examples should make it clear to the user how parameters can also be set with different data types. As a small reminder, the sequence of commands for the manual parameterization of an FMU is summarized again. ","category":"page"},{"location":"examples/parameterize/","page":"Manually parameterize an FMU","title":"Manually parameterize an FMU","text":"fmiLoad() &#8594; fmiInstantiate!() &#8594; fmiSetupExperiment() &#8594; fmiSetXXX() &#8594; fmiEnterInitializationMode() &#8594; fmiGetXXX() &#8594; fmiExitInitializationMode() &#8594; fmiSimualte() &#8594; fmiUnload()","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: FMI.jl Logo)","category":"page"},{"location":"#FMI.jl","page":"Introduction","title":"FMI.jl","text":"","category":"section"},{"location":"#What-is-FMI.jl?","page":"Introduction","title":"What is FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI.jl is a free-to-use software library for the Julia programming language which integrates the Functional Mock-Up Interface (fmi-standard.org): load or create, parameterize, simulate and plot FMUs seamlessly inside the Julia programming language!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Dev Docs)  (Image: Run Tests) (Image: Run Examples) (Image: Build Docs) (Image: Coverage) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"#How-can-I-use-FMI.jl?","page":"Introduction","title":"How can I use FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Open a Julia-REPL, activate your preferred environment.\nGoto Package-Manager (if not already), install FMI.jl.  ```julia  julia> ]\n(@v1.6) pkg> add FMI  ```\nIf you want to check that everything works correctly, you can run the tests bundled with FMI.jl:  ```julia  julia> using Pkg\njulia> Pkg.test(\"FMI\")  ```\nAdditionally, you can check the version of FMI.jl that you have installed with the status command.  julia  julia> ]  (@v1.6) pkg> status FMI\nHave a look inside the examples folder in the examples branch or the examples section of the documentation. All examples are available as Julia-Script (.jl), Jupyter-Notebook (.ipynb) and Markdown (.md).","category":"page"},{"location":"#How-can-I-simulate-a-FMU-and-plot-values?","page":"Introduction","title":"How can I simulate a FMU and plot values?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using FMI, Plots\n\n# load and instantiate a FMU\nmyFMU = fmiLoad(pathToFMU)\n\n# simulate from t=0.0s until t=10.0s and record the FMU variable named \"mass.s\"\nsimData = fmiSimulate(myFMU, 0.0, 10.0; recordValues=[\"mass.s\"])\n\n# plot it!\nfmiPlot(simData)\n\n# free memory\nfmiUnload(myFMU)","category":"page"},{"location":"#What-is-currently-supported-in-FMI.jl?","page":"Introduction","title":"What is currently supported in FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"importing the full FMI 2.0.3 and FMI 3.0.0 command set, including optional specials like fmi2GetState, fmi2SetState and fmi2GetDirectionalDerivatives\nparameterization, simulation & plotting of CS- and ME-FMUs\nevent-handling for imported discontinuous ME-FMUs","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":" FMI2.0.3  FMI3.0 \n Import Export Import Export\nCS ✓✓ ~~ ✓ ~\nME (continuous) ✓✓ ✓✓ ✓ ~\nME (discontinuous) ✓✓ ✓✓ ✓ ~\nSE - - ✓ ~\nExplicit solvers ✓✓ ✓✓ ✓ ~\nImplicit solvers (autodiff=false) ✓✓ ~~ ✓ ~\nImplicit solvers (autodiff=true) ✓ ~~ ~~ ~\nget/setState ✓✓ ~ ✓ ~\ngetDirectionalDerivatives ✓✓ ~ ✓ ~\ngetAdjointDerivatives - - ✓ ~","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"✓✓ supported & tested","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"✓  beta supported, untested","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"~~ work in progress","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"~  planned","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"-  not supported by the corresponding FMI standard","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"x  not planned","category":"page"},{"location":"#What-FMI.jl-Library-to-use?","page":"Introduction","title":"What FMI.jl-Library to use?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: FMI.jl Logo) To keep dependencies nice and clean, the original package FMI.jl had been split into new packages:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI.jl: High level loading, manipulating, saving or building entire FMUs from scratch\nFMIImport.jl: Importing FMUs into Julia\nFMIExport.jl: Exporting stand-alone FMUs from Julia Code\nFMICore.jl: C-code wrapper for the FMI-standard\nFMIBuild.jl: Compiler/Compilation dependencies for FMIExport.jl\nFMIFlux.jl: Machine Learning with FMUs (differentiation over FMUs)\nFMIZoo.jl: A collection of testing and example FMUs","category":"page"},{"location":"#What-is-further-under-development-in-FMI.jl?","page":"Introduction","title":"What is further under development in FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI Cross Checks (as soon as the successor is available)\nnice documentation & doc-strings\nmore examples/tutorials\n...","category":"page"},{"location":"#What-is-planned-for-FMI.jl?","page":"Introduction","title":"What is planned for FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SSP 1.0 support\n...","category":"page"},{"location":"#What-Platforms-are-supported?","page":"Introduction","title":"What Platforms are supported?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI.jl is tested (and testing) under Julia Versions 1.6.5 LTS (64-bit) and latest (64-bit) on Windows latest (64-bit) and Ubuntu latest (64-bit). Mac and Julia (32-bit) should work, but untested.","category":"page"},{"location":"#How-to-cite?-Related-publications?","page":"Introduction","title":"How to cite? Related publications?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Tobias Thummerer, Lars Mikelsons and Josef Kircher. 2021. NeuralFMU: towards structural integration of FMUs into neural networks. Martin Sjölund, Lena Buffoni, Adrian Pop and Lennart Ochel (Ed.). Proceedings of 14th Modelica Conference 2021, Linköping, Sweden, September 20-24, 2021. Linköping University Electronic Press, Linköping (Linköping Electronic Conference Proceedings ; 181), 297-306. DOI: 10.3384/ecp21181297","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Tobias Thummerer, Johannes Tintenherr, Lars Mikelsons 2021 Hybrid modeling of the human cardiovascular system using NeuralFMUs Journal of Physics: Conference Series 2090, 1, 012155. DOI: 10.1088/1742-6596/2090/1/012155","category":"page"},{"location":"#Interested-in-Hybrid-Modelling-in-Julia-using-FMUs?","page":"Introduction","title":"Interested in Hybrid Modelling in Julia using FMUs?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"See FMIFlux.jl.","category":"page"},{"location":"library/library/#Version-independent-library-functions","page":"FMI version independent library functions","title":"Version independent library functions","text":"","category":"section"},{"location":"library/library/#Creation,-Destruction-FMU","page":"FMI version independent library functions","title":"Creation, Destruction FMU","text":"","category":"section"},{"location":"library/library/","page":"FMI version independent library functions","title":"FMI version independent library functions","text":"fmiInstantiate!\nfmiFreeInstance!","category":"page"},{"location":"library/library/#FMI.fmiInstantiate!","page":"FMI version independent library functions","title":"FMI.fmiInstantiate!","text":"fmiInstantiate!(fmu::FMU2; pushComponents::Bool = true, visible::Bool = false, loggingOn::Bool = false, externalCallbacks::Bool = false,\n                      logStatusOK::Bool=true, logStatusWarning::Bool=true, logStatusDiscard::Bool=true, logStatusError::Bool=true, logStatusFatal::Bool=true, logStatusPending::Bool=true)\n\nCreates a new instance of the FMU, version independent.\n\nCreate a new instance of the given fmu, adds a logger if logginOn == true.\n\nArguments\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nKeywords\n\npushComponents::Bool = true:  pushComponents if the item component should be inserted in fmu.components(default = true).\nvisible::Bool = false: visible if the FMU should be started with graphic interface, if supported (default=false)\nloggingOn::Bool = false: loggingOn if the FMU should log and display function calls (default=false)\nexternalCallbacks::Bool = false: externalCallbacks if an external DLL should be used for the fmi2CallbackFunctions, this may improve readability of logging messages (default=false)\nlogStatusOK::Bool=true: logStatusOK whether to log status of kind fmi2OK (default=true)\nlogStatusWarning::Bool=true: logStatusWarning whether to log status of kind fmi2Warning (default=true)\nlogStatusDiscard::Bool=true: logStatusDiscard whether to log status of kind fmi2Discard (default=true)\nlogStatusError::Bool=true: logStatusError whether to log status of kind fmi2Error (default=true)\nlogStatusFatal::Bool=true: logStatusFatal whether to log status of kind fmi2Fatal (default=true)\nlogStatusPending::Bool=true: logStatusPending whether to log status of kind fmi2Pending (default=true)\n\nReturns\n\nnothing: if the instantiation failed. In addition, an error message appears.\ncomponent: Returns the instance of a new FMU component.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.19]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nSee also fmi2Instantiate!, fmi2Instantiate, FMU2.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiFreeInstance!","page":"FMI version independent library functions","title":"FMI.fmiFreeInstance!","text":"fmiFreeInstance!(str::fmi2Struct)\n\nFrees the allocated memory of the last instance of the FMU.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2FreeInstance, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#Platform-and-Version-number","page":"FMI version independent library functions","title":"Platform and Version number","text":"","category":"section"},{"location":"library/library/","page":"FMI version independent library functions","title":"FMI version independent library functions","text":"fmiGetTypesPlatform\nfmiGetVersion\nfmiSetDebugLogging","category":"page"},{"location":"library/library/#FMI.fmiGetTypesPlatform","page":"FMI version independent library functions","title":"FMI.fmiGetTypesPlatform","text":"fmiGetTypesPlatform(str::fmi2Struct)\n\nReturns the header file used to compile the FMU. By default returns default, version independent.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\n\n\nSee also fmi2GetVersion, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiGetVersion","page":"FMI version independent library functions","title":"FMI.fmiGetVersion","text":"fmiGetVersion(str::fmi2Struct)\n\nReturns the version of the FMU, version independent.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns a string from the address of a C-style (NUL-terminated) string. The string represents the version of the “fmi2Functions.h” header file which was used to compile the functions of the FMU. The function returns “fmiVersion” which is defined in this header file. The standard header file as documented in this specification has version “2.0”\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2GetVersion, unsafe_string, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiSetDebugLogging","page":"FMI version independent library functions","title":"FMI.fmiSetDebugLogging","text":"fmiSetDebugLogging(str::fmi2Struct)\n\nControl the use of the logging callback function, version independent.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\n\n\n\n\n","category":"function"},{"location":"library/library/#Initialization,-Termination-and-Destruction","page":"FMI version independent library functions","title":"Initialization, Termination and Destruction","text":"","category":"section"},{"location":"library/library/","page":"FMI version independent library functions","title":"FMI version independent library functions","text":"fmiSetupExperiment\nfmiEnterInitializationMode\nfmiExitInitializationMode\nfmiTerminate\nfmiReset","category":"page"},{"location":"library/library/#FMI.fmiSetupExperiment","page":"FMI version independent library functions","title":"FMI.fmiSetupExperiment","text":"fmiSetupExperiment(str::fmi2Struct, c::FMU2Component, startTime::Union{Real, Nothing} = nothing, stopTime::Union{Real, Nothing} = nothing; tolerance::Union{Real, Nothing} = nothing)\n\nInitialize the Simulation boundries\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstartTime::Union{Real, Nothing} = nothing: startTime is a real number which sets the value of starting time of the experiment. The default value is set automatically if doing nothing (default = nothing).\nstopTime::Union{Real, Nothing} = nothing: stopTime is a real number which sets the value of ending time of the experiment. The default value is set automatically if doing nothing (default = nothing).\n\nKeywords\n\ntolerance::Union{Real, Nothing} = nothing: tolerance is a real number which sets the value of tolerance range. The default value is set automatically if doing nothing (default = nothing).\n\nReturns\n\nReturns a warning if str.state is not called in fmi2ComponentStateInstantiated.\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2SetupExperiment, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiEnterInitializationMode","page":"FMI version independent library functions","title":"FMI.fmiEnterInitializationMode","text":"fmiEnterInitializationMode(str::fmi2Struct)\n\nInforms the FMU to enter initializaton mode, version independent.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns a warning if str.state is not called in fmi2ComponentStateInstantiated.\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2EnterInitializationMode, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiExitInitializationMode","page":"FMI version independent library functions","title":"FMI.fmiExitInitializationMode","text":"fmiExitInitializationMode(str::fmi2Struct)\n\nInforms the FMU to exit initialization mode, version independent.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns a warning if str.state is not called in fmi2ComponentStateInitializationMode.\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2ExitInitializationMode, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiTerminate","page":"FMI version independent library functions","title":"FMI.fmiTerminate","text":"fmiTerminate(str::fmi2Struct)\n\nInforms the FMU that the simulation run is terminated, version independent.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns a warning if str.state is not called in fmi2ComponentStateContinuousTimeMode or fmi2ComponentStateEventMode.\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2ExitInitializationMode, fmi2Status, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiReset","page":"FMI version independent library functions","title":"FMI.fmiReset","text":"fmiReset(str::fmi2Struct)\n\nResets the FMU after a simulation run, version independent.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns a warning if str.state is not called in fmi2ComponentStateTerminated or fmi2ComponentStateError.\nReturns an error if the reinstantiation failed.\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2Reset, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#Get/Set-variable-values","page":"FMI version independent library functions","title":"Get/Set variable values","text":"","category":"section"},{"location":"library/library/","page":"FMI version independent library functions","title":"FMI version independent library functions","text":"fmiGetReal\nfmiGetReal!\nfmiSetReal\nfmiGetInteger\nfmiGetInteger!\nfmiSetInteger\nfmiGetBoolean\nfmiGetBoolean!\nfmiSetBoolean\nfmiGetString\nfmiGetString!\nfmiSetString","category":"page"},{"location":"library/library/#FMI.fmiGetReal","page":"FMI version independent library functions","title":"FMI.fmiGetReal","text":"fmiGetReal(str::fmi2Struct, vr::fmi2ValueReferenceFormat)\n\nReturns the real values of an array of variables\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fm2Real}: returns values of an array of fmi2Real variables with the dimension of fmi2ValueReferenceFormat length.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetReal,fmi2ValueReferenceFormat, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiGetReal!","page":"FMI version independent library functions","title":"FMI.fmiGetReal!","text":"fmiGetReal!(str::fmi2Struct, c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Array{fmi2Real})\n\nfmiGetReal!(str::fmi2Struct, c::FMU2Component, vr::Array{fmi2ValueReference}, nvr::Csize_t, value::Array{fmi2Real})\n\nWrites the real values of an array of variables in the given field\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::Array{fm2Real}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetReal!, fmi2GetReal,fmi2ValueReferenceFormat, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiSetReal","page":"FMI version independent library functions","title":"FMI.fmiSetReal","text":"fmiSetReal(str::fmi2Struct, c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{Array{<:Real}, <:Real})\n\nfmiSetReal(str::fmi2Struct, c::FMU2Component, vr::Array{fmi2ValueReference}, nvr::Csize_t, value::Array{fmi2Real})\n\nSet the values of an array of real variables\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::Union{Array{<:Real}, <:Real}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2SetReal, fmi2GetReal,fmi2ValueReferenceFormat, fmi2Struct, FMU2, FMU2Component, fmi2ValueReference.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiGetInteger","page":"FMI version independent library functions","title":"FMI.fmiGetInteger","text":"fmiGetInteger(str::fmi2Struct,c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nReturns the integer values of an array of variables\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi2Integer}: Return values is an array with the actual values of these variables.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger,fmi2ValueReferenceFormat, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiGetInteger!","page":"FMI version independent library functions","title":"FMI.fmiGetInteger!","text":"function fmiGetInteger!(str::fmi2Struct, c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Array{fmi2Integer})\n\nfunction fmiGetInteger!(str::fmi2Struct, c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Array{fmi2Integer})\n\nWrites the integer values of an array of variables in the given field\n\nfmi2GetInteger! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::Array{fmi2Integer}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!,fmi2ValueReferenceFormat, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiSetInteger","page":"FMI version independent library functions","title":"FMI.fmiSetInteger","text":"fmiSetInteger(str::fmi2Struct, c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{Array{<:Integer}, <:Integer})\n\nfmiSetInteger(str::fmi2Struct, c::FMU2Component, vr::Array{fmi2ValueReference}, nvr::Csize_t, value::Array{fmi2Integer})\n\nSet the values of an array of integer variables\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::Union{Array{<:Integer}, <:Integer}: Argument values is an array or a single value with type Integer or any subtyp\nvalue::Array{fmi2Integer}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status indicates the success of the function call.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2SetInteger,fmi2ValueReferenceFormat, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiGetBoolean","page":"FMI version independent library functions","title":"FMI.fmiGetBoolean","text":"fmiGetBoolean(str::fmi2Struct, c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nReturns the boolean values of an array of variables\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi2Boolean}: Return values is an array with the actual values of these variables.\n\nSee also fmi2GetBoolean,fmi2ValueReferenceFormat, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiGetBoolean!","page":"FMI version independent library functions","title":"FMI.fmiGetBoolean!","text":"fmiGetBoolean!(str::fmi2Struct, c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Array{fmi2Boolean})\n\nWrites the boolean values of an array of variables in the given field\n\nfmi2GetBoolean! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::Union{Array{<:Integer}, <:Integer}: Argument values is an array or a single value with type Integer or any subtyp\nvalue::Array{fmi2Integer}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean!,fmi2ValueReferenceFormat, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiSetBoolean","page":"FMI version independent library functions","title":"FMI.fmiSetBoolean","text":"fmiSetBoolean(str::fmi2Struct, c::FMU2Component, vr::Array{fmi2ValueReference}, nvr::Csize_t, value::Array{fmi2Boolean})\n\nfmiSetBoolean(str::fmi2Struct, c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{Array{Bool}, Bool})\n\nSet the values of an array of boolean variables\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Array of the FMI2 Data Typ fmi2ValueReference\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::Union{Array{Bool}, Bool}: Argument values is an array or a single value with type Boolean or any subtyp\nvalue::Array{fmi2Boolean}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean,fmi2ValueReferenceFormat, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiGetString","page":"FMI version independent library functions","title":"FMI.fmiGetString","text":"fmiGetString(str::fmi2Struct, c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nReturns the string values of an array of variables\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi2String}:  Return values is an array with the actual values of these variables.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean!,fmi2ValueReferenceFormat, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiGetString!","page":"FMI version independent library functions","title":"FMI.fmiGetString!","text":"fmiGetString!(str::fmi2Struct, c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Array{fmi2String})\n\nfmiGetString!(str::fmi2Struct, c::FMU2Component, vr::Array{fmi2ValueReference}, nvr::Csize_t, value::Vector{Ptr{Cchar}})\n\nWrites the string values of an array of variables in the given field\n\nThese functions are especially used to get the actual values of output variables if a model is connected with other models.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Array of the FMI2 Data Typ fmi2ValueReference\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::Union{Array{Bool}, Bool}: Argument values is an array or a single value with type Boolean or any subtyp.\nvalue::Vector{Ptr{Cchar}}: Argument values is an vector with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetString!,fmi2ValueReferenceFormat, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiSetString","page":"FMI version independent library functions","title":"FMI.fmiSetString","text":"fmiSetString(str::fmi2Struct, c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{Array{String}, String})\n\nfmiSetString(str::fmi2Struct, c::FMU2Component, vr::Array{fmi2ValueReference}, nvr::Csize_t, value::Union{Array{Ptr{Cchar}}, Array{Ptr{UInt8}}})\n\nSet the values of an array of string variables\n\nFor the exact rules on which type of variables fmi2SetXXX can be called see FMISpec2.0.2 section 2.2.7 , as well as FMISpec2.0.2 section 3.2.3 in case of ModelExchange and FMISpec2.0.2 section 4.2.4 in case of CoSimulation.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Array of the FMI2 Data Typ fmi2ValueReference\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::Union{Array{String}, String}: Argument values is an array or a single value with type String.\nvalue::Vector{Ptr{Cchar}}: Argument values is an vector with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.46]: 2.2.7 Definition of Model Variables\nFMISpec2.0.2[p.46]: 3.2.3 State Machine of Calling Sequence\nFMISpec2.0.2[p.108]: 4.2.4 State Machine of Calling Sequence from Master to Slave\n\nSee also fmi2SetString,fmi2ValueReferenceFormat, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMU-state-Functions","page":"FMI version independent library functions","title":"FMU state Functions","text":"","category":"section"},{"location":"library/library/","page":"FMI version independent library functions","title":"FMI version independent library functions","text":"fmiGetFMUstate\nfmiSetFMUstate\nfmiFreeFMUstate!\nfmiSerializedFMUstateSize\nfmiSerializeFMUstate\nfmiDeSerializeFMUstate","category":"page"},{"location":"library/library/#FMI.fmiGetFMUstate","page":"FMI version independent library functions","title":"FMI.fmiGetFMUstate","text":"#ToDo\n\nfmiGetFMUstate(str::fmi2Struct)\n\nMakes a copy of the internal FMU state and returns a pointer to this copy.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nReturn state is a pointer to a copy of the internal FMU state.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2GetFMUstate, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiSetFMUstate","page":"FMI version independent library functions","title":"FMI.fmiSetFMUstate","text":"fmiSetFMUstate(str::fmi2Struct, c::FMU2Component, FMUstate::fmi2FMUstate)\n\nSets the FMU to the given state\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::fmi2FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2GetFMUstate, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiFreeFMUstate!","page":"FMI version independent library functions","title":"FMI.fmiFreeFMUstate!","text":"fmiFreeFMUstate!(str::fmi2Struct, c::FMU2Component, state::fmi2FMUstate)\n\nfmiFreeFMUstate!(str::fmi2Struct, c::FMU2Component, FMUstate::Ref{fmi2FMUstate})\n\nFree the memory for the allocated FMU state\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nFMUstate::Ref{fmi2FMUstate}: Argument FMUstate is an object that safely references data of type fmi3FMUstate wich is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nReturn singleton instance of type Nothing, if there is no value to return (as in a C void function) or when a variable or field holds no value.\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2FreeFMUstate!,fmi2FMUstate, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiSerializedFMUstateSize","page":"FMI version independent library functions","title":"FMI.fmiSerializedFMUstateSize","text":"fmiSerializedFMUstateSize(str::fmi2Struct, c::FMU2Component, state::fmi2FMUstate)\n\nReturns the size of the byte vector in which the FMUstate can be stored.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nReturn size is an object that safely references a value of type Csize_t.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializedFMUstateSize,fmi2FMUstate, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiSerializeFMUstate","page":"FMI version independent library functions","title":"FMI.fmiSerializeFMUstate","text":"fmiSerializeFMUstate(str::fmi2Struct, c::FMU2Component, state::fmi2FMUstate)\n\nSerializes the data referenced by the pointer FMUstate and copies this data into the byte vector serializedState of length size to be provided by the environment.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nserialized:: Array{fmi2Byte}: Return serializedState contains the copy of the serialized data referenced by the pointer FMUstate\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializeFMUstate,fmi2FMUstate, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiDeSerializeFMUstate","page":"FMI version independent library functions","title":"FMI.fmiDeSerializeFMUstate","text":"TODO     fmiDeSerializeFMUstate(str::fmi2Struct, c::FMU2Component, serializedState::Array{fmi2Byte})\n\nDeserialize the data in the serializedState fmi2Byte field\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nserializedState::Array{fmi2Byte}: Argument serializedState contains the fmi2Byte field to be deserialized.\n\nReturns\n\nReturn state is a pointer to a copy of the internal FMU state.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2DeSerializeFMUstate,fmi2FMUstate, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#Partial-Derivatives","page":"FMI version independent library functions","title":"Partial Derivatives","text":"","category":"section"},{"location":"library/library/","page":"FMI version independent library functions","title":"FMI version independent library functions","text":"fmiGetDirectionalDerivative(::FMI.fmi2Struct, ::Array{Cint}, ::Array{Cint}, ::Array{Real}, ::Array{Real})","category":"page"},{"location":"library/library/#FMI.fmiGetDirectionalDerivative-Tuple{Union{FMU2, FMU2Component}, Array{Int32, N} where N, Array{Int32, N} where N, Array{Real, N} where N, Array{Real, N} where N}","page":"FMI version independent library functions","title":"FMI.fmiGetDirectionalDerivative","text":"fmiGetDirectionalDerivative(str::fmi2Struct, c::FMU2Component,\n                                  vUnknown_ref::Array{fmi2ValueReference},\n                                  vKnown_ref::Array{fmi2ValueReference},\n                                  dvKnown::Union{Array{fmi2Real}, Nothing} = nothing)\n\nReturns the values of the directional derivatives.\n\nΔvUnknown = (∂h / ∂vKnown) ⋅ ΔvKnown\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::Array{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model. vUnknown_ref is the Array of the vector values of unknown variables computed in the actual Mode.\nvKnown_ref::Array{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref is the Array of the vector values of Real input variables of function h that changes its value in the actual Mode.\ndvKnown::Union{Array{fmi2Real}, Nothing} = nothing: Argument dvKnown contains values of type fmi2Real or one value of type Nothing, if no argument is passed the default value nothing is used. dvKnown represents the seed vector.\n\nReturns\n\ndvUnknown::Array{fmi2Real}: Return dvUnknown contains the directional derivative vector values.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.9 Getting Partial Derivatives\n\nSee also fmi2GetDirectionalDerivative,fmi2FMUstate, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"method"},{"location":"library/library/#CoSimulation-specific-Functions","page":"FMI version independent library functions","title":"CoSimulation specific Functions","text":"","category":"section"},{"location":"library/library/","page":"FMI version independent library functions","title":"FMI version independent library functions","text":"fmiDoStep(::FMI.fmi2Struct, ::Real)","category":"page"},{"location":"library/library/#FMI.fmiDoStep-Tuple{Union{FMU2, FMU2Component}, Real}","page":"FMI version independent library functions","title":"FMI.fmiDoStep","text":"fmiDoStep(str::fmi2Struct, c::FMU2Component, communicationStepSize::Union{Real, Nothing} = nothing; currentCommunicationPoint::Union{Real, Nothing} = nothing, noSetFMUStatePriorToCurrentPoint::Bool = true)\n\nfmiDoStep(str::fmi2Struct, c::FMU2Component, currentCommunicationPoint::fmi2Real, communicationStepSize::fmi2Real, noSetFMUStatePriorToCurrentPoint::fmi2Boolean)\n\nDoes one step in the CoSimulation FMU\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ncommunicationStepSize::Union{Real, Nothing} = nothing: Argument communicationStepSize contains a value of type Real or Nothing , if no argument is passed the default value nothing is used. communicationStepSize defines the communiction step size.\ncurrentCommunicationPoint::fmi2Real: Argument currentCommunicationPoint contains a value of type fmi2Real which is a identifier for a variable value . currentCommunicationPoint defines the current communication point of the master.\ncommunicationStepSize::fmi2Real: Argument communicationStepSize contains a value of type fmi2Real which is a identifier for a variable value. communicationStepSize defines the communiction step size.\nnoSetFMUStatePriorToCurrentPoint::fmi2Boolean: Argument noSetFMUStatePriorToCurrentPoint contains a value of type fmi2Boolean which is a identifier for a variable value. noSetFMUStatePriorToCurrentPoint indicates whether fmi2SetFMUStatewill no longer be called for time instants prior to currentCommunicationPoint in this simulation run.\n\nKeywords\n\ncurrentCommunicationPoint::Union{Real, Nothing} = nothing: Argument currentCommunicationPoint contains a value of type Real or type Nothing. If no argument is passed the default value nothing is used. currentCommunicationPoint defines the current communication point of the master.\nnoSetFMUStatePriorToCurrentPoint::Bool = true: Argument noSetFMUStatePriorToCurrentPoint contains a value of type Boolean. If no argument is passed the default value true is used. noSetFMUStatePriorToCurrentPoint indicates whether fmi2SetFMUState is no longer called for times before the currentCommunicationPoint in this simulation run Simulation run.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.2 Computation\n\nSee also fmi2DoStep, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"method"},{"location":"library/library/#ModelExchange-specific-Functions","page":"FMI version independent library functions","title":"ModelExchange specific Functions","text":"","category":"section"},{"location":"library/library/","page":"FMI version independent library functions","title":"FMI version independent library functions","text":"fmiSetTime\nfmiSetContinuousStates\nfmiNewDiscreteStates\nfmiEnterContinuousTimeMode\nfmiCompletedIntegratorStep\nfmiGetDerivatives\nfmiGetEventIndicators\nfmiGetContinuousStates\nfmiGetNominalsOfContinuousStates","category":"page"},{"location":"library/library/#FMI.fmiSetTime","page":"FMI version independent library functions","title":"FMI.fmiSetTime","text":"fmiSetTime(c::fmi2Struct, c::FMU2Component, time::fmi2Real)\n\nfmiSetTime(c::fmi2Struct, c::FMU2Component, t::Real)\n\nSet a new time instant and re-initialize caching of variables that depend on time.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ntime::fmi2Real: Argument time contains a value of type fmi2Real which is a alias type for Real data type. time sets the independent variable time t.\nt::Real: Argument t contains a value of type Real. t sets the independent variable time t.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSee also fmi2SetTime, fmi2Struct, FMU2, FMU2Component, fmi2ValueReference.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiSetContinuousStates","page":"FMI version independent library functions","title":"FMI.fmiSetContinuousStates","text":"fmiSetContinuousStates(str::fmi2Struct, c::FMU2Component,\n                             x::AbstractArray{fmi2Real},\n                             nx::Csize_t)\n\nfmiSetContinuousStates(str::fmi2Struct, c::FMU2Component,\n                             x::Union{AbstractArray{Float32},AbstractArray{Float64}})\n\nSet a new (continuous) state vector\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx::AbstractArray{fmi2Real}: Argument x contains values of type fmi2Real which is a alias type for Real data type.x is the AbstractArray of the vector values of Real input variables of function h that changes its value in the actual Mode.\nx::Union{AbstractArray{Float32},AbstractArray{Float64}}:\nnx::Csize_t: Argument nx defines the length of vector x and is provided for checking purposes\n\nReturns\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSee also fmi2SetContinuousStates.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiNewDiscreteStates","page":"FMI version independent library functions","title":"FMI.fmiNewDiscreteStates","text":"fmiNewDiscreteStates(str::fmi2Struct)\n\nReturns the next discrete states\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\neventInfo::fmi2EventInfo*: Strut with fmi2Boolean Variables\n\nMore detailed:\n\nnewDiscreteStatesNeeded::fmi2Boolean: If newDiscreteStatesNeeded = fmi2True the FMU should stay in Event Mode, and the FMU requires to set new inputs to the FMU to compute and get the outputs and to call\n\nfmi2NewDiscreteStates again. If all FMUs return newDiscreteStatesNeeded = fmi2False call fmi2EnterContinuousTimeMode.\n\nterminateSimulation::fmi2Boolean: If terminateSimulation = fmi2True call fmi2Terminate\nnominalsOfContinuousStatesChanged::fmi2Boolean: If nominalsOfContinuousStatesChanged = fmi2True then the nominal values of the states have changed due to the function call and can be inquired with fmi2GetNominalsOfContinuousStates.\nvaluesOfContinuousStatesChanged::fmi2Boolean: If valuesOfContinuousStatesChanged = fmi2True, then at least one element of the continuous state vector has changed its value due to the function call. The new values of the states can be retrieved with fmi2GetContinuousStates. If no element of the continuous state vector has changed its value, valuesOfContinuousStatesChanged must return fmi2False.\nnextEventTimeDefined::fmi2Boolean: If nextEventTimeDefined = fmi2True, then the simulation shall integrate at most until time = nextEventTime, and shall call fmi2EnterEventMode at this time instant. If integration is stopped before nextEventTime, the definition of nextEventTime becomes obsolete.\nnextEventTime::fmi2Real: next event if nextEventTimeDefined=fmi2True\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2NewDiscreteStates.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiEnterContinuousTimeMode","page":"FMI version independent library functions","title":"FMI.fmiEnterContinuousTimeMode","text":"fmiEnterContinuousTimeMode(str::fmi2Struct)\n\nThe model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are “frozen”. This function has to be called when changing from Event Mode  into Continuous-Time Mode.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2EnterContinuousTimeMode.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiCompletedIntegratorStep","page":"FMI version independent library functions","title":"FMI.fmiCompletedIntegratorStep","text":"fmiCompletedIntegratorStep(str::fmi2Struct, c::FMU2Component, noSetFMUStatePriorToCurrentPoint::fmi2Boolean)\n\nThis function must be called by the environment after every completed step\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nnoSetFMUStatePriorToCurrentPoint::fmi2Boolean: Argument noSetFMUStatePriorToCurrentPoint = fmi2True if fmi2SetFMUState  will no longer be called for time instants prior to current time in this simulation run.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\nenterEventMode::Array{fmi2Boolean, 1}: Returns enterEventMode[1] to signal to the environment if the FMU shall call fmi2EnterEventMode\nterminateSimulation::Array{fmi2Boolean, 1}: Returns terminateSimulation[1] to signal if the simulation shall be terminated.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2CompletedIntegratorStep, fmi2SetFMUState.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiGetEventIndicators","page":"FMI version independent library functions","title":"FMI.fmiGetEventIndicators","text":"fmiGetEventIndicators(str::fmi2Struct)\n\nReturns the event indicators of the FMU\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\neventIndicators::Array{fmi2Real}:The event indicators are returned as a vector represented by an array of \"fmi2Real\" values.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiGetContinuousStates","page":"FMI version independent library functions","title":"FMI.fmiGetContinuousStates","text":"fmiGetContinuousStates(s::fmi2Struct)\n\nReturn the new (continuous) state vector x\n\nArguments\n\ns::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\ns::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\ns::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nx::Array{fmi2Real}: Returns an array of fmi2Real values representing the new continuous state vector x.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators.\n\n\n\n\n\n","category":"function"},{"location":"library/library/#FMI.fmiGetNominalsOfContinuousStates","page":"FMI version independent library functions","title":"FMI.fmiGetNominalsOfContinuousStates","text":"fmiGetNominalsOfContinuousStates(s::fmi2Struct)\n\nReturn the new (continuous) state vector x\n\nArguments\n\ns::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\ns::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\ns::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nx::Array{fmi2Real}: Returns an array of fmi2Real values representing the new continuous state vector x.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetNominalsOfContinuousStates.\n\n\n\n\n\n","category":"function"}]
}
